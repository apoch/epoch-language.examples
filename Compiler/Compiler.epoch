//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//



//
// Singly linked list data structure
//

type listnode<type T> : list<T> | nothing

structure list<type T> :
	T value,
	listnode<T> next


//
// List manipulation functions
//

prepend<type T> : list<T> ref thelist, T ref value
{
	list<T> newlist = value, thelist
	thelist = newlist
}

append_recurse<type T> : list<T> ref thelist, nothing, T ref value
{
	list<T> newlist = value, nothing
	thelist.next = newlist
}

append_recurse<type T> : list<T> ref thelist, list<T> ref tail, T ref value
{
	append_recurse<T>(tail, tail.next, value)
}


append<type T> : list<T> ref thelist, T ref value
{
	append_recurse<T>(thelist, thelist.next, value)
}


//
// List traversal/inspection functions
//

map<type T> : list<T> ref thelist, (func : T)
{
	func(thelist.value)
	map<T>(thelist.next, func)
}

map<type T> : nothing, (func : T)
{
}


listcontains : list<integer> ref thelist, integer value -> boolean ret = false
{
	if(thelist.value == value)
	{
		ret = true
	}
	else
	{
		ret = listcontains(thelist.next, value)
	}
}

listcontains : nothing, integer value -> boolean contains = false



//
// API for registering plugins with the C++ compiler
//

RegisterFunc : string name, (funcptr : ) 						[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : string) 						[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : boolean) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : real)	 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer)				[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, string)					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, string, string)				[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, boolean)				[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, integer)			[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, integer, integer, boolean)	[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, boolean, integer)		[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, boolean, boolean)		[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, integer, boolean, integer)	[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, integer, integer)		[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : boolean, integer, integer, integer)		[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : -> integer) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : -> buffer) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]



//
// Entrypoint - called when the plugin is loaded
//
// Performs function registration with the C++ compiler
//

entrypoint :
{
	RegisterFunc("PluginOnCompileStart", OnCompileStart)

	RegisterBytecodePlugin()
	RegisterCodeGenPlugin()
}



//
// Register the bytecode inspection callbacks with the host infrastructure
//

RegisterBytecodePlugin :
{
	RegisterFunc("PluginBytecodeGetBuffer", OnBytecodeGetBuffer)
	RegisterFunc("PluginBytecodeGetSize", OnBytecodeGetSize)

	print("Epoch Compiler - bytecode emitter plugin registered")
}


//
// Register code generation callbacks with the host infrastructure
//

RegisterCodeGenPlugin :
{
	RegisterFunc("PluginCodeGenProcessProgram", OnCodeGenProcessProgram)

	RegisterFunc("PluginCodeGenRegisterString", OnCodeGenRegisterString)
	RegisterFunc("PluginCodeGenRegisterAlias", OnCodeGenRegisterAlias)
	RegisterFunc("PluginCodeGenRegisterScope", OnCodeGenRegisterScope)
	RegisterFunc("PluginCodeGenRegisterVariable", OnCodeGenRegisterVariable)
	RegisterFunc("PluginCodeGenRegisterFunction", OnCodeGenRegisterFunction)
	RegisterFunc("PluginCodeGenRegisterLiteralBoolean", OnCodeGenRegisterLiteralBoolean)
	RegisterFunc("PluginCodeGenRegisterLiteralInteger", OnCodeGenRegisterLiteralInteger)
	RegisterFunc("PluginCodeGenRegisterLiteralString", OnCodeGenRegisterLiteralString)
	RegisterFunc("PluginCodeGenRegisterLiteralReal", OnCodeGenRegisterLiteralReal)
	RegisterFunc("PluginCodeGenRegisterAtomIdentifier", OnCodeGenRegisterAtomIdentifier)
	RegisterFunc("PluginCodeGenRegisterAtomIdentifierReference", OnCodeGenRegisterAtomIdentifierReference)
	RegisterFunc("PluginCodeGenRegisterOperatorInvoke", OnCodeGenRegisterOperatorInvoke)
	RegisterFunc("PluginCodeGenRegisterTypeAnnotation", OnCodeGenRegisterTypeAnnotation)
	RegisterFunc("PluginCodeGenRegisterRefBinding", OnCodeGenRegisterRefBinding)
	RegisterFunc("PluginCodeGenRegisterParenthetical", OnCodeGenRegisterParenthetical)
	RegisterFunc("PluginCodeGenSetExpressionType", OnCodeGenSetExpressionType)

	RegisterFunc("PluginCodeGenRegisterFunctionTag", OnCodeGenRegisterFunctionTag)
	RegisterFunc("PluginCodeGenRegisterFunctionTagParam", OnCodeGenRegisterFunctionTagParam)
	RegisterFunc("PluginCodeGenRegisterFunctionInvokeTag", OnCodeGenRegisterFunctionInvokeTag)

	RegisterFunc("PluginCodeGenRegisterStructureMemVar", OnCodeGenRegisterStructureMemVar)
	RegisterFunc("PluginCodeGenRegisterStructureMemFuncSig", OnCodeGenRegisterStructureMemFuncSig)
	RegisterFunc("PluginCodeGenRegisterStructureMemFuncSigParam", OnCodeGenRegisterStructureMemFuncSigParam)

	RegisterFunc("PluginCodeGenRegisterSumTypeBase", OnCodeGenRegisterSumTypeBase)

	RegisterFunc("PluginCodeGenRegisterTypeMatchParam", OnCodeGenRegisterTypeMatchParam)

	RegisterFunc("PluginCodeGenRegisterConstructors", OnCodeGenRegisterConstructors)

	RegisterFunc("PluginCodeGenEnterFunctionBody", OnCodeGenEnterFunctionBody)
	RegisterFunc("PluginCodeGenEnterFunctionReturn", OnCodeGenEnterFunctionReturn)
	RegisterFunc("PluginCodeGenEnterStatement", OnCodeGenEnterStatement)
	RegisterFunc("PluginCodeGenEnterSubStatement", OnCodeGenEnterSubStatement)
	RegisterFunc("PluginCodeGenRegisterPreOpStatement", OnCodeGenRegisterPreOpStatement)
	RegisterFunc("PluginCodeGenRegisterPostOpStatement", OnCodeGenRegisterPostOpStatement)

	RegisterFunc("PluginCodeGenEnterAssignment", OnCodeGenEnterAssignment)
	RegisterFunc("PluginCodeGenEnterAssignmentCompound", OnCodeGenEnterAssignmentCompound)
	RegisterFunc("PluginCodeGenAssignmentCompoundMember", OnCodeGenAssignmentCompoundMember)
	RegisterFunc("PluginCodeGenAssignmentCompoundEnd", OnCodeGenAssignmentCompoundEnd)

	RegisterFunc("PluginCodeGenEnterChain", OnCodeGenEnterChain)
	RegisterFunc("PluginCodeGenEnterEntity", OnCodeGenEnterEntity)
	RegisterFunc("PluginCodeGenEnterEntityCode", OnCodeGenEnterEntityCode)

	RegisterFunc("PluginCodeGenEnterTypeMatcher", OnCodeGenEnterTypeMatcher)

	RegisterFunc("PluginCodeGenRegisterGlobalBlock", OnCodeGenRegisterGlobalBlock)

	RegisterFunc("PluginCodeGenExit", OnCodeGenExitContext)

	RegisterFunc("PluginCodeGenRegisterFunctionSignature", OnCodeGenRegisterFunctionSig)
	RegisterFunc("PluginCodeGenRegisterFunctionSigParam", OnCodeGenRegisterFunctionSigParam)
	RegisterFunc("PluginCodeGenRegisterFunctionSignatureEnd", OnCodeGenRegisterFunctionSigEnd)

	print("Epoch Compiler - code generation plugin registered")
}



//
// Callback for when compilation on a program begins
//

OnCompileStart :
{
	print("Epoch Compiler - compilation started")
}


//
// Callback used to emit a byte to a bytecode stream
//

OnBytecodeEmitByte : integer b
{
	writebuffer(Hack, HackSize, b)
	++HackSize
}


//
// Callback used to emit a series of bytes to a bytecode stream
//

OnBytecodeEmitBytes : integer bytes, integer size
{
	writebuffer(Hack, HackSize, bytes, size)
	HackSize += size
}


//
// Callback used to retrieve a bytecode stream's pointer
//

OnBytecodeGetBuffer : -> buffer ret = Hack


//
// Callback used to retrieve the size of a bytecode stream
//

OnBytecodeGetSize : -> integer size = HackSize



OnBytecodeEmitInteger : integer value
{
	writebuffer(Hack, HackSize, (value) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x100) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x10000) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x1000000) & 0xff)
	++HackSize
}

OnBytecodeEmitInteger16 : integer16 value
{
	integer v = cast(integer, value)
	writebuffer(Hack, HackSize, (v) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (v / 0x100) & 0xff)
	++HackSize
}

OnBytecodeEmitReal : real value
{
	writebuffer(Hack, HackSize, value)
	HackSize = HackSize + 4
}

OnBytecodeEmitString : string value
{
	integer len = (length(value) + 1) * 2
	writebuffer(Hack, HackSize, value, len)
	HackSize += len
}

OnBytecodeEmitBoolean : boolean value
{
	OnBytecodeEmitByte(cast(integer, value))
}


OnBytecodePoolString : integer handle, string data
{
	OnBytecodeEmitByte(0x10)			// PoolString instruction
	OnBytecodeEmitInteger(handle)
	OnBytecodeEmitString(data)
}

OnBytecodeLexicalScope : integer name, integer parent, integer count
{
	OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(parent)
	OnBytecodeEmitInteger(count)
}

OnBytecodeLexicalScopeEntry : integer varname, integer vartype, boolean isreference, integer origin
{
	OnBytecodeEmitInteger(varname)
	OnBytecodeEmitInteger(vartype)
	OnBytecodeEmitInteger(origin)
	OnBytecodeEmitBoolean(isreference)
}

OnBytecodeInvokeOffset : integer name
{
	OnBytecodeEmitByte(0x27)			// InvokeOffset instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(0)
}

OnBytecodeHalt :
{
	OnBytecodeEmitByte(0x00)			// Halt instruction
}

OnBytecodeEnterFunction : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x01)			// EntityTags::Function
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitFunction :
{
	OnBytecodeEmitByte(0x09)			// Return instruction
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeInvoke : integer target
{
	OnBytecodeEmitByte(0x07)			// Invoke instruction
	OnBytecodeEmitInteger(target)
}

OnBytecodeEnterEntity : integer tag, integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(tag)
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitEntity :
{
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeBeginChain :
{
	OnBytecodeEmitByte(0x0d)			// BeginChain instruction
}

OnBytecodeEndChain :
{
	OnBytecodeEmitByte(0x0e)			// EndChain instruction
}

OnBytecodeDefineStructure : integer typeid, integer nummembers
{
	OnBytecodeEmitByte(0x14)			// DefineStructure instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(nummembers)
}

OnBytecodeStructureMember : integer name, integer typeid
{
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeReadReference :
{
	OnBytecodeEmitByte(0x17)			// ReadRef instruction
}

OnBytecodeReadReferenceAnnotated :
{
	OnBytecodeEmitByte(0x24)			// ReadRefAnnotated instruction
}

OnBytecodeAllocStructure : integer typeid
{
	OnBytecodeEmitByte(0x13)			// AllocStructure instruction
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeBindReference : integer frameskip, integer index
{
	if(index < 0)
	{
		breakpoint()
	}

	OnBytecodeEmitByte(0x03)			// BindRef instruction
	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(index)
}

OnBytecodeAssign :
{
	OnBytecodeEmitByte(0x06)			// Assign instruction
}

OnBytecodePushVarValue : integer name, integer typeid
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(name)

	integer family = typeid & 0xff000000

	if(typeid == 0x02000001)			// Buffer type signature
	{
		OnBytecodeCopyBuffer()
	}
	elseif(family == 0x03000000)			// Structure family signature
	{
		OnBytecodeCopyStructure()
	}
	elseif(family == 0x08000000)			// Template instance family signature
	{
		OnBytecodeCopyStructure()
	}
}

OnBytecodeCopyBuffer :
{
	OnBytecodeEmitByte(0x19)			// CopyBuffer instruction
}

OnBytecodeCopyStructure :
{
	OnBytecodeEmitByte(0x1b)			// CopyStructure instruction
}

OnBytecodeCopyToStructure : integer structurename, integer membername
{
	OnBytecodeEmitByte(0x16)			// CopyToStructure instruction
	OnBytecodeEmitInteger(structurename)
	OnBytecodeEmitInteger(membername)
}

OnBytecodeSetReturnRegister : integer varindex
{
	OnBytecodeEmitByte(0x0a)			// SetRetVal instruction
	OnBytecodeEmitInteger(varindex)
}

OnBytecodePushVarNoCopy : integer varname
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeInvokeIndirect : integer varname
{
	OnBytecodeEmitByte(0x08)			// InvokeIndirect instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeEnterPatternResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x02)			// EntityTags::PatternMatchingResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitPatternResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeConstructSumType :
{
	OnBytecodeEmitByte(0x21)			// ConstructSumType instruction
}

OnBytecodeEnterTypeResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x05)			// EntityTags::TypeResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitTypeResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodePopStack : integer bytes
{
	OnBytecodeEmitByte(0x04)			// Pop instruction
	OnBytecodeEmitInteger(bytes)
}

OnBytecodeBindRefByHandle : integer id
{
	OnBytecodeEmitByte(0x1d)
	OnBytecodeEmitInteger(id)
}

OnBytecodeBindStructReference : integer membertype, integer memberoffset
{
	OnBytecodeEmitByte(0x18)			// BindMemberRef instruction
	OnBytecodeEmitInteger(membertype)
	OnBytecodeEmitInteger(memberoffset)
}

OnBytecodePushType : integer typeid
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeAssignSumType :
{
	OnBytecodeEmitByte(0x23)			// AssignSumType instruction
}

OnBytecodePushLocal : boolean isparam, integer frameskip, integer offset, integer size
{
	if(isparam)
	{
		OnBytecodeEmitByte(0x26)		// ReadParam instruction
	}
	else
	{
		OnBytecodeEmitByte(0x25)		// ReadStack instruction
	}

	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(offset)
	OnBytecodeEmitInteger(size)
}

OnBytecodePushBoolean : boolean literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000003)		// Boolean type signature
	OnBytecodeEmitBoolean(literal)
}

OnBytecodePushLiteralString : integer literalhandle
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x02000000)		// String type signature
	OnBytecodeEmitInteger(literalhandle)
}

OnBytecodePushLiteralInteger : integer literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(literal)
}

OnBytecodePushLiteralInteger16 : integer16 literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000002)		// Integer16 type signature
	OnBytecodeEmitInteger16(literal)
}

OnBytecodePushTypeAnnotation : integer annotation
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(annotation)
}

OnBytecodePushLiteralFunction : integer name
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x09000000)		// Function family signature (N.B. not the actual function type!)
	OnBytecodeEmitInteger(name)
}

OnBytecodePushLiteralReal : real value
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000004)		// Real type signature
	OnBytecodeEmitReal(value)
}

OnBytecodeEmitFunctionSignature : integer typeid, integer rettype, integer paramcount
{
	OnBytecodeEmitByte(0x28)			// FuncSig instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(rettype)
	OnBytecodeEmitInteger(paramcount)
}

OnBytecodeEmitFunctionSigParam : integer paramtype, boolean isref
{
	OnBytecodeEmitInteger(paramtype)
	OnBytecodeEmitBoolean(isref)
}


GetTypeSize : integer typeid -> integer size = 0
{
	if(typeid == 0x01000001)			// Integer
	{
		size = 4
	}
	elseif(typeid == 0x01000003)			// Boolean
	{
		size = 1
	}
	elseif(typeid == 0x02000000)			// StringHandle
	{
		size = 4
	}
	elseif((typeid & 0xff000000) == 0x03000000)	// StructureHandle
	{
		size = 4
	}
	elseif((typeid & 0xff000000) == 0x07000000)	// SumType
	{
		size = 4 + GetLargestSumTypeBaseSize(typeid)
	}
	else
	{
		print("Undefined type for size retrieval - " ; cast(string, typeid))
		assert(false)
	}
}


//
// Data structures for holding the internal representation of a compiled program
//

structure StringTableEntry :
	integer Handle,
	string Data

structure TypeAlias :
	integer Alias,
	integer Base

structure StructureMemberVariable :
	integer Name,
	integer Type

structure StructureMemberFunctionRef :
	integer Name,
	FunctionSignature Signature


type StructureMember : StructureMemberVariable | StructureMemberFunctionRef

structure StructureDefinition :
	integer Name,
	integer Type,
	integer ConstructorName,
	integer AnonConstructorName,
	integer CopyConstructorName,
	list<StructureMember> Members


structure IdentifierAtom :
	integer Handle,
	integer Type,
	boolean IsReference

structure StringHandleAtom :
	integer Handle

structure OperatorInvokeAtom :
	integer OperatorName

structure TypeAnnotationAtom :
	integer Type

structure RefBinding :
	integer Identifier,
	integer StructureName,
	boolean IsReference,
	boolean InputIsReference

structure AtomSentinel :
	integer dummy


type ExpressionAtom : 	integer | integer16 | boolean | real | StringHandleAtom |
			IdentifierAtom | OperatorInvokeAtom | TypeAnnotationAtom | RefBinding |
			Statement |
			ParentheticalExpression |
			AtomSentinel


structure Expression :
	list<ExpressionAtom> Atoms,
	integer Type

type OptionalExpression : Expression | nothing

structure ExpressionList :
	list<Expression> Expressions

type OptionalExpressionList : ExpressionList | nothing


structure ParentheticalExpression :
	Expression Inner


structure Statement :
	integer Name,
	OptionalExpressionList Parameters,
	integer Type

structure Assignment :
	integer LHSName,
	integer LHSType,
	integer Annotation,
	Expression RHS

structure AssignmentCompound :
	list<integer> LHS,
	integer LHSType,
	integer Annotation,
	Expression RHS

structure PreOpStatement :
	integer Operator,
	list<integer> Operand

structure PostOpStatement :
	integer Operator,
	list<integer> Operand


type CodeBlockEntry : Statement | PreOpStatement | PostOpStatement |
		      Assignment | AssignmentCompound | EntityChain

structure CodeBlock :
	list<CodeBlockEntry> Entries

type OptionalCodeBlock : CodeBlock | nothing

structure Entity :
	integer Tag,
	integer PostfixTag,
	OptionalExpression Param,
	OptionalCodeBlock Code


structure EntityList :
	list<Entity> ActualList

type OptionalEntityList : EntityList | nothing


structure EntityChain :
	OptionalEntityList Entries


structure FunctionDefinition :
	integer Name,
	OptionalExpression Return,
	OptionalCodeBlock Code,
	boolean AnonymousReturn,
	integer InvokeTag


structure Variable :
	integer Name,
	integer VarType,
	boolean IsReference,
	integer Origin,
	integer Offset

structure Scope :
	integer Name,
	integer ParentName,
	list<Variable> Variables,
	integer ParamOffset,
	integer LocalOffset



structure ContextStackEntry :
	integer EntryType,
	integer EntryName


structure SumType :
	integer Name,
	integer Type,
	list<integer> Bases


structure Parameter :
	integer Name,
	integer Type,
	boolean IsReference


structure FunctionSignature :
	integer Name,
	list<Parameter> Parameters,
	integer ReturnType

structure TypeMatcher :
	integer Name,
	list<FunctionSignature> Overloads


structure FunctionTag :
	integer FunctionName,
	string TagName,
	list<string> Parameters




//
// Callback invoked when the code generation process can begin
//

OnCodeGenProcessProgram :
{
	print("Emitting program...")

	CodeGenEmitStrings(GlobalStrings)

	CodeGenEmitSumTypes(SumTypes)

	CodeGenRearrangeStructures(Structures)
	CodeGenEmitStructures(Structures)

	CodeGenEmitFunctionSignatures(FunctionSignatures)

	CodeGenEmitScopes(Scopes)
	CodeGenEmitFunctionTags(FunctionTags)

	CodeGenEmitGlobalBlockPrologue(GlobalCodeBlock)
	CodeGenEmitFunctions(Functions)
	CodeGenEmitGlobalBlockEpilogue(GlobalCodeBlock)

	CodeGenEmitTypeMatchers(TypeMatchers)
	CodeGenEmitConstructors(Structures)

	print("Done.")
}

OnCodeGenRegisterString : integer handle, string data
{
	StringTableEntry entry = handle, data
	prepend<StringTableEntry>(GlobalStrings, entry)
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer membertype
{
	StructureMemberVariable member = membername, membertype
	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettype
{
	FunctionSignature signature = name, dummyparamlist, rettype
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype, boolean isref
{
	Parameter param = 1, paramtype, isref
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}


FindStructureAndAddMember : list<StructureDefinition> ref structures, integer structurename, integer structuretype, StructureMember ref member
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMember(structures.value.Members, structures.value.Members.next, member)
	}
	else
	{
		FindStructureAndAddMember(structures.next, structurename, structuretype, member)
	}
}

FindStructureAndAddMember : nothing, integer structurename, integer structuretype, StructureMember ref member
{
	list<StructureMember> members = member, nothing
	StructureDefinition def = structurename, structuretype, 0, 0, 0, members

	AppendStructure(Structures, Structures.next, def)
}

AppendStructure : list<StructureDefinition> ref structures, list<StructureDefinition> ref tail, StructureDefinition ref def
{
	AppendStructure(tail, tail.next, def)
}

AppendStructure : list<StructureDefinition> ref structures, nothing, StructureDefinition ref def
{
	list<StructureDefinition> newtail = def, nothing
	structures.next = newtail
}

AppendStructureMember : list<StructureMember> ref members, list<StructureMember> ref tail, StructureMember ref member
{
	AppendStructureMember(tail, tail.next, member)
}

AppendStructureMember : list<StructureMember> ref members, nothing, StructureMember ref member
{
	list<StructureMember> newtail = member, nothing
	members.next = newtail
}


FindStructureAndAddMemberParam : list<StructureDefinition> ref structures, integer structurename, integer structuretype, integer membername, Parameter ref param
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMemberParam(structures.value.Members, membername, param)
	}
	else
	{
		FindStructureAndAddMemberParam(structures.next, structurename, structuretype, membername, param)
	}
}

AppendStructureMemberParam : list<StructureMember> ref members, integer membername, Parameter ref param
{
	boolean match = CheckMemberForAddingParam(members.value, membername, param)
	if(!match)
	{
		AppendStructureMemberParam(members.next, membername, param)
	}
}

CheckMemberForAddingParam : StructureMemberVariable ref member, integer membername, Parameter ref param -> false

CheckMemberForAddingParam : StructureMemberFunctionRef ref member, integer membername, Parameter ref param -> boolean ret = false
{
	if(member.Name == membername)
	{
		AppendParameter(member.Signature.Parameters, param)
		ret = true
	}
}



OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname
{
	FindStructureAndSetConstructors(Structures, structurename, constructorname, anonname, copyname)
	prepend<integer>(AutoGeneratedFunctionNames, constructorname)
	prepend<integer>(AutoGeneratedFunctionNames, anonname)
	prepend<integer>(AutoGeneratedFunctionNames, copyname)
}

FindStructureAndSetConstructors : list<StructureDefinition> ref structures, integer structurename, integer constructorname, integer anonname, integer copyname
{
	if(structures.value.Name == structurename)
	{
		structures.value.ConstructorName = constructorname
		structures.value.AnonConstructorName = anonname
		structures.value.CopyConstructorName = copyname
	}
	else
	{
		FindStructureAndSetConstructors(structures.next, structurename, constructorname, anonname, copyname)
	}
}

FindStructureAndSetConstructors : nothing, integer structurename, integer constructorname, integer anonname, integer copyname



OnCodeGenRegisterSumTypeBase : integer sumtypename, integer sumtypeid, integer basetypeid
{
	FindSumTypeAndAddBase(SumTypes, sumtypename, sumtypeid, basetypeid)
}


FindSumTypeAndAddBase : list<SumType> ref sumtypes, integer sumtypename, integer sumtypeid, integer basetypeid
{
	if(sumtypes.value.Type == sumtypeid)
	{
		prepend<integer>(sumtypes.value.Bases, basetypeid)
	}
	else
	{
		FindSumTypeAndAddBase(sumtypes.next, sumtypename, sumtypeid, basetypeid)
	}
}

FindSumTypeAndAddBase : nothing, integer sumtypename, integer sumtypeid, integer basetypeid
{
	list<integer> bases = basetypeid, nothing
	SumType st = sumtypename, sumtypeid, bases
	prepend<SumType>(SumTypes, st)
}



OnCodeGenRegisterScope : integer scopename, integer parentname
{
	Scope scope = scopename, parentname, dummyvarlist, 0, 0
	prepend<Scope>(Scopes, scope)
}

OnCodeGenRegisterVariable : integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	StoreVariableInScope(Scopes, scopename, varname, vartype, isref, origin)
}

StoreVariableInScope : list<Scope> ref scopes, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	if(scopes.value.Name == scopename)
	{
		integer size = 4		// TODO - actual variable sizes

		if((vartype & 0xff000000) == 0x07000000)		// Sum type family signature
		{
			size = 8
		}

		integer offset = -1
		if(origin == 1)			// VARIABLE_ORIGIN_PARAMETER
		{
			if(isref)
			{
				size = 8
			}

			offset = scopes.value.ParamOffset
			scopes.value.ParamOffset = scopes.value.ParamOffset + size
		}
		else
		{
			offset = scopes.value.LocalOffset
			scopes.value.LocalOffset = scopes.value.LocalOffset + size
		}

		Variable var = varname, vartype, isref, origin, offset
		append<Variable>(scopes.value.Variables, var)
	}
	else
	{
		StoreVariableInScope(scopes.next, scopename, varname, vartype, isref, origin)
	}
}

StoreVariableInScope : nothing, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	print("No scope available")
	assert(false)
}


OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
}


OnCodeGenRegisterFunction : integer funcname
{
	FunctionDefinition func = funcname, nothing, nothing, false, 0
	prepend<FunctionDefinition>(Functions, func)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack
}

OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpressions.value = dummyexpression

	Functions.value.AnonymousReturn = anonymous
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	PopContext(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToSubStatement(ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToSubStatement(ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
		AppendEntityToChain(ChainStack, entity)
		PopEntityStack(EntityStack, EntityStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		EntityChain chain = ChainStack.value
		CodeBlockEntry cbe = chain
		AppendEntryToCurrentCodeBlock(cbe)
		PopChain(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		ParentheticalExpression parenthetical = ScratchExpressions.value
		ExpressionAtom atom = parenthetical
		PopExpression(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}

PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	print("No contexts available")
	assert(false)
}

PopExpression : list<Expression> ref thelist, list<Expression> ref next
{
	thelist = next
}

PopExpression : list<Expression> ref thelist, nothing



PopCodeBlock : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref next
{
	stack = next
}

PopCodeBlock : list<OptionalCodeBlock> ref stack, nothing


PopEntityStack : list<Entity> ref stack, list<Entity> ref next
{
	stack = next
}

PopEntityStack : list<Entity> ref stack, nothing


PopChain : list<EntityChain> ref stack, list<EntityChain> ref next
{
	stack = next
}

PopChain : list<EntityChain> ref stack, nothing



PopCurrentStatementAndAppendToScratchExpression : list<Expression> ref expressions, list<Expression> ref tail
{
	Statement stmt = SubStatements.value
	ExpressionAtom atom = stmt

	expressions = tail

	PlaceAtomInScratchExpression(atom)
	PopSubStatement(SubStatements, SubStatements.next)
}

SetReturnExpression : FunctionDefinition ref funcdef, Expression ref expr
{
	funcdef.Return = expr
	ScratchExpressions.value = dummyexpression
}

SetGlobalCodeBlock : CodeBlock ref block
{
	GlobalCodeBlock = block
}

PopSubStatement : list<Statement> ref statements, list<Statement> ref tail
{
	statements = tail
}



AppendExpressionToSubStatement : Expression ref expr
{
	AppendExpressionToStatement(SubStatements.value, expr)
}


OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	TypeMatcher matcher = matchername, dummysignaturelist
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


PlaceAtomInScratchExpression : ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(ScratchExpressions.value.Atoms.value))
	{
		list<ExpressionAtom> atoms = atom, nothing
		ScratchExpressions.value = Expression(atoms, 0)
	}
	else
	{
		AppendAtomToExpression(ScratchExpressions.value.Atoms, ScratchExpressions.value.Atoms.next, atom)
	}
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0xff000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(TypeAliases, literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifierReference : integer idhandle
{
	IdentifierAtom id = idhandle, 0, true
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterTypeAnnotation : integer annotationtype
{
	TypeAnnotationAtom taa = annotationtype
	ExpressionAtom atom = taa
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}


ExpressionAtomIsSentinel : AtomSentinel 	   ref sentinel    -> boolean ret = true
ExpressionAtomIsSentinel : StringHandleAtom 	   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : IdentifierAtom 	   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : OperatorInvokeAtom 	   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : TypeAnnotationAtom 	   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : integer 		   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : integer16 		   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : boolean 		   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : real 		   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : Statement		   ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : RefBinding              ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : ParentheticalExpression ref nonsentinel -> boolean ret = false



AppendAtomToExpression : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, ExpressionAtom ref atom
{
	AppendAtomToExpression(tail, tail.next, atom)
}

AppendAtomToExpression : list<ExpressionAtom> ref atoms, nothing, ExpressionAtom ref atom
{
	list<ExpressionAtom> newatoms = atom, nothing
	atoms.next = newatoms
}


OnCodeGenEnterStatement : integer statementname, integer statementtype
{
	Statement statement = statementname, nothing, statementtype

	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statementname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}

OnCodeGenEnterAssignment : integer lhsname, integer lhstype, integer annotation
{
	Assignment assignment = lhsname, lhstype, annotation, Expression(dummyatomlist, 0)
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpressions.value = Expression(dummyatomlist, 0)
}


OnCodeGenEnterAssignmentCompound : integer lhsname, integer lhstype, integer annotation
{
	list<integer> idlist = lhsname, nothing
	AssignmentCompound assignment = idlist, lhstype, annotation, Expression(dummyatomlist, 0)
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundMember : integer membername
{
	FindCurrentFunctionAndAppendCompoundMember(membername)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpressions.value = Expression(dummyatomlist, 0)
}


OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}



AppendEntryToCurrentCodeBlock : CodeBlockEntry ref cbe
{
	AppendEntryToCurrentCodeBlockWorker(CurrentCodeBlockStack, cbe)
}

AppendEntryToCurrentCodeBlockWorker : list<OptionalCodeBlock> ref blockstack, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(blockstack, blockstack.value, entry)
}

AppendEntryToCurrentCodeBlockWorker : nothing, CodeBlockEntry ref entry
{
	print("No code block is being processed")
	assert(false)
}


FindCurrentFunctionAndAppendCompoundMember : integer membername
{
	FindLastAssignmentAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}



FindLastAssignmentAndAppendCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(code.Entries, code.Entries.next, membername)
}



AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, CodeBlock ref code, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(code.Entries, entry)
}

AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> stmtlist = entry, nothing
	CodeBlock block = stmtlist
	OptionalCodeBlock blockwrap = block
	prepend<OptionalCodeBlock>(stack, blockwrap)
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(entries, entries.next, entry)
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> newlist = entry, nothing
	entries.next = newlist
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, CodeBlockEntry ref value
{
	AppendEntryToCodeBlock(tail, tail.next, value)
}


FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}

AppendCompoundMemberHelper : AssignmentCompound ref a, integer membername
{
	AppendCompoundMember(a.LHS, a.LHS.next, membername)
}

AppendCompoundMember : list<integer> ref members, list<integer> ref tail, integer membername
{
	AppendCompoundMember(tail, tail.next, membername)
}

AppendCompoundMember : list<integer> ref members, nothing, integer membername
{
	list<integer> newtail = membername, nothing
	members.next = newtail
}



FindCurrentStatementAndAppendExpression : Expression ref expression
{
	FindLastStatementInBlockAndAppendExpression(CurrentCodeBlockStack.value, expression)
}



FindCurrentAssignmentAndSetExpression : Expression ref expression
{
	FindLastAssignmentInBlockAndSetExpression(CurrentCodeBlockStack.value, expression)
}



FindLastStatementInBlockAndAppendExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastStatementAndAppendExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastStatementAndAppendExpression(tail, tail.next, expression)
}

FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	AppendExpressionToStatement(codeblockentries.value, expression)
}

AppendExpressionToStatement : Statement ref statement, Expression ref expression
{
	AppendExpressionToStatementParams(statement, statement.Parameters, expression)
}

AppendExpressionToStatementParams : Statement ref statement, ExpressionList ref parameters, Expression ref expression
{
	AppendExpression(parameters.Expressions, parameters.Expressions.next, expression)
}

AppendExpressionToStatementParams : Statement ref statement, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	ExpressionList params = newlist
	statement.Parameters = params
}

AppendExpression : list<Expression> ref expressions, list<Expression> ref tail, Expression ref expression
{
	AppendExpression(tail, tail.next, expression)
}

AppendExpression : list<Expression> ref expressions, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	expressions.next = newlist
}


FindLastAssignmentInBlockAndSetExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastAssignmentAndSetExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastAssignmentAndSetExpression(tail, tail.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	SetAssignmentExpression(codeblockentries.value, expression)
}

SetAssignmentExpression : Assignment ref assignment, Expression ref expression
{
	assignment.RHS = expression
}

SetAssignmentExpression : AssignmentCompound ref assignment, Expression ref expression
{
	assignment.RHS = expression
}



SetFunctionCodeBlock : FunctionDefinition ref funcdef, OptionalCodeBlock ref optblock
{
	SetFunctionCodeBlockWorker(funcdef, optblock)
}

SetFunctionCodeBlock : nothing, OptionalCodeBlock ref optblock
{
	print("No function in flight")
	assert(false)
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, CodeBlock ref block
{
	funcdef.Code = block
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, nothing



CodeGenEmitStrings : list<StringTableEntry> ref table
{
	map<StringTableEntry>(table, CodeGenEmitSingleString)
}

CodeGenEmitSingleString : StringTableEntry entry			// TODO - this should be passed by ref
{
	if(entry.Handle != 0)
	{
		OnBytecodePoolString(entry.Handle, entry.Data)
	}
}


CodeGenEmitStructures : list<StructureDefinition> ref structures
{
	CodeGenEmitStructures(structures.next)
	CodeGenEmitSingleStructure(structures.value)
}

CodeGenEmitStructures : nothing


CodeGenEmitSingleStructure : StructureDefinition ref def
{
	if(def.Name != 0)
	{
		integer membercount = CountMembers(def.Members)
		OnBytecodeDefineStructure(def.Type, membercount)
		CodeGenEmitMembers(def.Members)
	}
}

CodeGenEmitMembers : list<StructureMember> ref members
{
	CodeGenEmitMember(members.value)
	CodeGenEmitMembers(members.next)
}

CodeGenEmitMembers : nothing

CodeGenEmitMember : StructureMemberVariable ref memvar
{
	OnBytecodeStructureMember(memvar.Name, memvar.Type)
}

CodeGenEmitMember : StructureMemberFunctionRef ref member
{
	OnBytecodeStructureMember(member.Name, 0x09000000)
}


CountMembers : list<StructureMember> ref members -> integer count = 0
{
	CountMembers(members, count)
}

CountMembers : list<StructureMember> ref members, integer ref count
{
	++count
	CountMembers(members.next, count)
}

CountMembers : nothing, integer ref count





CodeGenEmitScopes : list<Scope> ref scopes
{
	CodeGenEmitScopes(scopes.next)
	CodeGenEmitSingleScope(scopes.value, scopes.value.Name)
}

CodeGenEmitScopes : nothing


CodeGenEmitSingleScope : Scope ref scope, integer funcname
{
	if(scope.Name != 0)
	{
		integer varcount = CountScopeVariables(scope)
		OnBytecodeLexicalScope(scope.Name, scope.ParentName, varcount)
		CodeGenEmitVariables(scope.Variables, funcname)
	}
}


CountScopeVariables : Scope ref scope -> integer count = 0
{
	CountScopeVariables(scope.Variables, count)
}

CountScopeVariables : list<Variable> ref variables, integer ref count
{
	if(variables.value.Name != 0)
	{
		++count
	}

	CountScopeVariables(variables.next, count)
}

CountScopeVariables : nothing, integer ref count


CodeGenEmitVariables : list<Variable> ref vars, integer funcname
{
	CodeGenEmitSingleVariable(vars.value, funcname)
	CodeGenEmitVariables(vars.next, funcname)
}

CodeGenEmitVariables : nothing, integer funcname


CodeGenEmitSingleVariable : Variable ref var, integer funcname
{
	if(var.Name != 0)
	{
		integer basetype = var.VarType
		while((basetype & 0xff000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(TypeAliases, basetype)
		}


		if((var.Origin == 2) && (listcontains(CustomConstructors, funcname)))
		{
			OnBytecodeLexicalScopeEntry(var.Name, basetype, var.IsReference, 0)
		}
		else
		{
			OnBytecodeLexicalScopeEntry(var.Name, basetype, var.IsReference, var.Origin)
		}
	}
}


CodeGenEmitFunctions : list<FunctionDefinition> ref table
{
	CodeGenEmitSingleFunction(table.value)
	CodeGenEmitFunctions(table.next)
}

CodeGenEmitFunctions : nothing


CodeGenEmitSingleFunction : FunctionDefinition ref def
{
	if(def.Name != 0)
	{
		EmittingFunctionName = def.Name
		OnBytecodeEnterFunction(def.Name)
		CodeGenEmitFunctionReturn(def.Return)

		if(def.InvokeTag != 0)
		{
			OnBytecodeInvoke(def.InvokeTag)
		}

		CodeGenEmitCodeBlock(def.Code)
		if(listcontains(CustomConstructors, def.Name))
		{
			OnBytecodePushVarNoCopy(FindReturnVariableName())
			OnBytecodeBindReference(0, 0)			// TODO - kind of a hack
			OnBytecodeAssign()
		}
		else
		{
			if(def.AnonymousReturn)
			{
				CodeGenEmitReturnRegisterAnonymous(def.Return)
			}
			else
			{
				CodeGenEmitReturnRegister(def.Return)
			}
		}
		OnBytecodeExitFunction()
	}
}

CodeGenEmitFunctionReturn : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitFunctionReturn : nothing


CodeGenEmitReturnRegister : Expression ref expr
{
	integer index = FindReturnVariableIndex()
	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegister : nothing


CodeGenEmitReturnRegisterAnonymous : Expression ref expr
{
	integer index = FindReturnVariableIndex()

	OnBytecodeBindReference(0, index)
	OnBytecodeAssign()

	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegisterAnonymous : nothing



CodeGenEmitCodeBlock : CodeBlock ref block
{
	CodeGenEmitCodeBlockEntries(block.Entries)
}

CodeGenEmitCodeBlock : nothing


CodeGenEmitCodeBlockEntries : list<CodeBlockEntry> ref entries
{
	CodeGenEmitSingleCodeBlockEntry(entries.value)
	CodeGenEmitCodeBlockEntries(entries.next)
}

CodeGenEmitCodeBlockEntries : nothing


CodeGenEmitSingleCodeBlockEntry : Statement ref s
{
	boolean sumtype = SumTypeExists(s.Name)
	boolean constructssumtype = false
	if((s.Type & 0xff000000) == 0x07000000)
	{
		constructssumtype = true
	}

	boolean constructorcall = false
	//if(GetTypeByName(s.Name) != 0)
	//{
	//	constructorcall = true
	//}

	CodeGenEmitExpressionList(s.Parameters, constructssumtype, constructorcall)

	Variable var = 0, 0, false, 0, 0
	FindVariableDataInScope(EmittingFunctionName, s.Name, var)
	if((var.Name != 0) && ((var.VarType & 0xff000000) == 0x09000000))
	{
		OnBytecodeInvokeIndirect(s.Name)
	}
	elseif(sumtype)
	{
		OnBytecodeConstructSumType()
	}
	elseif(FunctionIsAutoGenOrHasIR(s.Name))
	{
		OnBytecodeInvokeOffset(s.Name)
	}
	else
	{
		OnBytecodeInvoke(s.Name)
	}
}

CodeGenEmitSingleCodeBlockEntry : Assignment ref a
{
	CodeGenEmitExpressionAtoms(a.RHS.Atoms, false, false)

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0xff000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}

CodeGenEmitSingleCodeBlockEntry : AssignmentCompound ref a
{
	CodeGenEmitExpressionAtoms(a.RHS.Atoms, false, false)

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHS.value, frames)
	OnBytecodeBindReference(frames, index)


	integer structurename = GetNameOfStructureByType(FindVariableType(a.LHS.value))
	BindAssignmentMembers(a.LHS.next, structurename)

	if((a.LHSType & 0xff000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()	
	}
	else
	{
		OnBytecodeAssign()
	}
}


CodeGenEmitBindingsForOperand : list<integer> ref operand
{
	integer frames = 0
	integer index = FindVariable(operand.value, frames)
	OnBytecodeBindReference(frames, index)

	integer structurename = GetNameOfStructureByType(FindVariableType(operand.value))
	BindAssignmentMembers(operand.next, structurename)
}


CodeGenEmitSingleCodeBlockEntry : PreOpStatement ref preop
{
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(preop.Operator)
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeAssign()
	// TODO - push extra copy of value LAST if in a parenthetical
}

CodeGenEmitSingleCodeBlockEntry : PostOpStatement ref postop
{
	// TODO - push extra copy of value FIRST if in a parenthetical
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(postop.Operator)
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeAssign()
}



CodeGenEmitSingleCodeBlockEntry : EntityChain ref chain
{
	OnBytecodeBeginChain()
	CodeGenEmitEntityChain(chain.Entries)
	OnBytecodeEndChain()
}


CodeGenEmitEntityChain : EntityList ref entities
{
	CodeGenEmitEntityList(entities.ActualList)
}

CodeGenEmitEntityList : list<Entity> ref thelist
{
	if(thelist.value.Tag != 0)
	{
		CodeGenEmitExpression(thelist.value.Param, false, false)
		OnBytecodeEnterEntity(thelist.value.Tag, 0)
		CodeGenEmitCodeBlock(thelist.value.Code)
		OnBytecodeExitEntity()
	}

	CodeGenEmitEntityList(thelist.next)
}

CodeGenEmitEntityList : nothing


BindAssignmentMembers : list<integer> ref lhsmembers, integer structurename
{
	integer membertype = GetStructureMemberType(Structures, structurename, lhsmembers.value)
	integer memberoffset = GetStructureMemberOffset(Structures, structurename, lhsmembers.value)
	OnBytecodeBindStructReference(membertype, memberoffset)

	// Recurse
	BindAssignmentMembers(lhsmembers.next, GetNameOfType(membertype))
}

BindAssignmentMembers : nothing, integer structurename



CodeGenEmitExpressionList : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpressionList : ExpressionList ref expressions, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionList(expressions.Expressions, constructssumtype, constructorcall)
}

CodeGenEmitExpressionList : list<Expression> ref expressions, boolean constructssumtype, boolean constructorcall
{
	if((expressions.value.Type & 0xff000000) == 0x07000000)
	{
		constructssumtype = true
	}

	CodeGenEmitExpressionAtoms(expressions.value.Atoms, constructssumtype, constructorcall)
	CodeGenEmitExpressionList(expressions.next, constructssumtype, constructorcall)
}

CodeGenEmitExpression : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpression : Expression ref expr, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionAtoms(expr.Atoms, constructssumtype, constructorcall)
}

CodeGenEmitExpressionAtoms : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean constructorcall
{
	boolean needsref = false
	CodeGenEmitExpressionAtomsWorker(atoms, constructssumtype, needsref, constructorcall)
	if(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

CodeGenEmitExpressionAtomsWorker : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean ref needsref, boolean constructorcall
{
	boolean thisneedsref = CodeGenCheckAtomForReadRef(atoms.value)
	if(thisneedsref)
	{
		needsref = true
	}
	elseif(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
		needsref = false
	}

	CodeGenEmitSingleAtom(atoms.value, constructorcall)
	CodeGenEmitExpressionAtomsWorker(atoms.next, constructssumtype, needsref, constructorcall)
}

CodeGenEmitExpressionAtomsWorker : nothing, boolean constructssumtype, boolean ref needsref, boolean constructorcall


CodeGenCheckAtomForReadRef : RefBinding ref atom -> !atom.IsReference

CodeGenCheckAtomForReadRef : integer ref atom -> false
CodeGenCheckAtomForReadRef : integer16 ref atom -> false
CodeGenCheckAtomForReadRef : boolean ref atom -> false
CodeGenCheckAtomForReadRef : real ref atom -> false
CodeGenCheckAtomForReadRef : IdentifierAtom ref atom -> false
CodeGenCheckAtomForReadRef : StringHandleAtom ref atom -> false
CodeGenCheckAtomForReadRef : OperatorInvokeAtom ref atom -> false
CodeGenCheckAtomForReadRef : TypeAnnotationAtom ref atom -> false
CodeGenCheckAtomForReadRef : Statement ref atom -> false
CodeGenCheckAtomForReadRef : ParentheticalExpression ref atom -> false
CodeGenCheckAtomForReadRef : AtomSentinel ref atom -> false




CodeGenEmitSingleAtom : integer ref literalinteger, boolean constructor
{
	OnBytecodePushLiteralInteger(literalinteger)
}

CodeGenEmitSingleAtom : integer16 ref literalinteger16, boolean constructor
{
	OnBytecodePushLiteralInteger16(literalinteger16)
}

CodeGenEmitSingleAtom : boolean ref literalboolean, boolean constructor
{
	OnBytecodePushBoolean(literalboolean)
}

CodeGenEmitSingleAtom : real ref literalreal, boolean constructor
{
	OnBytecodePushLiteralReal(literalreal)
}

CodeGenEmitSingleAtom : StringHandleAtom ref atom, boolean constructor
{
	OnBytecodePushLiteralString(atom.Handle)
}

CodeGenEmitSingleAtom : OperatorInvokeAtom ref atom, boolean constructor
{
	OnBytecodeInvoke(atom.OperatorName)
}

CodeGenEmitSingleAtom : IdentifierAtom ref idatom, boolean constructor
{
	if(idatom.Type == 0x00000004)							// Nothing type signature
	{
		OnBytecodePushLiteralInteger(0)
	}
	else
	{
		if(FunctionIsAutoGenOrHasIR(idatom.Handle))
		{
			OnBytecodePushLiteralFunction(idatom.Handle)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			OnBytecodePushLiteralString(idatom.Handle)
		}	
		else
		{
			if(idatom.Type == 0x01000000)					// Identifier type signature
			{
				if(!constructor)
				{
					OnBytecodePushLiteralString(idatom.Handle)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
			}
			elseif((idatom.Type & 0xff000000) == 0x09000000)		// Function type family signature
			{
				OnBytecodePushLiteralFunction(idatom.Handle)
			}
			else
			{
				if(idatom.IsReference)
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
				else
				{
					OnBytecodePushVarValue(idatom.Handle, idatom.Type)
				}
			}
		}
	}
}

CodeGenEmitSingleAtom : TypeAnnotationAtom ref atom, boolean constructor
{
	OnBytecodePushTypeAnnotation(atom.Type)
}

CodeGenEmitSingleAtom : Statement ref atom, boolean constructor
{
	CodeGenEmitSingleCodeBlockEntry(atom)
}

CodeGenEmitSingleAtom : RefBinding ref atom, boolean constructor
{
	integer memtype = GetStructureMemberType(Structures, atom.StructureName, atom.Identifier)
	integer memoffset = GetStructureMemberOffset(Structures, atom.StructureName, atom.Identifier)
	OnBytecodeBindStructReference(memtype, memoffset)
}

CodeGenEmitSingleAtom : ParentheticalExpression ref expr, boolean constructor
{
	CodeGenEmitExpression(expr.Inner, false, false)
}

CodeGenEmitSingleAtom : AtomSentinel ref sentinel, boolean constructor


GetNameOfStructureByType : integer typeid -> integer name = 0
{
	name = GetNameOfStructureByType(Structures, typeid)
}

GetNameOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.Name
	}
	else
	{
		name = GetNameOfStructureByType(structures.next, typeid)
	}
}

GetNameOfStructureByType : nothing, integer typeid -> integer name = 0



GetSizeOfStructureByType : integer typeid -> integer size = 0
{
	size = GetSizeOfStructureByType(Structures, typeid)
}

GetSizeOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer size = 0
{
	if(structures.value.Type == typeid)
	{
		size = GetTotalMemberSize(structures.value.Members)
	}
	else
	{
		size = GetSizeOfStructureByType(structures.next, typeid)
	}
}

GetSizeOfStructureByType : nothing, integer typeid -> integer name = 0


GetTotalMemberSize : list<StructureMember> ref members -> integer size = 0
{
	size = GetMemberSize(members.value) + GetTotalMemberSize(members.next)
}

GetTotalMemberSize : nothing -> integer size = 0



GetStructureMemberType : list<StructureDefinition> ref structures, integer structurename, integer membername -> integer rtype = 0
{
	if(structures.value.Name == structurename)
	{
		rtype = GetMemberType(structures.value.Members, membername)
	}
	else
	{
		rtype = GetStructureMemberType(structures.next, structurename, membername)
	}
}

GetStructureMemberType : nothing, integer structurename, integer membername -> integer rtype = 0

GetMemberType : list<StructureMember> ref members, integer membername -> integer rtype = 0
{
	if(GetMemberName(members.value) == membername)
	{
		rtype = GetMemberTypeDecompose(members.value)
	}
	else
	{
		rtype = GetMemberType(members.next, membername)
	}
}

GetMemberType : nothing, integer membername -> integer rtype = 0

GetMemberTypeDecompose : StructureMemberVariable ref memvar -> integer rtype = memvar.Type

GetMemberTypeDecompose : StructureMemberFunctionRef ref member -> integer rtype = 0x09000000



GetMemberName : StructureMemberVariable ref memvar -> integer name = memvar.Name

GetMemberName : StructureMemberFunctionRef ref member -> integer name = member.Name


GetMemberOffset : list<StructureMember> ref members, integer membername -> integer offset = 0
{
	integer counter = 0
	GetMemberOffset(members, membername, counter)
	offset = counter
}

GetMemberOffset : list<StructureMember> ref members, integer membername, integer ref counter
{
	if(GetMemberName(members.value) != membername)
	{
		counter += GetMemberSize(members.value)
		GetMemberOffset(members.next, membername, counter)
	}
}

GetMemberOffset : nothing, integer membername, integer ref counter

GetMemberSize : StructureMemberVariable ref memvar -> integer rtype = GetTypeSize(memvar.Type)

GetMemberSize : StructureMemberFunctionRef ref member -> 4



GetStructureMemberOffset : list<StructureDefinition> ref structures, integer structurename, integer membername -> integer offset = 0
{
	if(structures.value.Name == structurename)
	{
		offset = GetMemberOffset(structures.value.Members, membername)
	}
	else
	{
		offset = GetStructureMemberOffset(structures.next, structurename, membername)
	}
}

GetStructureMemberOffset : nothing, integer structurename, integer membername -> 0



CodeGenEmitSumTypes : list<SumType> ref sumtypes
{
	CodeGenEmitSingleSumType(sumtypes.value)
	CodeGenEmitSumTypes(sumtypes.next)
}

CodeGenEmitSumTypes : nothing


CodeGenEmitSingleSumType : SumType ref sumtype
{
	if(sumtype.Type != 0)
	{
		OnBytecodeEmitByte(0x1f)			// SumTypeDef instruction
		OnBytecodeEmitInteger(sumtype.Type)
		OnBytecodeEmitInteger(CountSumTypeBases(sumtype.Bases))
		CodeGenEmitSumTypeBase(sumtype.Bases)
	}
}

CountSumTypeBases : list<integer> ref bases -> integer count = 0
{
	count = CountSumTypeBases(bases.next)

	if(bases.value != 0)	
	{
		++count
	}
}

CountSumTypeBases : nothing -> integer count = 0

CodeGenEmitSumTypeBase : list<integer> ref bases
{
	CodeGenEmitSumTypeBase(bases.next)

	if(bases.value != 0)
	{
		OnBytecodeEmitInteger(bases.value)
	}
}

CodeGenEmitSumTypeBase : nothing


SumTypeExists : integer typename -> boolean exists = SumTypeExists(SumTypes, typename)

SumTypeExists : list<SumType> ref sumtypes, integer typename -> boolean exists = false
{
	if(sumtypes.value.Name == typename)
	{
		exists = true
	}
	else
	{
		exists = SumTypeExists(sumtypes.next, typename)
	}
}

SumTypeExists : nothing, integer typename -> boolean exists = false


FindSumTypeName : integer typeid -> integer name = FindSumTypeName(SumTypes, typeid)

FindSumTypeName : list<SumType> ref sumtypes, integer typeid -> integer name = 0
{
	if(sumtypes.value.Type == typeid)
	{
		name = sumtypes.value.Name
	}
	else
	{
		name = FindSumTypeName(sumtypes.next, typeid)
	}
}

FindSumTypeName : nothing, integer typeid -> 0



FunctionIsAutoGenOrHasIR : integer funcname -> boolean ret = false
{
	if(FunctionExists(Functions, funcname))
	{
		ret = true
	}
	elseif(TypeMatcherExists(TypeMatchers, funcname))
	{
		ret = true
	}
	elseif(FunctionIsAutoGen(AutoGeneratedFunctionNames, funcname))
	{
		ret = true
	}
}

FunctionExists : list<FunctionDefinition> ref funcs, integer funcname -> boolean ret = false
{
	if(funcs.value.Name == funcname)
	{
		ret = true
	}
	else
	{
		ret = FunctionExists(funcs.next, funcname)
	}
}

FunctionExists : nothing, integer funcname -> boolean ret = false


FunctionIsAutoGen : list<integer> ref genlist, integer target -> boolean ret = false
{
	if(genlist.value == target)
	{
		ret = true
	}
	else
	{
		ret = FunctionIsAutoGen(genlist.next, target)
	}
}

FunctionIsAutoGen : nothing, integer target -> boolean ret = false



TypeMatcherExists : list<TypeMatcher> ref matchers, integer matchername -> boolean ret = false
{
	if(matchers.value.Name == matchername)
	{
		ret = true
	}
	else
	{
		ret = TypeMatcherExists(matchers.next, matchername)
	}
}

TypeMatcherExists : nothing, integer matchername -> boolean ret = false



FindVariable : integer name, integer ref frames -> integer index = FindVariableInScope(EmittingFunctionName, name)
{
	if(index < 0)
	{
		index = FindVariableInScope(GlobalCodeBlockName, name)
		frames = -1
	}
}



FindVariableInScope : integer scopename, integer varname -> integer index = FindVariableInScopeList(Scopes, scopename, varname)

FindVariableInScopeList : list<Scope> ref scopes, integer scopename, integer varname -> integer index = -1
{
	if(scopes.value.Name == scopename)
	{
		index = 0
		FindVariableInSingleScope(scopes.value.Variables, varname, index)
	}
	else
	{
		index = FindVariableInScopeList(scopes.next, scopename, varname)
	}
}

FindVariableInScopeList : nothing, integer scopename, integer varname -> integer index = -1

FindVariableInSingleScope : list<Variable> ref vars, integer varname, integer ref index
{
	if(vars.value.Name != varname)
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindVariableInSingleScope(vars.next, varname, index)
	}
}

FindVariableInSingleScope : nothing, integer varname, integer ref index
{
	index = -1
}


FindReturnVariableIndex : -> integer index = FindReturnVariableInScopeList(Scopes, EmittingFunctionName)

FindReturnVariableName: -> integer index = FindReturnVariableNameInScopeList(Scopes, EmittingFunctionName)


FindReturnVariableInScopeList : list<Scope> ref scopes, integer scopename -> integer index = -1
{
	if(scopes.value.Name == scopename)
	{
		index = 0
		FindReturnVariableInSingleScope(scopes.value.Variables, index)
	}
	else
	{
		index = FindReturnVariableInScopeList(scopes.next, scopename)
	}
}

FindReturnVariableInSingleScope : list<Variable> ref vars, integer ref index
{
	if(vars.value.Origin != 2)		// VARIABLE_ORIGIN_RETURN
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindReturnVariableInSingleScope(vars.next, index)
	}
}

FindReturnVariableInSingleScope : nothing, integer ref index
{
	index = -1
}


FindReturnVariableNameInScopeList : list<Scope> ref scopes, integer scopename -> integer name = 0
{
	if(scopes.value.Name == scopename)
	{
		FindReturnVariableNameInSingleScope(scopes.value.Variables, name)
	}
	else
	{
		name = FindReturnVariableNameInScopeList(scopes.next, scopename)
	}
}

FindReturnVariableNameInSingleScope : list<Variable> ref vars, integer ref name
{
	if(vars.value.Origin == 2)		// VARIABLE_ORIGIN_RETURN
	{
		name = vars.value.Name
	}
	else
	{
		FindReturnVariableNameInSingleScope(vars.next, name)
	}
}

FindReturnVariableNameInSingleScope : nothing, integer ref name
{
	name = 0
}



FindVariableType : integer varname -> integer rettype = 0
{
	Variable var = 0, 0, false, 0, 0
	FindVariableDataInScope(EmittingFunctionName, varname, var)
	rettype = var.VarType
}


FindVariableDataInScope : integer scopename, integer varname, Variable ref outvar 
	->
	boolean found = FindVariableDataInScopeList(Scopes, scopename, varname, outvar)

FindVariableDataInScopeList : list<Scope> ref scopes, integer scopename, integer varname, Variable ref outvar -> boolean found = false
{
	if(scopes.value.Name == scopename)
	{
		found = FindVariableDataInSingleScope(scopes.value.Variables, varname, outvar)
	}
	else
	{
		found = FindVariableDataInScopeList(scopes.next, scopename, varname, outvar)
	}
}

FindVariableDataInScopeList : nothing, integer scopename, integer varname, Variable ref outvar -> boolean found = false

FindVariableDataInSingleScope : list<Variable> ref vars, integer varname, Variable ref outvar -> boolean found = false
{
	if(vars.value.Name == varname)
	{
		outvar = vars.value
		found = true
	}
	else
	{
		found = FindVariableDataInSingleScope(vars.next, varname, outvar)
	}
}

FindVariableDataInSingleScope : nothing, integer varname, Variable ref outvar -> boolean found = false



CodeGenEmitTypeMatchers : list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{
		CodeGenEmitSingleTypeMatcher(matchers.value)
	}

	CodeGenEmitTypeMatchers(matchers.next)
}

CodeGenEmitTypeMatchers : nothing


CodeGenEmitSingleTypeMatcher : TypeMatcher ref matcher
{
	OnBytecodeLexicalScope(matcher.Name, 0, 0)
	OnBytecodeEnterTypeResolver(matcher.Name)
	CodeGenEmitTypeMatcherOverloads(matcher.Overloads)
	OnBytecodeExitTypeResolver()
}


OnCodeGenRegisterTypeMatchParam : integer matchername, integer overloadname, integer varname, integer vartype, boolean isref
{
	Parameter p = varname, vartype, isref
	FindTypeMatcherAndAppendOverloadParameter(TypeMatchers, matchername, overloadname, p)
}

FindTypeMatcherAndAppendOverloadParameter : list<TypeMatcher> ref matchers, integer matchername, integer overloadname, Parameter ref p
{
	if(matchers.value.Name == matchername)
	{
		FindTMOverloadAndAppendParameter(matchers.value.Overloads, matchers.value.Overloads, overloadname, p)
	}
	else
	{
		FindTypeMatcherAndAppendOverloadParameter(matchers.next, matchername, overloadname, p)
	}
}

FindTypeMatcherAndAppendOverloadParameter : nothing, integer matchername, integer overloadname, Parameter ref p
{
	print("No type matcher available")
	assert(false)
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, list<FunctionSignature> ref signatures, integer overloadname, Parameter ref p
{
	if(signatures.value.Name == overloadname)
	{
		AppendParameter(signatures.value.Parameters, p)
	}
	else
	{
		FindTMOverloadAndAppendParameter(originallist, signatures.next, overloadname, p)
	}
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, nothing, integer overloadname, Parameter ref p
{
	list<Parameter> paramlist = p, nothing
	FunctionSignature sig = overloadname, paramlist, 0
	prepend<FunctionSignature>(originallist, sig)
}

AppendParameter : list<Parameter> ref params, Parameter ref p
{
	AppendParameterRecurse(params, params.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, list<Parameter> ref tail, Parameter ref p
{
	AppendParameterRecurse(tail, tail.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, nothing, Parameter ref p
{
	list<Parameter> newlist = p, nothing
	params.next = newlist
}


CodeGenEmitTypeMatcherOverloads : list<FunctionSignature> ref signatures
{
	CodeGenEmitTypeMatcherOverloads(signatures.next)

	if(signatures.value.Name != 0)
	{
		OnBytecodeEmitByte(0x20)				// TypeMatch instruction
		OnBytecodeEmitInteger(signatures.value.Name)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(CountParameters(signatures.value.Parameters))
		
		CodeGenEmitTypeMatcherParams(signatures.value.Parameters)
	}
}

CodeGenEmitTypeMatcherOverloads : nothing


CountParameters : list<Parameter> ref params -> integer count = 0
{
	count = CountParameters(params.next)

	if(params.value.Name != 0)
	{
		++count
	}
}

CountParameters : nothing -> integer count = 0


CodeGenEmitTypeMatcherParams : list<Parameter> ref params
{
	CodeGenEmitTypeMatcherParams(params.next)

	if(params.value.Name != 0)
	{
		integer refflag = 0
		if(params.value.IsReference)
		{
			refflag = 1
		}

		OnBytecodeEmitByte(refflag)
		OnBytecodeEmitInteger(params.value.Type)
	}
}

CodeGenEmitTypeMatcherParams : nothing



OnCodeGenRegisterFunctionInvokeTag : integer funcname, integer invoketarget
{
	FindFunctionAndSetInvokeTag(Functions, funcname, invoketarget)
}

FindFunctionAndSetInvokeTag : list<FunctionDefinition> ref functions, integer funcname, integer invoketarget
{
	if(functions.value.Name == funcname)
	{
		functions.value.InvokeTag = invoketarget
	}
	else
	{
		FindFunctionAndSetInvokeTag(functions.next, funcname, invoketarget)
	}
}

FindFunctionAndSetInvokeTag : nothing, integer funcname, integer invoketarget
{
	print("Cannot tag non-existent function")
	assert(false)
}

OnCodeGenRegisterFunctionTag : integer funcname, string tagname
{
	FunctionTag tag = funcname, tagname, dummytagparams
	prepend<FunctionTag>(FunctionTags, tag)

	if(tagname == "constructor")
	{
		prepend<integer>(CustomConstructors, funcname)
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParam(FunctionTags.value.Parameters, FunctionTags.value.Parameters.next, param)
}

AppendFunctionTagParam : list<string> ref params, list<string> ref tail, string param
{
	AppendFunctionTagParam(tail, tail.next, param)
}

AppendFunctionTagParam : list<string> ref params, nothing, string param
{
	list<string> newlist = param, nothing
	params.next = newlist
}


CodeGenEmitFunctionTags : list<FunctionTag> ref tags
{
	CodeGenEmitSingleFunctionTag(tags.value)
	CodeGenEmitFunctionTags(tags.next)
}

CodeGenEmitFunctionTags : nothing


CodeGenEmitSingleFunctionTag : FunctionTag ref tag
{
	if(tag.FunctionName != 0)
	{
		if(tag.TagName != "")
		{
			OnBytecodeEmitByte(0x1a)
			OnBytecodeEmitInteger(tag.FunctionName)
			OnBytecodeEmitInteger(CountTagParams(tag.Parameters))
			OnBytecodeEmitString(tag.TagName)

			CodeGenEmitFunctionTagParams(tag.Parameters)
		}
	}
}


CodeGenEmitFunctionTagParams : list<string> ref params
{
	if(params.value != "")
	{
		OnBytecodeEmitString(params.value)
	}

	CodeGenEmitFunctionTagParams(params.next)
}

CodeGenEmitFunctionTagParams : nothing


CountTagParams : list<string> ref params -> integer count = 0
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0


CodeGenEmitConstructors : list<StructureDefinition> ref structures
{
	if(structures.value.Name != 0)
	{
		EmitCtorTag(structures.value.ConstructorName)
		EmitCtorTag(structures.value.AnonConstructorName)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCtorTag(structures.value.CopyConstructorName)
		}

		EmitConstructor(structures.value)
		EmitAnonConstructor(structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCopyConstructor(structures.value)
		}
	}

	CodeGenEmitConstructors(structures.next)
}

CodeGenEmitConstructors : nothing

EmitCtorTag : integer funcname
{
	OnBytecodeEmitByte(0x1a)
	OnBytecodeEmitInteger(funcname)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitString("@@autogen@constructor")
}


EmitConstructor : StructureDefinition ref def
{
	integer idhandle = FindString(GlobalStrings, "identifier")

	OnBytecodeLexicalScope(def.ConstructorName, 0, CountMembers(def.Members) + 1)
	OnBytecodeLexicalScopeEntry(idhandle, 0x01000000, true, 1)
	EmitScopeEntriesForMembers(def.Members)

	OnBytecodeEnterFunction(def.ConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, idhandle)

	OnBytecodeExitFunction()
}

EmitAnonConstructor : StructureDefinition ref def
{
	integer membercount = CountMembers(def.Members)
	OnBytecodeLexicalScope(def.AnonConstructorName, 0, membercount + 1)
	EmitScopeEntriesForMembers(def.Members)
	OnBytecodeLexicalScopeEntry(def.AnonConstructorName, def.Type, false, 2)

	OnBytecodeEnterFunction(def.AnonConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, membercount)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, def.AnonConstructorName)

	OnBytecodeSetReturnRegister(membercount)
	OnBytecodeExitFunction()
}

EmitCopyConstructor : StructureDefinition ref def
{
	OnBytecodeLexicalScope(def.CopyConstructorName, 0, 2)
	OnBytecodeLexicalScopeEntry(FindString(GlobalStrings, "identifier"), 0x01000000, true, 1)
	OnBytecodeLexicalScopeEntry(FindString(GlobalStrings, "value"), def.Type, false, 1)

	OnBytecodeEnterFunction(def.CopyConstructorName)
	OnBytecodePushVarNoCopy(FindString(GlobalStrings, "value"))
	OnBytecodeCopyStructure()
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()
	OnBytecodeExitFunction()
}


EmitScopeEntriesForMembers : list<StructureMember> ref members
{
	EmitScopeEntryForMember(members.value)
	EmitScopeEntriesForMembers(members.next)
}

EmitScopeEntriesForMembers : nothing


EmitScopeEntryForMember : StructureMemberVariable ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, memvar.Type, false, 1)
	}
}

EmitScopeEntryForMember : StructureMemberFunctionRef ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, 0x09000000, false, 1)
	}
}



EmitMemberDataCopies : list<StructureMember> ref members, integer idhandle
{
	EmitMemberDataCopy(members.value, idhandle)
	EmitMemberDataCopies(members.next, idhandle)
}

EmitMemberDataCopies : nothing, integer idhandle

EmitMemberDataCopy : StructureMemberVariable ref memvar, integer idhandle
{
	if(memvar.Name != 0)
	{
		OnBytecodePushVarValue(memvar.Name, memvar.Type)
		OnBytecodeCopyToStructure(idhandle, memvar.Name)
	}
}

EmitMemberDataCopy : StructureMemberFunctionRef ref member, integer idhandle
{
	if(member.Name != 0)
	{
		OnBytecodePushVarValue(member.Name, 0x09000000)
		OnBytecodeCopyToStructure(idhandle, member.Name)
	}
}


FindString : list<StringTableEntry> ref strings, string target -> integer handle = 0
{
	if(strings.value.Data == target)
	{
		handle = strings.value.Handle
	}
	else
	{
		handle = FindString(strings.next, target)
	}
}

FindString : nothing, string target -> integer handle = 0



GetNameOfType : integer typeid -> integer name = 0
{
	if(typeid == 0x01000001)
	{
		name = FindString(GlobalStrings, "integer")
	}
	elseif(typeid == 0x02000000)
	{
		name = FindString(GlobalStrings, "string")
	}
	elseif(typeid == 0x00000004)
	{
		name = FindString(GlobalStrings, "nothing")
	}
	elseif((typeid & 0xff000000) == 0x03000000)
	{
		name = GetNameOfStructureByType(typeid)
	}
	elseif((typeid & 0xff000000) == 0x07000000)
	{
		name = FindSumTypeName(typeid)
	}
	else
	{
		print("Unknown type " ; cast(string, typeid))
		assert(false)
	}
}

GetTypeByName : integer name -> integer typeid = 0
{
	if(name == FindString(GlobalStrings, "integer"))
	{
		typeid = 0x01000001
	}
	elseif(name == FindString(GlobalStrings, "string"))
	{
		typeid = 0x02000000
	}
	elseif(name == FindString(GlobalStrings, "nothing"))
	{
		typeid = 0x00000004
	}
	else
	{
		integer structurename = GetStructureTypeByName(Structures, name)
		if(structurename != 0)
		{
			typeid = structurename
		}
	}
}


GetStructureTypeByName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0
{
	if(structures.value.Name == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureTypeByName(structures.next, name)
	}
}

GetStructureTypeByName : nothing, integer name -> 0



// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	list<integer> processed = 0, nothing
	boolean changed = CodeGenRearrangeStructuresRecurse(thelist, processed)

	if(changed)
	{
		CodeGenRearrangeStructures(thelist)
	}
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref thelist, list<integer> ref processed -> boolean changed = false
{
	if(thelist.value.Name != 0)
	{
		list<integer> dependencies = 0, nothing
		ParseStructDependencies(thelist.value.Members, dependencies)

		if(MissingDependency(dependencies, processed))
		{
			SwapDown(thelist, thelist.next)
			changed = true
		}

		prepend<integer>(processed, thelist.value.Type)
	}

	if(!changed)
	{
		CodeGenRearrangeStructuresRecurse(thelist.next, processed)
	}
}

CodeGenRearrangeStructuresRecurse : nothing, list<integer> ref processed -> false


SwapDown : list<StructureDefinition> ref thelist, list<StructureDefinition> ref tail
{
	StructureDefinition temp = tail.value
	tail.value = thelist.value
	thelist.value = temp
}

SwapDown : list<StructureDefinition> ref thelist, nothing



ParseStructDependencies : list<StructureMember> ref members, list<integer> ref out
{
	integer dependency = GetMemberDependency(members.value)
	if(dependency != 0)
	{
		prepend<integer>(out, dependency)
	}

	ParseStructDependencies(members.next, out)
}

ParseStructDependencies : nothing, list<integer> ref out


GetMemberDependency : StructureMemberVariable ref var -> integer dep = 0
{
	if(var.Name != 0)
	{
		if((var.Type & 0xff000000) == 0x03000000)
		{
			dep = var.Type
		}
	}
}

GetMemberDependency : StructureMemberFunctionRef ref member -> 0


MissingDependency : list<integer> ref dependencies, list<integer> ref processed -> boolean missing = true
{
	// TODO - clean up this horrible code
	if(dependencies.value != 0)
	{
		if(listcontains(processed, dependencies.value))
		{
			missing = false
		}
		else
		{
			missing = MissingDependency(dependencies.next, processed)
		}
	}
	else
	{
		missing = MissingDependency(dependencies.next, processed)
	}
}

MissingDependency : nothing, list<integer> ref processed -> boolean missing = true


OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	ScratchExpressions.value = dummyexpression
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = ScratchExpressions.value
	EntityStack.value.Param = expr
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


AppendEntityToChain : list<EntityChain> ref chainstack, Entity ref e
{
	AppendEntityToChainUnwrap(chainstack.value.Entries, e)
}

AppendEntityToChainUnwrap : EntityList ref entitylist, Entity ref e
{
	AppendEntityToChainWorker(entitylist.ActualList, entitylist.ActualList.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, list<Entity> ref tail, Entity ref e
{
	AppendEntityToChainWorker(tail, tail.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, nothing, Entity ref e
{
	list<Entity> newtail = e, nothing
	chain.next = newtail
}


FindTypeAliasBase : list<TypeAlias> ref aliases, integer aliastype -> integer basetype = 0
{
	if(aliases.value.Alias == aliastype)
	{
		basetype = aliases.value.Base
	}
	else
	{
		basetype = FindTypeAliasBase(aliases.next, aliastype)
	}
}

FindTypeAliasBase : nothing, integer aliastype -> integer basetype = 0


OnCodeGenRegisterAlias : integer aliastype, integer base
{
	TypeAlias newalias = aliastype, base
	prepend<TypeAlias>(TypeAliases, newalias)
}



OnCodeGenRegisterFunctionSig : integer sigtype, integer rettype
{
	FunctionSignature sig = sigtype, dummyparamlist, rettype
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype, boolean isref
{
	Parameter param = 1, paramtype, isref
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigEnd :
{
	// TODO - dead code?
}


CodeGenEmitFunctionSignatures : list<FunctionSignature> ref thelist
{
	CodeGenEmitSingleFunctionSignature(thelist.value)
	CodeGenEmitFunctionSignatures(thelist.next)
}

CodeGenEmitFunctionSignatures : nothing


CodeGenEmitSingleFunctionSignature : FunctionSignature ref signature
{
	if(signature.Name != 0)
	{
		OnBytecodeEmitFunctionSignature(signature.Name, signature.ReturnType, CountParameters(signature.Parameters))
	}
	CodeGenEmitFunctionSigParams(signature.Parameters)
}

CodeGenEmitFunctionSigParams : list<Parameter> ref params
{
	CodeGenEmitFunctionSigParams(params.next)
	if(params.value.Type != 0)
	{
		OnBytecodeEmitFunctionSigParam(params.value.Type, params.value.IsReference)
	}
}

CodeGenEmitFunctionSigParams : nothing


OnCodeGenRegisterParenthetical : 
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	prepend<Expression>(ScratchExpressions, dummyexpression)
}


OnCodeGenRegisterPreOpStatement : integer operator, integer operand
{
	list<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist
	CodeBlockEntry cbe = preop
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	list<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}


GetLargestSumTypeBaseSize : integer typeid -> integer size = FindSumTypeAndGetBaseMaxSize(SumTypes, typeid)

FindSumTypeAndGetBaseMaxSize : list<SumType> ref sumtypes, integer typeid -> integer size = 0
{
	if(sumtypes.value.Type == typeid)
	{
		GetBaseMaxSize(sumtypes.value.Bases, size)
	}
	else
	{
		size = FindSumTypeAndGetBaseMaxSize(sumtypes.next, typeid)
	}
}

FindSumTypeAndGetBaseMaxSize : nothing, integer typeid -> 0


GetBaseMaxSize : list<integer> ref basetypes, integer ref outsize
{
	if(basetypes.value != 0)
	{
		integer thissize = GetTypeSize(basetypes.value)
		if(thissize > outsize)
		{
			outsize = thissize
		}
	}

	GetBaseMaxSize(basetypes.next, outsize)
}

GetBaseMaxSize : nothing, integer ref outsize



OnCodeGenSetExpressionType : integer typeid
{
	ScratchExpressions.value.Type = typeid
}


CodeGenEmitGlobalBlockPrologue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeEnterEntity(4, GlobalCodeBlockName)
		CodeGenEmitCodeBlock(block)
		OnBytecodeInvokeOffset(FindString(GlobalStrings, "entrypoint"))
		OnBytecodeHalt()
	}
}

CodeGenEmitGlobalBlockEpilogue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeExitEntity()
	}
}




//
// Global state (just a hack while we bootstrap!)
//

global
{
	buffer Hack = 102400
	integer HackSize = 0

	list<StringTableEntry> GlobalStrings = StringTableEntry(0, ""), nothing

	Variable dummyvar = 0, 0, false, 0, 0
	list<Variable> dummyvarlist = dummyvar, nothing
	Scope dummyscope = 0, 0, dummyvarlist, 0, 0
	list<Scope> Scopes = dummyscope, nothing

	FunctionDefinition dummyfunc = 0, nothing, nothing, false, 0
	list<FunctionDefinition> Functions = dummyfunc, nothing


	list<integer> dummybases = 0, nothing
	SumType dummysumtype = 0, 0, dummybases
	list<SumType> SumTypes = dummysumtype, nothing


	StructureMemberVariable dummymember = 0, 0
	list<StructureMember> dummymembers = dummymember, nothing
	StructureDefinition dummystruct = 0, 0, 0, 0, 0, dummymembers
	list<StructureDefinition> Structures = dummystruct, nothing


	// TODO - convert to an enumeration
	integer STACK_TYPE_GLOBAL = 0
	integer STACK_TYPE_FUNCTION = 1
	integer STACK_TYPE_CODEBLOCK = 2
	integer STACK_TYPE_STATEMENT = 3
	integer STACK_TYPE_ASSIGNMENT = 4
	integer STACK_TYPE_TYPEMATCH = 5
	integer STACK_TYPE_SUBSTATEMENT = 6
	integer STACK_TYPE_FUNCRET = 7
	integer STACK_TYPE_ENTITY_PARAM = 8
	integer STACK_TYPE_ENTITY_CODE = 9
	integer STACK_TYPE_CHAIN = 10
	integer STACK_TYPE_PARENTHETICAL = 11

	ContextStackEntry GlobalStackEntry = STACK_TYPE_GLOBAL, 0
	list<ContextStackEntry> ContextStack = GlobalStackEntry, nothing

	AtomSentinel dummysentinel = 0
	list<ExpressionAtom> dummyatomlist = dummysentinel, nothing
	Expression dummyexpression = dummyatomlist, 0
	list<Expression> ScratchExpressions = dummyexpression, nothing
	Statement dummystatement = 0, nothing, 0
	list<Statement> SubStatements = dummystatement, nothing

	Parameter dummyparam = 0, 0, false
	list<Parameter> dummyparamlist = dummyparam, nothing
	FunctionSignature dummysignature = 0, dummyparamlist, 0
	list<FunctionSignature> dummysignaturelist = dummysignature, nothing
	TypeMatcher dummytypematch = 0, dummysignaturelist
	list<TypeMatcher> TypeMatchers = dummytypematch, nothing

	Entity dummyentity = 0, 0, nothing, nothing
	list<Entity> EntityStack = dummyentity, nothing


	list<string> dummytagparams = "", nothing
	FunctionTag dummytag = 0, "", dummytagparams
	list<FunctionTag> FunctionTags = dummytag, nothing

	integer EmittingFunctionName = 0

	list<OptionalCodeBlock> CurrentCodeBlockStack = nothing, nothing

	list<CodeBlockEntry> dummyblockentries = dummystatement, nothing
	CodeBlock GlobalCodeBlock = dummyblockentries
	integer GlobalCodeBlockName = 0

	list<Entity> chaincontents = dummyentity, nothing
	OptionalEntityList chaincontentswrap = chaincontents
	EntityChain dummychain = chaincontentswrap
	list<EntityChain> ChainStack = dummychain, nothing


	list<integer> AutoGeneratedFunctionNames = 0, nothing
	list<integer> CustomConstructors = 0, nothing

	TypeAlias dummyalias = 0, 0
	list<TypeAlias> TypeAliases = dummyalias, nothing

	list<FunctionSignature> FunctionSignatures = dummysignature, nothing
}

