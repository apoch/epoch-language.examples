//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//

type listnode<type T> : list<T> | nothing

structure list<type T> :
	T value,
	listnode<T> next


prepend<type T> : list<T> ref thelist, T ref value
{
	list<T> newlist = value, thelist
	thelist = newlist
}

map<type T> : list<T> ref thelist, (func : T)
{
	func(thelist.value)
	map<T>(thelist.next, func)
}

map<type T> : nothing, (func : T)
{
}



//
// API for registering plugins with the C++ compiler
//
RegisterFunc : string name, (funcptr : ) 						[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : string) 						[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : boolean) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer)				[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, string)					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, integer)			[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, boolean, integer)		[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : integer, integer, integer, boolean, integer)	[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : boolean, integer, integer, integer)		[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : -> integer) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]
RegisterFunc : string name, (funcptr : -> buffer) 					[external("EpochCompiler.dll", "RegisterPluginFunction", "stdcall")]



//
// Entrypoint - called when the plugin is loaded
//
// Performs function registration with the C++ compiler
//
entrypoint :
{
	RegisterFunc("PluginOnCompileStart", OnCompileStart)

	RegisterBytecodePlugin()
	RegisterCodeGenPlugin()
}


RegisterBytecodePlugin :
{
	RegisterFunc("PluginBytecodeGetBuffer", OnBytecodeGetBuffer)
	RegisterFunc("PluginBytecodeGetSize", OnBytecodeGetSize)

	print("Epoch Compiler - bytecode emitter plugin registered")
}

RegisterCodeGenPlugin :
{
	RegisterFunc("PluginCodeGenProcessProgram", OnCodeGenProcessProgram)

	RegisterFunc("PluginCodeGenRegisterString", OnCodeGenRegisterString)
	RegisterFunc("PluginCodeGenRegisterScope", OnCodeGenRegisterScope)
	RegisterFunc("PluginCodeGenRegisterVariable", OnCodeGenRegisterVariable)
	RegisterFunc("PluginCodeGenRegisterFunction", OnCodeGenRegisterFunction)
	RegisterFunc("PluginCodeGenRegisterLiteralBoolean", OnCodeGenRegisterLiteralBoolean)
	RegisterFunc("PluginCodeGenRegisterLiteralInteger", OnCodeGenRegisterLiteralInteger)
	RegisterFunc("PluginCodeGenRegisterLiteralString", OnCodeGenRegisterLiteralString)
	RegisterFunc("PluginCodeGenRegisterAtomIdentifier", OnCodeGenRegisterAtomIdentifier)
	RegisterFunc("PluginCodeGenRegisterOperatorInvoke", OnCodeGenRegisterOperatorInvoke)

	RegisterFunc("PluginCodeGenRegisterStructureMemVar", OnCodeGenRegisterStructureMemVar)

	RegisterFunc("PluginCodeGenEnterFunctionBody", OnCodeGenEnterFunctionBody)
	RegisterFunc("PluginCodeGenEnterStatement", OnCodeGenEnterStatement)
	RegisterFunc("PluginCodeGenExit", OnCodeGenExitContext)

	print("Epoch Compiler - code generation plugin registered")
}


//
// Callback for when compilation on a program begins
//
OnCompileStart :
{
	print("Epoch Compiler - compilation started")
}


//
// Callback used to emit a byte to a bytecode stream
//
OnBytecodeEmitByte : integer b
{
	writebuffer(Hack, HackSize, b)
	++HackSize
}

//
// Callback used to emit a series of bytes to a bytecode stream
//
OnBytecodeEmitBytes : integer bytes, integer size
{
	writebuffer(Hack, HackSize, bytes, size)
	HackSize += size
}


//
// Callback used to retrieve a bytecode stream's pointer
//
OnBytecodeGetBuffer : -> buffer ret = Hack


//
// Callback used to retrieve the size of a bytecode stream
//
OnBytecodeGetSize : -> integer size = HackSize



OnBytecodeEmitInteger : integer value
{
	writebuffer(Hack, HackSize, (value) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x100) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x10000) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x1000000) & 0xff)
	++HackSize
}

OnBytecodeEmitInteger16 : integer16 value
{
	integer v = cast(integer, value)
	writebuffer(Hack, HackSize, (v) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (v / 0x100) & 0xff)
	++HackSize
}


OnBytecodeEmitString : string value
{
	integer len = (length(value) + 1) * 2
	writebuffer(Hack, HackSize, value, len)
	HackSize += len
}

OnBytecodeEmitBoolean : boolean value
{
	OnBytecodeEmitByte(cast(integer, value))
}


OnBytecodePoolString : integer handle, string data
{
	OnBytecodeEmitByte(0x10)			// PoolString instruction
	OnBytecodeEmitInteger(handle)
	OnBytecodeEmitString(data)
}

OnBytecodeLexicalScope : integer name, integer parent, integer count
{
	OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(parent)
	OnBytecodeEmitInteger(count)
}

OnBytecodeLexicalScopeEntry : integer varname, integer vartype, boolean isreference, integer origin
{
	OnBytecodeEmitInteger(varname)
	OnBytecodeEmitInteger(vartype)
	OnBytecodeEmitInteger(origin)
	OnBytecodeEmitBoolean(isreference)
}

OnBytecodeInvokeOffset : integer name
{
	OnBytecodeEmitByte(0x27)			// InvokeOffset instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(0)
}

OnBytecodeHalt :
{
	OnBytecodeEmitByte(0x00)			// Halt instruction
}

OnBytecodeEnterFunction : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x01)			// EntityTags::Function
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitFunction :
{
	OnBytecodeEmitByte(0x09)			// Return instruction
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeInvoke : integer target
{
	OnBytecodeEmitByte(0x07)			// Invoke instruction
	OnBytecodeEmitInteger(target)
}

OnBytecodeEnterEntity : integer tag, integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(tag)
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitEntity :
{
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeBeginChain :
{
	OnBytecodeEmitByte(0x0d)			// BeginChain instruction
}

OnBytecodeEndChain :
{
	OnBytecodeEmitByte(0x0e)			// EndChain instruction
}

OnBytecodeDefineStructure : integer typeid, integer nummembers
{
	OnBytecodeEmitByte(0x14)			// DefineStructure instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(nummembers)
}

OnBytecodeStructureMember : integer name, integer typeid
{
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeReadReference :
{
	OnBytecodeEmitByte(0x17)			// ReadRef instruction
}

OnBytecodeReadReferenceAnnotated :
{
	OnBytecodeEmitByte(0x24)			// ReadRefAnnotated instruction
}

OnBytecodeAllocStructure : integer typeid
{
	OnBytecodeEmitByte(0x13)			// AllocStructure instruction
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeBindReference : integer frameskip, integer index
{
	OnBytecodeEmitByte(0x03)			// BindRef instruction
	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(index)
}

OnBytecodeAssign :
{
	OnBytecodeEmitByte(0x06)			// Assign instruction
}

OnBytecodePushVarValue : integer name, integer typeid
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(name)

	integer family = typeid & 0xff000000

	if(typeid == 0x02000001)			// Buffer type signature
	{
		OnBytecodeCopyBuffer()
	}
	elseif(family == 0x03000000)			// Structure family signature
	{
		OnBytecodeCopyStructure()
	}
	elseif(family == 0x08000000)			// Template instance family signature
	{
		OnBytecodeCopyStructure()
	}
}

OnBytecodeCopyBuffer :
{
	OnBytecodeEmitByte(0x19)			// CopyBuffer instruction
}

OnBytecodeCopyStructure :
{
	OnBytecodeEmitByte(0x1b)			// CopyStructure instruction
}

OnBytecodeCopyToStructure : integer structurename, integer membername
{
	OnBytecodeEmitByte(0x16)			// CopyToStructure instruction
	OnBytecodeEmitInteger(structurename)
	OnBytecodeEmitInteger(membername)
}

OnBytecodeSetReturnRegister : integer varindex
{
	OnBytecodeEmitByte(0x0a)			// SetRetVal instruction
	OnBytecodeEmitInteger(varindex)
}

OnBytecodePushVarNoCopy : integer varname
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeInvokeIndirect : integer varname
{
	OnBytecodeEmitByte(0x08)			// InvokeIndirect instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeEnterPatternResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x02)			// EntityTags::PatternMatchingResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitPatternResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeConstructSumType :
{
	OnBytecodeEmitByte(0x21)			// ConstructSumType instruction
}

OnBytecodeEnterTypeResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x05)			// EntityTags::TypeResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitTypeResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodePopStack : integer bytes
{
	OnBytecodeEmitByte(0x04)			// Pop instruction
	OnBytecodeEmitInteger(bytes)
}

OnBytecodeBindStructReference : integer membertype, integer memberoffset
{
	OnBytecodeEmitByte(0x18)			// BindMemberRef instruction
	OnBytecodeEmitInteger(membertype)
	OnBytecodeEmitInteger(memberoffset)
}

OnBytecodePushType : integer typeid
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeAssignSumType :
{
	OnBytecodeEmitByte(0x23)			// AssignSumType instruction
}

OnBytecodePushLocal : boolean isparam, integer frameskip, integer offset, integer size
{
	if(isparam)
	{
		OnBytecodeEmitByte(0x26)		// ReadParam instruction
	}
	else
	{
		OnBytecodeEmitByte(0x25)		// ReadStack instruction
	}

	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(offset)
	OnBytecodeEmitInteger(size)
}

OnBytecodePushBoolean : boolean literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000003)		// Boolean type signature
	OnBytecodeEmitBoolean(literal)
}

OnBytecodePushLiteralString : integer literalhandle
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x02000000)		// String type signature
	OnBytecodeEmitInteger(literalhandle)
}

OnBytecodePushLiteralInteger : integer literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(literal)
}

OnBytecodePushLiteralInteger16 : integer16 literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000002)		// Integer16 type signature
	OnBytecodeEmitInteger16(literal)
}


//
// Code generation
//


structure StringTableEntry :
	integer Handle,
	string Data

structure StructureMemberVariable :
	integer Name,
	integer Type

// TODO - support for function signatures
structure StructureMemberFunctionRef :
	integer Name


type StructureMember : StructureMemberVariable | StructureMemberFunctionRef

structure StructureDefinition :
	list<StructureMember> Members


structure IdentifierAtom :
	integer Handle,
	integer Type

structure StringHandleAtom :
	integer Handle

structure OperatorInvokeAtom :
	integer OperatorName

structure AtomSentinel :
	integer dummy


type ExpressionAtom : integer | integer16 | boolean | IdentifierAtom | StringHandleAtom | OperatorInvokeAtom | AtomSentinel

structure Expression :
	list<ExpressionAtom> Atoms

type OptionalExpression : Expression | nothing

structure ExpressionList :
	list<Expression> Expressions

type OptionalExpressionList : ExpressionList | nothing


structure Statement :
	integer Name,
	OptionalExpressionList Parameters


structure CodeBlock :
	list<Statement> Entries

type OptionalCodeBlock : CodeBlock | nothing


structure FunctionDefinition :
	integer Name,
	OptionalExpression Return,
	OptionalCodeBlock Code


structure Variable :
	integer Name,
	integer VarType,
	boolean IsReference,
	integer Origin

structure Scope :
	integer Name,
	integer ParentName,
	list<Variable> Variables



structure ContextStackEntry :
	integer EntryType,
	integer EntryName


OnCodeGenProcessProgram :
{
	print("Emitting program...")
	CodeGenEmitStrings(GlobalStrings)
	// TODO - emit structures
	CodeGenEmitScopes(Scopes)
	CodeGenEmitFunctions(Functions)
	print("Done.")
}

OnCodeGenRegisterString : integer handle, string data
{
	StringTableEntry entry = handle, data
	prepend<StringTableEntry>(GlobalStrings, entry)
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer membername, integer membertype
{
	// TODO - find structure and append member
}

OnCodeGenRegisterScope : integer scopename, integer parentname
{
	Scope scope = scopename, parentname, dummyvarlist
	prepend<Scope>(Scopes, scope)
}

OnCodeGenRegisterVariable : integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	StoreVariableInScope(Scopes, scopename, varname, vartype, isref, origin)
}

StoreVariableInScope : list<Scope> ref scopes, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	if(scopes.value.Name == scopename)
	{
		Variable var = varname, vartype, isref, origin
		prepend<Variable>(scopes.value.Variables, var)
	}
	else
	{
		StoreVariableInScope(scopes.next, scopename, varname, vartype, isref, origin)
	}
}

StoreVariableInScope : nothing, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	assert(false)
}


OnCodeGenRegisterFunction : integer funcname
{
	FunctionDefinition func = funcname, nothing, nothing
	prepend<FunctionDefinition>(Functions, func)
}

OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	PopContext(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		FindCurrentStatementAndAppendExpression(Functions, ScratchExpression)
	}
}

PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	assert(false)
}


PlaceAtomInScratchExpression : ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(ScratchExpression.Atoms.value))
	{
		list<ExpressionAtom> atoms = atom, nothing
		ScratchExpression = Expression(atoms)
	}
	else
	{
		AppendAtomToExpression(ScratchExpression.Atoms, ScratchExpression.Atoms.next, atom)
	}
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}


ExpressionAtomIsSentinel : AtomSentinel 	ref sentinel    -> boolean ret = true
ExpressionAtomIsSentinel : StringHandleAtom 	ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : IdentifierAtom 	ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : OperatorInvokeAtom 	ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : integer 		ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : integer16 		ref nonsentinel -> boolean ret = false
ExpressionAtomIsSentinel : boolean 		ref nonsentinel -> boolean ret = false


AppendAtomToExpression : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, ExpressionAtom ref atom
{
	AppendAtomToExpression(tail, tail.next, atom)
}

AppendAtomToExpression : list<ExpressionAtom> ref atoms, nothing, ExpressionAtom ref atom
{
	list<ExpressionAtom> newatoms = atom, nothing
	atoms.next = newatoms
}


OnCodeGenEnterStatement : integer statementname
{
	Statement statement = statementname, nothing
	AppendStatementToCurrentCodeBlock(statement)

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statementname
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpression = Expression(dummyatomlist)
}



AppendStatementToCurrentCodeBlock : Statement ref statement
{
	if(ContextStack.value.EntryType == STACK_TYPE_FUNCTION)
	{
		FindCurrentFunctionAndAppendStatement(Functions, statement)
	}
	else
	{
		// TODO - support other code body types on context stack
		assert(false)
	}
}

FindCurrentFunctionAndAppendStatement : list<FunctionDefinition> ref functions, Statement ref statement
{
	assert(ContextStack.value.EntryType == STACK_TYPE_FUNCTION)
	if(functions.value.Name == ContextStack.value.EntryName)
	{
		AppendStatementToCodeBlock(functions.value, functions.value.Code, statement)
	}
	else
	{
		FindCurrentFunctionAndAppendStatement(functions.next, statement)
	}
}

FindCurrentFunctionAndAppendStatement : nothing, Statement ref statement
{
	assert(false)
}


AppendStatementToCodeBlock : FunctionDefinition ref funcdef, CodeBlock ref code, Statement ref statement
{
	AppendStatementToCodeBlock(code.Entries, statement)
}

AppendStatementToCodeBlock : FunctionDefinition ref funcdef, nothing, Statement ref statement
{
	list<Statement> stmtlist = statement, nothing
	CodeBlock block = stmtlist

	SetFunctionCodeBlock(funcdef, block)
}

AppendStatementToCodeBlock : list<Statement> ref statements, Statement ref statement
{
	AppendStatementToCodeBlock(statements, statements.next, statement)
}

AppendStatementToCodeBlock : list<Statement> ref statements, nothing, Statement ref statement
{
	list<Statement> newlist = statement, nothing
	statements.next = newlist
}

AppendStatementToCodeBlock : list<Statement> ref statements, list<Statement> ref tail, Statement ref value
{
	AppendStatementToCodeBlock(tail, tail.next, value)
}



FindCurrentStatementAndAppendExpression : list<FunctionDefinition> ref functions, Expression ref expression
{
	assert(ContextStack.value.EntryType == STACK_TYPE_FUNCTION)
	if(functions.value.Name == ContextStack.value.EntryName)
	{
		FindLastStatementInBlockAndAppendExpression(functions.value.Code, expression)
	}
	else
	{
		FindCurrentStatementAndAppendExpression(functions.next, expression)
	}
}

FindCurrentStatementAndAppendExpression : nothing, Statement ref statement
{
	assert(false)
}



FindLastStatementInBlockAndAppendExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastStatementAndAppendExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastStatementAndAppendExpression : list<Statement> ref codeblockentries, list<Statement> ref tail, Expression ref expression
{
	FindLastStatementAndAppendExpression(tail, tail.next, expression)
}

FindLastStatementAndAppendExpression : list<Statement> ref codeblockentries, nothing, Expression ref expression
{
	AppendExpressionToStatement(codeblockentries.value, codeblockentries.value.Parameters, expression)
}

AppendExpressionToStatement : Statement ref statement, ExpressionList ref parameters, Expression ref expression
{
	AppendExpression(parameters.Expressions, parameters.Expressions.next, expression)
}

AppendExpressionToStatement : Statement ref statement, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	ExpressionList params = newlist
	statement.Parameters = params
}

AppendExpression : list<Expression> ref expressions, list<Expression> ref tail, Expression ref expression
{
	AppendExpression(tail, tail.next, expression)
}

AppendExpression : list<Expression> ref expressions, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	expressions.next = newlist
}


SetFunctionCodeBlock : FunctionDefinition ref funcdef, CodeBlock ref block
{
	funcdef.Code = block
}

SetFunctionCodeBlock : nothing, CodeBlock ref block
{
	print("Error - missing function definition")
	assert(false)
}


CodeGenEmitStrings : list<StringTableEntry> ref table
{
	map<StringTableEntry>(table, CodeGenEmitSingleString)
}

CodeGenEmitSingleString : StringTableEntry entry			// TODO - this should be passed by ref
{
	if(entry.Handle != 0)
	{
		OnBytecodePoolString(entry.Handle, entry.Data)
	}
}


CodeGenEmitScopes : list<Scope> ref scopes
{
	CodeGenEmitSingleScope(scopes.value)
	CodeGenEmitScopes(scopes.next)
}

CodeGenEmitScopes : nothing


CodeGenEmitSingleScope : Scope ref scope
{
	integer varcount = CountScopeVariables(scope)
	OnBytecodeLexicalScope(scope.Name, scope.ParentName, varcount)
	CodeGenEmitVariables(scope.Variables)
}


CountScopeVariables : Scope ref scope -> integer count = 0
{
	CountScopeVariables(scope.Variables, count)
}

CountScopeVariables : list<Variable> ref variables, integer ref count
{
	if(variables.value.Name != 0)
	{
		++count
	}

	CountScopeVariables(variables.next, count)
}

CountScopeVariables : nothing, integer ref count


CodeGenEmitVariables : list<Variable> ref vars
{
	CodeGenEmitSingleVariable(vars.value)
	CodeGenEmitVariables(vars.next)
}

CodeGenEmitVariables : nothing


CodeGenEmitSingleVariable : Variable ref var
{
	if(var.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(var.Name, var.VarType, var.IsReference, var.Origin)
	}
}


CodeGenEmitFunctions : list<FunctionDefinition> ref table
{
	CodeGenEmitSingleFunction(table.value)
	CodeGenEmitFunctions(table.next)
}

CodeGenEmitFunctions : nothing


CodeGenEmitSingleFunction : FunctionDefinition ref def
{
	if(def.Name != 0)
	{
		OnBytecodeEnterFunction(def.Name)
		CodeGenEmitCodeBlock(def.Code)
		OnBytecodeExitFunction()
	}
}


CodeGenEmitCodeBlock : CodeBlock ref block
{
	CodeGenEmitStatements(block.Entries)
}

CodeGenEmitCodeBlock : nothing


CodeGenEmitStatements : list<Statement> ref entries
{
	CodeGenEmitSingleStatement(entries.value)
	CodeGenEmitStatements(entries.next)
}

CodeGenEmitStatements : nothing


CodeGenEmitSingleStatement : Statement ref s
{
	CodeGenEmitExpressionList(s.Parameters)
	OnBytecodeInvoke(s.Name)			// TODO - other types of invoke may be needed depending on context!
}


CodeGenEmitExpressionList : nothing

CodeGenEmitExpressionList : ExpressionList ref expressions
{
	CodeGenEmitExpressionList(expressions.Expressions)
}

CodeGenEmitExpressionList : list<Expression> ref expressions
{
	CodeGenEmitExpressionAtoms(expressions.value.Atoms)
	CodeGenEmitExpressionList(expressions.next)
}

CodeGenEmitExpressionAtoms : list<ExpressionAtom> ref atoms
{
	CodeGenEmitSingleAtom(atoms.value)
	CodeGenEmitExpressionAtoms(atoms.next)
}

CodeGenEmitExpressionAtoms : nothing

CodeGenEmitSingleAtom : integer ref literalinteger
{
	OnBytecodePushLiteralInteger(literalinteger)
}

CodeGenEmitSingleAtom : integer16 ref literalinteger16
{
	OnBytecodePushLiteralInteger16(literalinteger16)
}

CodeGenEmitSingleAtom : boolean ref literalboolean
{
	OnBytecodePushBoolean(literalboolean)
}

CodeGenEmitSingleAtom : StringHandleAtom ref atom
{
	OnBytecodePushLiteralString(atom.Handle)
}

CodeGenEmitSingleAtom : OperatorInvokeAtom ref atom
{
	OnBytecodeInvoke(atom.OperatorName)
}

CodeGenEmitSingleAtom : IdentifierAtom ref idatom
{
	// TODO - this is a totally sloppy hack
	if(idatom.Type == 0x01000000)
	{
		OnBytecodePushLiteralString(idatom.Handle)
	}
	else
	{
		OnBytecodePushLocal(false, 0, 0, 4)
	}
}

CodeGenEmitSingleAtom : AtomSentinel ref sentinel



//
// Global state (just a hack while we bootstrap!)
//

global
{
	buffer Hack = 102400
	integer HackSize = 0

	list<StringTableEntry> GlobalStrings = StringTableEntry(0, ""), nothing

	Variable dummyvar = 0, 0, false, 0
	list<Variable> dummyvarlist = dummyvar, nothing
	Scope dummyscope = 0, 0, dummyvarlist
	list<Scope> Scopes = dummyscope, nothing

	FunctionDefinition dummyfunc = 0, nothing, nothing
	list<FunctionDefinition> Functions = dummyfunc, nothing


	// TODO - convert to an enumeration
	integer STACK_TYPE_GLOBAL = 0
	integer STACK_TYPE_FUNCTION = 1
	integer STACK_TYPE_CODEBLOCK = 2
	integer STACK_TYPE_STATEMENT = 3

	ContextStackEntry GlobalStackEntry = STACK_TYPE_GLOBAL, 0
	list<ContextStackEntry> ContextStack = GlobalStackEntry, nothing

	AtomSentinel dummysentinel = 0
	list<ExpressionAtom> dummyatomlist = dummysentinel, nothing
	Expression ScratchExpression = dummyatomlist
}

