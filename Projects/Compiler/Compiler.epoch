//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//



//
// Singly linked list data structures
//

type simplelistnode<type T> : simplelist<T> | nothing

structure simplelist<type T> :
	T value,
	simplelistnode<T> next


type listnode<type T> : list<T> | nothing

structure list<type T> :
	T ref value,
	listnode<T> next


//
// List manipulation functions
//

simpleprepend<type T> : simplelist<T> ref thelist, T value
{
	simplelist<T> newlist = value, thelist
	thelist = newlist
}

prepend<type T> : list<T> ref thelist, T ref value
{
	list<T> newlist = value, thelist
	thelist = newlist
}


getelement : simplelist<integer> ref thelist, integer index -> integer value = thelist.value
{
	if(index > 0)
	{
		value = getelement(thelist.next, index - 1)
	}
}




CloseHandle : integer handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]
CreateFile : string filename, integer access, integer sharemode, integer attributes, integer creation, integer flags, integer template -> integer ret = 0 [external("Kernel32.dll", "CreateFileW", "stdcall")]
CreateFileMapping : integer filehandle, integer attributes, integer protection, integer maxsizehigh, integer maxsizelow, integer name -> integer ret = 0 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
MapViewOfFile : integer handle, integer access, integer offsethigh, integer offsetlow, integer bytestomap -> integer ptr = 0 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]
UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]
GetFileSize : integer handle, integer ignored -> integer size = 0 [external("Kernel32.dll", "GetFileSize", "stdcall")]


timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime", "stdcall")]


ExecuteByteCodeBuffer : buffer ref code, integer len [external("EpochRuntime.dll", "ExecuteByteCodeDeferred", "stdcall")]



simple_append_recurse<type T> : simplelist<T> ref thelist, nothing, T value
{
	simplelist<T> newlist = value, nothing
	thelist.next = newlist
}

simple_append_recurse<type T> : simplelist<T> ref thelist, simplelist<T> ref tail, T value
{
	simple_append_recurse<T>(tail, tail.next, value)
}


simple_append<type T> : simplelist<T> ref thelist, T value
{
	simple_append_recurse<T>(thelist, thelist.next, value)
}



entrypoint :
{
	print("Epoch Language Project")
	print("Command line compiler and tools interface")
	print("")

	if(cmdlineisvalid() && (cmdlinegetcount() > 1))
	{
		boolean makeexe = false
		
		string filename = cmdlineget(1)
		if(filename == "make")
		{
			filename = cmdlineget(2)
			makeexe = true
		}
		else
		{
			print("Executing: " ; filename)
			print("")
		}

		integer len = 0
		string contents = ReadFile(filename, len)
		
		if(len == 0)
		{
			return()
		}

		PrepareStringTable()
		InitBuiltInOverloads()

		integer startparsems = timeGetTime()
		boolean parseok = Parse(contents, len)
		integer durationparsems = timeGetTime() - startparsems

		print("Parsing completed in " ; cast(string, durationparsems) ; " milliseconds")
		if(!parseok)
		{
			return()
		}

		integer startprocessms = timeGetTime()
		boolean irok = IRProcess()
		integer durationprocessms = timeGetTime() - startprocessms

		print("Semantic analysis completed in " ; cast(string, durationprocessms) ; " milliseconds")
		if(!irok)
		{
			return()
		}

		integer startcodegenms = timeGetTime()
		OnCodeGenProcessProgram()
		integer durationcodegenms = timeGetTime() - startcodegenms

		print("Code generation completed in " ; cast(string, durationcodegenms) ; " milliseconds")
		print("")

		if(makeexe)
		{
			MakeExe("test.exe")
		}
		else
		{
			ExecuteByteCodeBuffer(Hack, HackSize)
		}
	}
	else
	{
		print("Please specify a program to execute!")
	}
}


PrepareStringTable :
{
	integer counter = 0
	OnCodeGenRegisterString((++counter), "+")
	OnCodeGenRegisterString((++counter), "-")
	OnCodeGenRegisterString((++counter), "*")
	OnCodeGenRegisterString((++counter), "/")
	OnCodeGenRegisterString((++counter), "+=@@real")
	OnCodeGenRegisterString((++counter), "+@@real")
	OnCodeGenRegisterString((++counter), "-=@@real")
	OnCodeGenRegisterString((++counter), "-@@real")
	OnCodeGenRegisterString((++counter), "*@@real")
	OnCodeGenRegisterString((++counter), "/@@real")
	OnCodeGenRegisterString((++counter), "+=@@integer")
	OnCodeGenRegisterString((++counter), "+@@integer")
	OnCodeGenRegisterString((++counter), "-=@@integer")
	OnCodeGenRegisterString((++counter), "-@@integer")
	OnCodeGenRegisterString((++counter), "*@@integer")
	OnCodeGenRegisterString((++counter), "/@@integer")
	OnCodeGenRegisterString((++counter), "++@@integer")
	OnCodeGenRegisterString((++counter), "--@@integer")
	OnCodeGenRegisterString((++counter), "!@@integer")
	OnCodeGenRegisterString((++counter), "++@@real")
	OnCodeGenRegisterString((++counter), "--@@real")
	OnCodeGenRegisterString((++counter), "+=")
	OnCodeGenRegisterString((++counter), "-=")
	OnCodeGenRegisterString((++counter), "!")
	OnCodeGenRegisterString((++counter), "++")
	OnCodeGenRegisterString((++counter), "--")
	OnCodeGenRegisterString((++counter), "&")
	OnCodeGenRegisterString((++counter), "&&")
	OnCodeGenRegisterString((++counter), "!@@boolean")
	OnCodeGenRegisterString((++counter), "cmdlineisvalid")
	OnCodeGenRegisterString((++counter), "cmdlinegetcount")
	OnCodeGenRegisterString((++counter), "cmdlineget")
	OnCodeGenRegisterString((++counter), "==")
	OnCodeGenRegisterString((++counter), "!=")
	OnCodeGenRegisterString((++counter), ">")
	OnCodeGenRegisterString((++counter), "<")
	OnCodeGenRegisterString((++counter), "==@@integer")
	OnCodeGenRegisterString((++counter), "==@@integer16")
	OnCodeGenRegisterString((++counter), "!=@@integer")
	OnCodeGenRegisterString((++counter), "==@@boolean")
	OnCodeGenRegisterString((++counter), "!=@@boolean")
	OnCodeGenRegisterString((++counter), "==@@string")
	OnCodeGenRegisterString((++counter), "!=@@string")
	OnCodeGenRegisterString((++counter), "==@@real")
	OnCodeGenRegisterString((++counter), ">@@integer")
	OnCodeGenRegisterString((++counter), "<@@integer")
	OnCodeGenRegisterString((++counter), ">@@real")
	OnCodeGenRegisterString((++counter), "<@@real")
	OnCodeGenRegisterString((++counter), "print")
	OnCodeGenRegisterString((++counter), "read")
	OnCodeGenRegisterString((++counter), "assert")
	OnCodeGenRegisterString((++counter), "passtest")
	OnCodeGenRegisterString((++counter), "sqrt")
	OnCodeGenRegisterString((++counter), "plotpixel")
	OnCodeGenRegisterString((++counter), "breakpoint")
	OnCodeGenRegisterString((++counter), "if")
	OnCodeGenRegisterString((++counter), "elseif")
	OnCodeGenRegisterString((++counter), "else")
	OnCodeGenRegisterString((++counter), "while")
	OnCodeGenRegisterString((++counter), "do")
	OnCodeGenRegisterString((++counter), "return")
	OnCodeGenRegisterString((++counter), "constructor")
	OnCodeGenRegisterString((++counter), "external")
	OnCodeGenRegisterString((++counter), "@@external")
	OnCodeGenRegisterString((++counter), "nogc")
	OnCodeGenRegisterString((++counter), "sizeof")
	OnCodeGenRegisterString((++counter), "marshalstructure")
	OnCodeGenRegisterString((++counter), "writebuffer")
	OnCodeGenRegisterString((++counter), "writebuffer@@string")
	OnCodeGenRegisterString((++counter), "writebuffer@@multiple")
	OnCodeGenRegisterString((++counter), "writebuffer@@real")
	OnCodeGenRegisterString((++counter), "unescape")
	OnCodeGenRegisterString((++counter), "substring")
	OnCodeGenRegisterString((++counter), "substring@@withlength")
	OnCodeGenRegisterString((++counter), "substring@@nolength")
	OnCodeGenRegisterString((++counter), ";")
	OnCodeGenRegisterString((++counter), "length")
	OnCodeGenRegisterString((++counter), "narrowstring")
	OnCodeGenRegisterString((++counter), "widenfromptr")
	OnCodeGenRegisterString((++counter), "widenfrombuffer")
	OnCodeGenRegisterString((++counter), "string")
	OnCodeGenRegisterString((++counter), "integer")
	OnCodeGenRegisterString((++counter), "integer16")
	OnCodeGenRegisterString((++counter), "real")
	OnCodeGenRegisterString((++counter), "cast@@integer_to_string")
	OnCodeGenRegisterString((++counter), "cast@@string_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@real_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@integer_to_real")
	OnCodeGenRegisterString((++counter), "cast@@boolean_to_string")
	OnCodeGenRegisterString((++counter), "cast@@real_to_string")
	OnCodeGenRegisterString((++counter), "cast@@buffer_to_string")
	OnCodeGenRegisterString((++counter), "cast@@boolean_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@integer_to_integer16")
	OnCodeGenRegisterString((++counter), "cast@@integer16_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@string_to_real")
	OnCodeGenRegisterString((++counter), "boolean")
	OnCodeGenRegisterString((++counter), "buffer")
	OnCodeGenRegisterString((++counter), "nothing")
	OnCodeGenRegisterString((++counter), "buffer@@copy")
	OnCodeGenRegisterString((++counter), "cast")
	OnCodeGenRegisterString((++counter), ".")
	OnCodeGenRegisterString((++counter), "identifier")
	OnCodeGenRegisterString((++counter), "function")

	CurrentStringHandle = counter + 1
}


ReadFile : string filename, integer ref len -> string contents = ""
{
	integer INVALID_HANDLE_VALUE = 0xffffffff
	integer FILE_SHARE_READ = 0x01
	integer OPEN_EXISTING = 3
	integer GENERIC_READ = 0x80000000

	integer filehandle = CreateFile(filename, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0)
	if(filehandle != INVALID_HANDLE_VALUE)
	{
		integer PAGE_READONLY = 0x02
		
		len = GetFileSize(filehandle, 0)

		if(len > 0)
		{
			integer mappinghandle = CreateFileMapping(filehandle, 0, PAGE_READONLY, 0, 0, 0)
			if(mappinghandle != 0)
			{
				integer FILE_MAP_READ = 0x04
				integer ptr = MapViewOfFile(mappinghandle, FILE_MAP_READ, 0, 0, len)

				if(ptr != 0)
				{
					contents = widenfromptr(ptr, len)
				}
				CloseHandle(mappinghandle)
			}
			else
			{
				print("Failed to map file!")
			}
		}
		else
		{
			contents = ""
		}
		CloseHandle(filehandle)
	}
	else
	{
		print("Couldn't open that file!")
	}
}


Parse : string code, integer len -> boolean success = false
{
	integer startlexms = timeGetTime()
	Lex(code, len)
	integer durationlexms = timeGetTime() - startlexms
	
	print("Lexical analysis completed in " ; cast(string, durationlexms) ; "ms")


	// Discard the dummy token
	PopToken()

	IREnterProgram()

	string token = PeekToken(0)
	while(token != "")
	{
		if(ParseGlobalBlock())
		{
		}
		elseif(ParseSumType())
		{
		}
		elseif(ParseWeakAlias())
		{
		}
		elseif(ParseStrongAlias())
		{
		}
		elseif(ParseStructure())
		{
		}
		elseif(!ParseFunction())
		{
			print("Error: code could not be parsed: " ; token ; " " ; PeekToken(1) ; " " ; PeekToken(2))
			return()
		}

		token = PeekToken(0)
	}

	IRExitProgram()
	success = true
}


Lex : string code, integer len [nogc]
{
	integer index = 0
	integer lasttokenstart = 0

	integer state = CHARACTER_CLASS_WHITE
	integer prevstate = CHARACTER_CLASS_WHITE

	while(index < len)
	{
		string c = charat(code, index)

		if(state == CHARACTER_CLASS_WHITE)
		{
			if((c == "/") && (charat(code, index + 1) == "/"))
			{
				state = CHARACTER_CLASS_COMMENT
			}
			elseif(!IsWhitespace(c))
			{
				state = Classify(c, state)
				lasttokenstart = index
			}
		}
		elseif(state == CHARACTER_CLASS_IDENTIFIER)
		{
			boolean notidentifier = false
			if(IsWhitespace(c))
			{
				notidentifier = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_IDENTIFIER)
			{
				notidentifier = true
				state = Classify(c, state)
			}

			if(notidentifier)
			{
				PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			}
		}
		elseif(state == CHARACTER_CLASS_PUNCTUATION)
		{
			if(IsWhitespace(c))
			{
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_PUNCTUATION)
			{
				state = Classify(c, state)
			}

			PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			lasttokenstart = index
		}
		elseif(state == CHARACTER_CLASS_PUNCTUATION_COMPOUND)
		{
			boolean notcompound = false
			if(IsWhitespace(c))
			{
				notcompound = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_PUNCTUATION_COMPOUND)
			{
				notcompound = true
				state = Classify(c, state)
			}
			else
			{
				if((index - lasttokenstart) > 1)
				{
					string potentialtoken = substring(code, lasttokenstart, index - lasttokenstart)
					if(!IsValidPunctuation(potentialtoken))
					{
						PushToken(substring(potentialtoken, 0, length(potentialtoken) - 1))
						lasttokenstart = index - 1
					}
				}
			}

			if(notcompound)
			{
				if((index - lasttokenstart) > 1)
				{
					string potentialtoken = substring(code, lasttokenstart, index - lasttokenstart)
					if(!IsValidPunctuation(potentialtoken))
					{
						PushToken(substring(potentialtoken, 0, length(potentialtoken) - 1))
						lasttokenstart = index - 1						
					}
				}
				
				PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			}
		}
		elseif(state == CHARACTER_CLASS_COMMENT)
		{
			if(c == unescape("\r"))
			{
				state = CHARACTER_CLASS_WHITE
			}
			elseif(c == unescape("\n"))
			{
				state = CHARACTER_CLASS_WHITE
			}
		}
		elseif(state == CHARACTER_CLASS_STRING_LITERAL)
		{
			if(c == unescape("\'"))
			{
				state = CHARACTER_CLASS_WHITE
				PushToken(substring(code, lasttokenstart, index - lasttokenstart + 1))
			}
		}
		elseif(state == CHARACTER_CLASS_LITERAL)
		{
			boolean notliteral = false
			if(IsWhitespace(c))
			{
				notliteral = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_LITERAL)
			{
				notliteral = true
				state = Classify(c, state)
			}

			if(notliteral)
			{
				PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			}
		}
		
		// Handle negated literals (slightly hacky)
		if(state == CHARACTER_CLASS_PUNCTUATION_COMPOUND)
		{
			if(Classify(charat(code, index + 1), state) == CHARACTER_CLASS_LITERAL)
			{
				state = CHARACTER_CLASS_LITERAL
			}
		}


		if(state != prevstate)
		{
			lasttokenstart = index
		}

		prevstate = state
		++index
	}

	if((lasttokenstart < len) && (state != CHARACTER_CLASS_WHITE))
	{		
		PushToken(substring(code, lasttokenstart, len - lasttokenstart))
	}
}


IsValidPunctuation : string token -> boolean valid = false [nogc]
{
	if(token == "+=")
	{
		valid = true
	}
	elseif(token == "-=")
	{
		valid = true
	}
	elseif(token == "==")
	{
		valid = true
	}
	elseif(token == "!=")
	{
		valid = true
	}
	elseif(token == "++")
	{
		valid = true
	}
	elseif(token == "--")
	{
		valid = true
	}
	elseif(token == "->")
	{
		valid = true
	}
	elseif(token == "&&")
	{
		valid = true
	}
}


IsWhitespace : string c -> boolean white = false [nogc]
{
	if(c == " ")
	{
		white = true
	}
	elseif(c == unescape("\r"))
	{
		white = true
	}
	elseif(c == unescape("\n"))
	{
		white = true
	}
	elseif(c == unescape("\t"))
	{
		white = true
	}
}

Classify : string c, integer currentclass -> integer class = CHARACTER_CLASS_IDENTIFIER [nogc]
{
	if(c == "{")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "}")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == ":")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "(")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == ")")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "=")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == "&")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == ",")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == unescape("\'"))
	{
		class = CHARACTER_CLASS_STRING_LITERAL
	}
	elseif(c == "+")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == "-")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == "<")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == ">")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == ".")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		elseif(currentclass == CHARACTER_CLASS_PUNCTUATION_COMPOUND)
		{
			class = CHARACTER_CLASS_PUNCTUATION_COMPOUND		// hack!
		}
		else
		{
			class = CHARACTER_CLASS_PUNCTUATION
		}
	}
	elseif(c == ";")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "!")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == "[")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "]")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "0")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "1")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "2")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "3")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "4")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "5")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "6")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "7")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "8")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "9")
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == "x")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == "a")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == "b")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == "c")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == "d")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == "e")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == "f")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}	
}


// TODO - replace with better option
charat : string in, integer index -> string c = substring(in, index, 1) [nogc]


PushToken : string token [nogc]
{
	if(length(token) == 0)
	{
		print("Lexer attempted to push a zero-length token!")
		assert(false)
	}

	quick_append(TokenStreamTail.tail, token)
}


quick_append : simplelist<string> ref tailnode, string token [nogc]
{
	simplelist<string> newlist = token, nothing
	tailnode.next = newlist
	TokenStreamTail.tail = newlist
}

quick_append : nothing, string token [nogc]
{
	assert(false)
}


DumpStream : simplelist<string> ref tokens
{
	print(tokens.value)
	DumpStream(tokens.next)
}

DumpStream : nothing


PopToken :
{
	PopTokenFromStream(TokenStream, TokenStream.next)
}

PopTokens : integer count
{
	while(count > 0)
	{
		--count
		PopToken()
	}
}

PopTokenFromStream : simplelist<string> ref tokens, simplelist<string> ref tail
{
	tokens = tail
}

PopTokenFromStream : simplelist<string> ref tokens, nothing
{
	tokens.value = ""
}


PeekToken : integer displacement -> string token = PeekTokenInStream(TokenStream, displacement)

PeekTokenInStream : simplelist<string> ref tokens, integer displacement -> string token = tokens.value
{
	if(displacement > 0)
	{
		token = PeekTokenInStream(tokens.next, displacement - 1)
	}
}

PeekTokenInStream : nothing, integer displacement -> ""



PeekWithExpectation : integer displacement, string expected -> boolean found = false
{
	string token = PeekToken(displacement)
	if(token == expected)
	{
		found = true
	}
}


ParseGlobalBlock : -> boolean matched = false
{
	if(PeekToken(0) != "global")
	{
		return()
	}
	
	if(PeekToken(1) != "{")
	{
		return()
	}
	
	PopTokens(2)
	
	integer blockname = PoolString("@@globalblock")
	OnCodeGenRegisterScope(blockname, 0)
	OnCodeGenRegisterGlobalBlock(blockname)
	
	while(PeekToken(0) != "}")
	{
		if(!ParseInitialization(false))
		{
			print("Failure to parse global entry")
			return()
		}
	}
	
	PopToken()
	OnCodeGenExitContext()
	matched = true
}


ParseWeakAlias : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "alias"))
	{
		return()
	}

	if(!PeekWithExpectation(2, "="))
	{
		return()
	}
	
	PopToken()
	string aliasname = PeekToken(0)
	string basename = PeekToken(2)
	PopTokens(3)
	
	OnCodeGenRegisterWeakAlias((++GlobalWeakAliasCounter), PoolString(aliasname), PoolString(basename))
	
	matched = true
}


ParseStrongAlias : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "type"))
	{
		return()
	}

	if(!PeekWithExpectation(2, ":"))
	{
		return()
	}
	
	PopToken()
	string aliasname = PeekToken(0)
	string basename = PeekToken(2)
	PopTokens(3)
	
	OnCodeGenRegisterAlias((++GlobalAliasCounter), PoolString(aliasname), PoolString(basename))
	
	matched = true
}


ParseSumType : -> boolean matched = false
{
	boolean templated = false

	if(!PeekWithExpectation(0, "type"))
	{
		return()
	}
	
	string sumtypename = PeekToken(1)

	if(PeekToken(2) == "<")
	{
		PopTokens(3)
		if(!ParseTemplateParameters())
		{
			return()
		}

		templated = true
		
		if(!PeekWithExpectation(1, ":"))
		{
			return()
		}
	}
	elseif(!PeekWithExpectation(2, ":"))
	{
		return()
	}
	else
	{
		PopToken()
	}
	
	integer typename = PoolString(sumtypename)
	integer typeid = (++GlobalSumTypeCounter)
	PopTokens(2)
	
	ParseSumTypeBases(typename, typeid)
	
	string finalbasename = PeekToken(0)	
	OnCodeGenRegisterSumTypeBase(typename, typeid, PoolString(finalbasename), false)		// TODO - allow template args on trailing type
	PopToken()
	
	if(templated)
	{
		SetUpSumTypeTemplate(SumTypes, typeid)
	}
	
	matched = true
}


ParseSumTypeBases : integer typename, integer typeid
{
	boolean hasmorebases = true

	while(hasmorebases)
	{
		string basename = PeekToken(0)

		if(PeekToken(1) == "<")
		{
			integer baselookahead = ParseTemplateArgs(2)
			PopTokens(baselookahead + 2)

			OnCodeGenRegisterSumTypeBase(typename, typeid, PoolString(basename), true)
		}
		else
		{
			OnCodeGenRegisterSumTypeBase(typename, typeid, PoolString(basename), false)
			PopTokens(2)
		}

		hasmorebases = (PeekToken(1) == "|")
	}
}


ParseStructure : -> boolean matched = false
{
	boolean templated = false

	if(!PeekWithExpectation(0, "structure"))
	{
		return()
	}
		
	string structurename = PeekToken(1)

	if(PeekToken(2) == "<")
	{
		PopTokens(3)
		if(!ParseTemplateParameters())
		{
			return()
		}
		
		templated = true
				
		if(!PeekWithExpectation(1, ":"))
		{
			return()
		}
	}
	elseif(!PeekWithExpectation(2, ":"))
	{
		return()
	}

	PopTokens(2)
	if(!templated)
	{
		PopToken()
	}
	
	integer structuretype = (++GlobalStructureCounter)
	integer structurenamehandle = PoolString(structurename)

	boolean moremembers = true
	while(moremembers)
	{
		if(PeekToken(0) == "(")
		{
			PopToken()
			
			string memberfuncname = PeekToken(0)
			PopToken()
			
			if(!PeekWithExpectation(0, ":"))
			{
				return()
			}
			
			PopToken()
			
			integer memberfuncnamehandle = PoolString(memberfuncname)
			
			simplelist<integer> paramtypenames = 0, nothing
						
			boolean moreparams = true
			while(moreparams)
			{
				string paramtypename = PeekToken(0)
				PopToken()
				
				simpleprepend<integer>(paramtypenames, PoolString(paramtypename))
				
				if(PeekToken(0) != ",")
				{
					moreparams = false
				}
				else
				{
					PopToken()
				}
			}
			
			integer returntypehandle = 0
			
			if(PeekToken(0) == "->")
			{
				PopToken()
				returntypehandle = PoolString(PeekToken(0))
				PopToken()
			}
			
			OnCodeGenRegisterStructureMemFuncSig(structurenamehandle, structuretype, memberfuncnamehandle, returntypehandle)
			OnCodeGenRegisterStructureMemFuncSigParamList(structurenamehandle, structuretype, memberfuncnamehandle, paramtypenames)
			
			if(!PeekWithExpectation(0, ")"))
			{
				return()
			}
			
			PopToken()
		}
		else
		{
			boolean membertemplated = false
			boolean isref = false
			string membertypename = PeekToken(0)
			PopToken()
			string membername = PeekToken(0)
			PopToken()
			
			if(membername == "<")
			{
				integer memberlookahead = ParseTemplateArgs(0)
				if(memberlookahead > 0)
				{
					membertemplated = true
					PopTokens(memberlookahead + 1)
					membername = PeekToken(0)
					PopToken()
				}
				else
				{
					print("Error in template arguments for structure member")
					return()
				}
			}
			
			if(membername == "ref")
			{
				isref = true
				membername = PeekToken(0)
				PopToken()
			}
			
			OnCodeGenRegisterStructureMemVar(structurenamehandle, structuretype, PoolString(membername), PoolString(membertypename), isref, membertemplated)
		}
		
		if(PeekToken(0) != ",")
		{
			moremembers = false
		}
		else
		{
			PopToken()
		}
	}
	
	if(templated)
	{
		SetStructureToTemplate(Structures, structurenamehandle)
	}
	
	matched = true
}


ParseFunction : -> boolean matched = false
{
	string functionname = PeekToken(0)
	boolean templated = false
	
	if(PeekToken(1) == "<")
	{
		PopTokens(2)
		if(!ParseTemplateParameters())
		{
			return()
		}
		
		templated = true
	}

	if(!PeekWithExpectation(1, ":"))
	{
		return()
	}

	PopTokens(2)
	
	integer rawnamehandle = PoolString(functionname)
	integer namehandle = RegisterOverloadForFunction(rawnamehandle)
	
	OnCodeGenRegisterFunction(namehandle, rawnamehandle, templated)
	ParseFunctionParams(rawnamehandle, namehandle)
	ParseFunctionReturn(namehandle)
	ParseFunctionTags(namehandle, rawnamehandle)

	if(!PeekWithExpectation(0, "{"))
	{
		matched = true
		IREnterFunction(namehandle)
		OnCodeGenEnterFunctionBody(namehandle)
		IRExitFunction()
		return()
	}

	PopTokens(1)
	IREnterFunction(namehandle)
	OnCodeGenEnterFunctionBody(namehandle)

	ParseCodeBlock()
	
	IRExitFunction()
	matched = true
}


ParseTemplateParameters : -> boolean matched = false
{
	boolean hasparams = true
	
	while(hasparams)
	{
		string paramtype = PeekToken(0)
		string paramname = PeekToken(1)
		
		IRRegisterTemplateParameter(PoolString(paramtype), PoolString(paramname))
		
		PopTokens(2)
		
		if(PeekToken(0) == ">")
		{
			hasparams = false
		}
		elseif(PeekToken(0) == ",")
		{
			PopToken()
		}
		else
		{
			print("Syntax error in template parameters")
			return()
		}
	}
	
	matched = true
}


ParseFunctionParams : integer rawname, integer mangledname
{
	string typetoken = PeekToken(0)
	if(typetoken == "")
	{
		return()
	}
	
	while((typetoken != "{") && (typetoken != "->"))
	{
		if(typetoken == "nothing")
		{
			integer pooledhandle = PoolString(typetoken)
			
			PopToken()
			IRRegisterFunctionParam(pooledhandle, pooledhandle, false, false)
		}
		elseif(typetoken == "(")
		{
			PopToken()
			string higherordername = PeekToken(0)
			
			if(PeekWithExpectation(1, ":"))
			{
				PopTokens(2)
				
				simplelist<integer> paramtypenames = 0, nothing
				
				boolean moreparams = true
				if(PeekToken(0) == ")")
				{
					moreparams = false
				}
				
				while(moreparams)
				{
					string paramtypename = PeekToken(0)
					PopToken()
					
					simpleprepend<integer>(paramtypenames, PoolString(paramtypename))
					
					if(PeekToken(0) != ",")
					{
						moreparams = false
					}
					else
					{
						PopToken()
					}
				}
				
				integer returntypename = 0
				
				if(PeekToken(0) == "->")
				{
					PopToken()
					returntypename = PoolString(PeekToken(0))
					PopToken()
				}
				
				integer sigtype = FindOrCreateFunctionSignatureType(paramtypenames, returntypename)				
				
				if(!PeekWithExpectation(0, ")"))
				{	
					print("Error in higher order function parameter syntax")
					return()
				}
				
				UnresolvedParameter p = PoolString(higherordername), 0, sigtype, false, nothing, nothing
				AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)

				PopToken()
			}
		}
		elseif(HandleLiteralFunctionParam(typetoken))
		{
			PopToken()
			EnsurePatternMatcherExists(PendingPatternMatchers, rawname, mangledname)
			EnsurePatternMatcherExists(PendingPatternMatchers, rawname, rawname)			// kind of a dumb hack
		}
		else
		{
			integer lookahead = 0
			boolean templated = false
			
			if(PeekToken(1) == "<")
			{
				lookahead = ParseTemplateArgs(2)
				if(lookahead > 0)
				{
					templated = true
				}
			}
			
			string nametoken = PeekToken(1 + lookahead)
			PopTokens(2 + lookahead)
			
			boolean isreference = false
			if(nametoken == "ref")
			{
				isreference = true
				nametoken = PeekToken(0)
				PopToken()
			}
			
			// TODO - error checking
			
			IRRegisterFunctionParam(PoolString(nametoken), PoolString(typetoken), isreference, templated)
		}
		
		typetoken = PeekToken(0)
		if(typetoken != ",")
		{
			return()
		}
		PopToken()
		typetoken = PeekToken(0)
	}
}


ParseFunctionReturn : integer namehandle
{
	if(!PeekWithExpectation(0, "->"))
	{
		return()
	}
	
	PopToken()
		
	OnCodeGenEnterFunctionReturn(namehandle, true)
	if(!ParseInitialization(true))
	{
		ParseExpression()
	}
	OnCodeGenExitContext()
}


ParseFunctionTags : integer functionname, integer rawfuncname
{
	if(!PeekWithExpectation(0, "["))
	{
		return()
	}
	
	PopToken()
	
	while(PeekToken(0) != "]")
	{
		ParseSingleFunctionTag(functionname, rawfuncname)
	}
	
	PopToken()
}

ParseSingleFunctionTag : integer functionname, integer rawfuncname
{
	string tagname = PeekToken(0)
	
	if(PeekToken(1) == "(")
	{
		PopTokens(2)
		OnCodeGenRegisterFunctionTag(functionname, tagname, rawfuncname)
		
		string token = PeekToken(0)
		while(token != ")")
		{
			if(token == "")
			{
				print("Incomplete function tag")
				return()
			}
			
			string parameter = PeekToken(0)
			if(substring(parameter, 0, 1) == unescape("\'"))
			{
				parameter = substring(parameter, 1, length(parameter) - 2)
			}
			
			PopToken()
			
			OnCodeGenRegisterFunctionTagParam(functionname, tagname, parameter)

			token = PeekToken(0)
			if(token == ",")
			{
				PopToken()
				token = PeekToken(0)
			}			
		}
		
		PopToken()
	}
	else
	{
		PopToken()
		OnCodeGenRegisterFunctionTag(functionname, tagname, rawfuncname)
	}
	
	if(tagname == "external")
	{
		OnCodeGenRegisterFunctionInvokeTag(functionname, PoolString("@@external"))
	}
}


ParseStatement : boolean substatement -> boolean matched = false
{
	string statementname = PeekToken(0)
	boolean templated = false
	integer lookahead = 0
	
	if(PeekToken(1) == "<")
	{
		lookahead = ParseTemplateArgs(2)
		if(lookahead > 0)
		{
			templated = true
		}
	}
	
	if(!PeekWithExpectation(1 + lookahead, "("))
	{
		return()
	}

	if(substatement)
	{
		OnCodeGenEnterSubStatement()
	}
	
	IREnterStatement(statementname, !substatement, templated)
	
	PopTokens(2 + lookahead)

	string token = PeekToken(0)
	while(token != ")")
	{
		if(token == "")
		{
			print("Error: missing a )")
			return()
		}

		if(!ParseExpression())
		{
			print("Error: mangled expression")
			return()
		}
		
		token = PeekToken(0)
		if(token == ",")
		{
			PopToken()
			token = PeekToken(0)
			OnCodeGenShiftParameter()
		}
	}
	
	PopToken()
	IRExitStatement()
	
	if(substatement)
	{
		IRExitStatement()
	}
	
	matched = true
}

ParseTemplateArgs : integer intialconsume -> integer consumed = intialconsume
{
	TemplateArgumentList newarglist = scratchtemplatearglist
	prepend<TemplateArgumentList>(ScratchTemplateArgumentStack, newarglist)

	boolean hasargs = true
	while(hasargs)
	{
		string argvalue = PeekToken(consumed)
		++consumed
		
		integer replacehandle = PoolString(argvalue)
		TemplateArgument newarg = replacehandle
		AppendTemplateArgument(ScratchTemplateArgumentStack.value.Args, newarg)
		
		if(PeekToken(consumed) == ">")
		{
			hasargs = false
		}
		elseif(PeekToken(consumed) == ",")
		{
			++consumed
		}
		else
		{
			PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
			consumed = 0
			return()
		}
	}
}

ParseInitialization : boolean inreturn -> boolean matched = false
{
	boolean templated = false
	string typename = PeekToken(0)
	string varname = PeekToken(1)
	
	integer skipahead = 0
	if(varname == ".")
	{
		return()
	}
	elseif(varname == "<")
	{
		skipahead = ParseTemplateArgs(2)
		varname = PeekToken(1 + skipahead)
		
		templated = true
	}

	if(PeekToken(2 + skipahead) != "=")
	{
		return()
	}

	PopTokens(3 + skipahead)
	
	if(inreturn)
	{
		OnCodeGenEnterSubStatement()
	}

	IREnterStatement(typename, true, templated)
	IRAddLiteralIdentifier(varname)
	
	OnCodeGenShiftParameter()
	
	ParseExpression()
	while(PeekToken(0) == ",")
	{
		PopToken()
		OnCodeGenShiftParameter()
		ParseExpression()
	}
	
	IRExitStatement()

	matched = true
	
	if(inreturn)
	{
		IRExitStatement()
		Functions.value.AnonymousReturn = false
	}
}


ParseExpression : -> boolean matched = false
{
	boolean matchedstatement = false
	
	if(!ParseExpressionTerm(true, matchedstatement))
	{
		return()
	}
	
	if(matchedstatement && (PeekToken(0) == ")"))
	{
	}
	else
	{
		while(ParseExpressionOperator())
		{
			if(!ParseExpressionTerm(false, matchedstatement))
			{
				return()
			}
		}
	}

	matched = true
}

ParseExpressionTerm : boolean startsexpr, boolean ref matchedstatement -> boolean matched = false
{
	string term = PeekToken(0)
		
	if(term == ")")
	{
		return()
	}
	elseif(term == ",")
	{
		return()
	}
	elseif(term == "")
	{
		return()
	}
	elseif(term == "(")
	{
		OnCodeGenRegisterParenthetical()
		
		PopToken()
		if(ParseExpression())
		{
			PopToken()
			matched = true
		}
		else
		{
			print("Error in parenthetical expression")
		}
		
		OnCodeGenExitContext()
		
		
		return()
	}

	// Unary operator detection
	if(term == "!")
	{
		PopToken()
		IRAddOperator(term)
		matched = ParseExpressionTerm(startsexpr, matchedstatement)
		return()
	}

	if(term == "false")
	{
		IRAddLiteralBoolean(false)
	}
	elseif(term == "true")
	{
		IRAddLiteralBoolean(true)
	}
	elseif(term == "0")
	{
		IRAddLiteralInteger(0)
	}
	elseif(term == "0.0")
	{
		IRAddLiteralReal(0.0)
	}
	elseif(ParsePreopStatement(true))
	{
		matched = true
		return()
	}
	elseif(ParseStatement(true))
	{
		matched = true
		matchedstatement = true
		return()
	}
	else
	{
		if(substring(term, 0, 1) == unescape("\'"))
		{
			string stringliteral = substring(term, 1, length(term) - 2)
			IRAddLiteralString(stringliteral)			
		}
		else
		{
			if(stringcontains(term, "."))
			{
				real realvalue = cast(real, term)
				IRAddLiteralReal(realvalue)
			}
			else
			{
				integer literalvalue = cast(integer, term)
				if(literalvalue != 0)
				{
					IRAddLiteralInteger(literalvalue)
				}
				else
				{
					IRAddLiteralIdentifier(term)
				}
			}
		}
	}

	PopToken()
	matched = true
}

ParseExpressionOperator : -> boolean matched = false
{
	string op = PeekToken(0)	
	if(op == ")")
	{
		return()
	}
	elseif(op == ",")
	{
		return()
	}
	elseif(op == "")
	{
		return()
	}
	

	boolean knownoperator = false
	if(op == "+")
	{
		knownoperator = true
	}
	elseif(op == "-")
	{
		knownoperator = true
	}
	elseif(op == "*")
	{
		knownoperator = true
	}
	elseif(op == "/")
	{
		knownoperator = true
	}
	elseif(op == "==")
	{
		knownoperator = true
	}
	elseif(op == "!=")
	{
		knownoperator = true
	}
	elseif(op == ".")
	{
		knownoperator = true
	}
	elseif(op == ";")
	{
		knownoperator = true
	}
	elseif(op == ">")
	{
		knownoperator = true
	}
	elseif(op == "<")
	{
		knownoperator = true
	}
	elseif(op == "&")
	{
		knownoperator = true
	}
	elseif(op == "&&")
	{
		knownoperator = true
	}
	
	if(knownoperator)
	{
		IRAddOperator(op)
		PopToken()
		matched = true
	}
}


ParseAssignment : -> boolean matched = false
{
	integer lhslength = 1
	while(PeekToken(lhslength) == ".")
	{
		lhslength += 2
	}
	
	string assignmenttoken = PeekToken(lhslength)
	boolean recognized = false
	if(assignmenttoken == "=")
	{
		recognized = true
	}
	elseif(assignmenttoken == "+=")
	{
		recognized = true
	}
	elseif(assignmenttoken == "-=")
	{
		recognized = true
	}
	
	if(!recognized)
	{
		return()
	}
	
	if(lhslength == 1)
	{
		OnCodeGenEnterAssignment(PoolString(assignmenttoken), PoolString(PeekToken(0)), 0, 0)
	}
	else
	{
		OnCodeGenEnterAssignmentCompound(PoolString(assignmenttoken), PoolString(PeekToken(0)), 0, 0)
		integer tokenindex = 2
		while(tokenindex < lhslength)
		{
			OnCodeGenAssignmentCompoundMember(PoolString(PeekToken(tokenindex)))
			tokenindex += 2
		}
		OnCodeGenAssignmentCompoundEnd()
	}
	
	PopTokens(lhslength + 1)
	
	boolean haschain = true
	while(haschain)
	{
		lhslength = 1
		while(PeekToken(lhslength) == ".")
		{
			lhslength += 2
		}
			
		if(PeekToken(lhslength) == "=")
		{
			if(assignmenttoken != "=")
			{
				print("Cannot chain assignments with side effects")
				return()
			}
			
			if(lhslength == 1)
			{
				OnCodeGenChainAssignment(PoolString("="), PoolString(PeekToken(0)), 0, 0)
			}
			else
			{
				OnCodeGenChainAssignmentCompound(PoolString("="), PoolString(PeekToken(0)), 0, 0)
				integer tokenindex = 2
				while(tokenindex < lhslength)
				{
					OnCodeGenChainAssignmentCompoundMember(PoolString(PeekToken(tokenindex)))
					tokenindex += 2
				}
				OnCodeGenChainAssignmentCompoundEnd()
			}			
			
			PopTokens(lhslength + 1)
		}
		else
		{
			haschain = false
		}
	}
	
	if(ParseExpression())
	{
		matched = true
		OnCodeGenExitContext()
	}
	else
	{
		print("Right hand side of assignment is not a valid expression")
	}
}


ParseEntity : -> boolean matched = false
{
	string entityname = PeekToken(0)
	
	if(entityname == "if")
	{
		if(PeekToken(1) == "(")
		{
			PopTokens(2)
			
			OnCodeGenEnterChain()
			OnCodeGenEnterEntity(0x11, 0)
			
			ParseExpression()
			PopToken()
			
			matched = ParseEntityCode()
			
			while(PeekToken(0) == "elseif")
			{
				PopTokens(2)
				OnCodeGenEnterEntity(0x12, 0)
				ParseExpression()
				PopToken()
				matched = ParseEntityCode()
			}
			
			if(PeekToken(0) == "else")
			{
				PopToken()
				OnCodeGenEnterEntity(0x13, 0)
				matched = ParseEntityCode()
			}
			
			OnCodeGenExitContext()
		}
	}
	elseif(entityname == "while")
	{
		if(PeekToken(1) == "(")
		{
			PopTokens(2)
			
			OnCodeGenEnterChain()
			OnCodeGenEnterEntity(0x14, 0)
			
			ParseExpression()
			PopToken()

			matched = ParseEntityCode()
			
			OnCodeGenExitContext()
		}
	}
}

ParseCodeBlock :
{
	string token = PeekToken(0)
	while(token != "}")
	{
		if(token == "")
		{
			print("Error: missing a }")
			return()
		}

		if(ParseEntity())
		{
		}
		elseif(ParsePreopStatement(false))
		{
		}
		elseif(ParsePostopStatement())
		{
		}
		elseif(ParseStatement(false))
		{
		}
		elseif(ParseInitialization(false))
		{
		}
		elseif(ParseAssignment())
		{
		}
		else
		{
			print("Parse failure: " ; PeekToken(0) ; " " ; PeekToken(1) ; " " ; PeekToken(2))
			return()
		}
		
		token = PeekToken(0)
	}

	PopToken()
}


ParseEntityCode : -> boolean matched = false
{
	if(PeekToken(0) == "{")
	{
		OnCodeGenEnterEntityCode()
		PopToken()
		ParseCodeBlock()
		OnCodeGenExitContext()
		OnCodeGenExitContext()
		matched = true
	}
	else
	{
		print("Expected code block")
	}
}


ParsePreopStatement : boolean substatement -> boolean matched = false
{
	boolean recognized = false
	string potential = PeekToken(0)
	
	if(potential == "++")
	{
		recognized = true
	}
	elseif(potential == "--")
	{
		recognized = true
	}
	
	if(recognized)
	{
		PopToken()
		
		string operand = PeekToken(0)
		PopToken()
		
		OnCodeGenPreparePreOpStatement(PoolString(potential), PoolString(operand))
		
		while(PeekToken(0) == ".")
		{
			PopToken()
			operand = PeekToken(0)
			PopToken()
			
			OnCodeGenPreparePreOpCompoundOperand(PoolString(operand))
		}
		
		OnCodeGenCompletePreOpStatement(substatement)
		
		matched = true
	}
}

ParsePostopStatement : -> boolean matched = false
{
	boolean recognized = false
	
	string operand = PeekToken(0)
	integer operandlength = 1
	while(PeekToken(operandlength) == ".")
	{
		operandlength += 2
	}
	
	string potential = PeekToken(operandlength)
	if(potential == "++")
	{
		recognized = true
	}
	elseif(potential == "--")
	{
		recognized = true
	}
	
	if(recognized)
	{
		OnCodeGenRegisterPostOpStatement(PoolString(potential), PoolString(operand))

		if(operandlength > 1)
		{
			integer tokenindex = 2
			while(tokenindex < operandlength)
			{
				operand = PeekToken(tokenindex)
				OnCodeGenAddPreOpCompoundOperand(PoolString(operand))
				tokenindex += 2
			}
		}

		PopTokens(operandlength + 1)
				
		matched = true
	}
}


HandleLiteralFunctionParam : string token -> boolean isliteral = false
{
	if(token == "0")
	{
		RegisterLiteralFunctionParam(0)
		isliteral = true
	}
	elseif(token == "0.0")
	{
		RegisterLiteralFunctionParam(0.0)
		isliteral = true
	}
	elseif(stringcontains(token, "."))
	{
		real realval = cast(real, token)
		RegisterLiteralFunctionParam(realval)
		isliteral = true
	}
	else
	{
		integer intval = cast(integer, token)
		if(intval != 0)
		{
			RegisterLiteralFunctionParam(intval)
			isliteral = true
			return()
		}
				
		// TODO - support pattern match literals of other types
	}
}


RegisterLiteralFunctionParam : integer literalvalue
{
	ExpressionAtom atom = literalvalue
	list<ExpressionAtom> atoms = atom, nothing
	Expression expr = atoms, 0x01000001		// integer type signature

	UnresolvedParameter p = 0, GetNameOfType(expr.Type), expr.Type, false, expr, nothing
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

RegisterLiteralFunctionParam : real literalvalue
{
	ExpressionAtom atom = literalvalue
	list<ExpressionAtom> atoms = atom, nothing
	Expression expr = atoms, 0x01000004		// real type signature
	
	UnresolvedParameter p = 0, GetNameOfType(expr.Type), expr.Type, false, expr, nothing
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}


//
// List traversal/inspection functions
//

map<type T> : list<T> ref thelist, (func : T)
{
	func(thelist.value)
	map<T>(thelist.next, func)
}

map<type T> : nothing, (func : T)
{
}


listcontains : simplelist<integer> ref thelist, integer value -> boolean ret = false
{
	if(thelist.value == value)
	{
		ret = true
	}
	else
	{
		ret = listcontains(thelist.next, value)
	}
}

listcontains : nothing, integer value -> boolean contains = false



TypeListContains : simplelist<integer> ref thelist, integer value -> integer ret = 0
{
	integer listval = thelist.value
	if((listval & 0x7f000000) == 0x05000000)
	{
		listval = FindTypeAliasBase(TypeAliases, listval)
	}
	
	if((value & 0x7f000000) == 0x07000000)
	{
		if(SumTypeHasBase(SumTypes, MakeNonReferenceType(value), MakeNonReferenceType(listval)))
		{
			ret = value
			return()
		}
	}
	
	if((listval & 0x7f000000) == 0x07000000)
	{
		if(SumTypeHasBase(SumTypes, listval, MakeNonReferenceType(value)))
		{
			ret = value
			return()
		}
	}
	
	if(MakeNonReferenceType(listval) == value)
	{
		ret = listval
	}
	elseif(listval == value)
	{
		ret = listval
	}
	else
	{
		ret = TypeListContains(thelist.next, value)
	}
}

TypeListContains : nothing, integer value -> 0



//
// Callback used to emit a byte to a bytecode stream
//

OnBytecodeEmitByte : integer b
{
	writebuffer(Hack, HackSize, b)
	++HackSize
}


//
// Callback used to emit a series of bytes to a bytecode stream
//

OnBytecodeEmitBytes : integer bytes, integer size
{
	writebuffer(Hack, HackSize, bytes, size)
	HackSize += size
}


//
// Callback used to retrieve a bytecode stream's pointer
//

OnBytecodeGetBuffer : -> buffer ret = Hack


//
// Callback used to retrieve the size of a bytecode stream
//

OnBytecodeGetSize : -> integer size = HackSize



OnBytecodeEmitInteger : integer value
{
	writebuffer(Hack, HackSize, (value) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x100) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x10000) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x1000000) & 0xff)
	++HackSize
}

OnBytecodeEmitInteger16 : integer16 value
{
	integer v = cast(integer, value)
	writebuffer(Hack, HackSize, (v) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (v / 0x100) & 0xff)
	++HackSize
}

OnBytecodeEmitReal : real value
{
	writebuffer(Hack, HackSize, value)
	HackSize = HackSize + 4
}

OnBytecodeEmitString : string value
{
	integer len = (length(value) + 1) * 2
	writebuffer(Hack, HackSize, value, len)
	HackSize += len
}

OnBytecodeEmitBoolean : boolean value
{
	OnBytecodeEmitByte(cast(integer, value))
}


OnBytecodePoolString : integer handle, string data
{
	OnBytecodeEmitByte(0x10)			// PoolString instruction
	OnBytecodeEmitInteger(handle)
	OnBytecodeEmitString(data)
}

OnBytecodeLexicalScope : integer name, integer parent, integer count
{
	OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(parent)
	OnBytecodeEmitInteger(count)
}

OnBytecodeLexicalScopeEntry : integer varname, integer vartype, integer origin
{
	OnBytecodeEmitInteger(varname)
	OnBytecodeEmitInteger(vartype)
	OnBytecodeEmitInteger(origin)
	OnBytecodeEmitBoolean(false)
}

OnBytecodeInvokeOffset : integer name
{
	OnBytecodeEmitByte(0x27)			// InvokeOffset instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(0)
}

OnBytecodeHalt :
{
	OnBytecodeEmitByte(0x00)			// Halt instruction
}

OnBytecodeEnterFunction : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x01)			// EntityTags::Function
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitFunction :
{
	OnBytecodeEmitByte(0x09)			// Return instruction
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeInvoke : integer target
{
	OnBytecodeEmitByte(0x07)			// Invoke instruction
	OnBytecodeEmitInteger(target)
}

OnBytecodeEnterEntity : integer tag, integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(tag)
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitEntity :
{
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeBeginChain :
{
	OnBytecodeEmitByte(0x0d)			// BeginChain instruction
}

OnBytecodeEndChain :
{
	OnBytecodeEmitByte(0x0e)			// EndChain instruction
}

OnBytecodeDefineStructure : integer typeid, integer nummembers
{
	OnBytecodeEmitByte(0x14)			// DefineStructure instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(nummembers)
}

OnBytecodeStructureMember : integer name, integer typeid
{
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeReadReference :
{
	OnBytecodeEmitByte(0x17)			// ReadRef instruction
}

OnBytecodeReadReferenceAnnotated :
{
	OnBytecodeEmitByte(0x24)			// ReadRefAnnotated instruction
}

OnBytecodeAllocStructure : integer typeid
{
	OnBytecodeEmitByte(0x13)			// AllocStructure instruction
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeBindReference : integer frameskip, integer index
{
	if(index < 0)
	{
		print("Binding reference to a missing variable!")
		assert(false)
	}

	OnBytecodeEmitByte(0x03)			// BindRef instruction
	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(index)
}

OnBytecodeAssign :
{
	OnBytecodeEmitByte(0x06)			// Assign instruction
}

OnBytecodePushVarValueNoCopy : integer name
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(name)
}

OnBytecodePushVarValue : integer name, integer typeid
{
	OnBytecodePushVarValueNoCopy(name)
	
	integer family = typeid & 0xff000000

	if(typeid == 0x02000001)			// Buffer type signature
	{
		OnBytecodeCopyBuffer()
	}
	elseif(family == 0x03000000)			// Structure family signature
	{
		OnBytecodeCopyStructure()
	}
	elseif(family == 0x08000000)			// Template instance family signature
	{
		OnBytecodeCopyStructure()
	}
}

OnBytecodeCopyBuffer :
{
	OnBytecodeEmitByte(0x19)			// CopyBuffer instruction
}

OnBytecodeCopyStructure :
{
	OnBytecodeEmitByte(0x1b)			// CopyStructure instruction
}

OnBytecodeCopyToStructure : integer structurename, integer membername
{
	OnBytecodeEmitByte(0x16)			// CopyToStructure instruction
	OnBytecodeEmitInteger(structurename)
	OnBytecodeEmitInteger(membername)
}

OnBytecodeSetReturnRegister : integer varindex
{
	OnBytecodeEmitByte(0x0a)			// SetRetVal instruction
	OnBytecodeEmitInteger(varindex)
}

OnBytecodePushVarNoCopy : integer varname
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeInvokeIndirect : integer varname
{
	OnBytecodeEmitByte(0x08)			// InvokeIndirect instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeEnterPatternResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x02)			// EntityTags::PatternMatchingResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitPatternResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeConstructSumType :
{
	OnBytecodeEmitByte(0x21)			// ConstructSumType instruction
}

OnBytecodeEnterTypeResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x05)			// EntityTags::TypeResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitTypeResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodePopStack : integer bytes
{
	OnBytecodeEmitByte(0x04)			// Pop instruction
	OnBytecodeEmitInteger(bytes)
}

OnBytecodeBindRefByHandle : integer id
{
	OnBytecodeEmitByte(0x1d)
	OnBytecodeEmitInteger(id)
}

OnBytecodeBindStructReference : integer membertype, integer memberoffset
{
	OnBytecodeEmitByte(0x18)			// BindMemberRef instruction
	OnBytecodeEmitInteger(MakeNonReferenceType(membertype))
	OnBytecodeEmitInteger(memberoffset)
}

OnBytecodePushType : integer typeid
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeAssignSumType :
{
	OnBytecodeEmitByte(0x23)			// AssignSumType instruction
}

OnBytecodePushLocal : boolean isparam, integer frameskip, integer offset, integer size
{
	if(isparam)
	{
		OnBytecodeEmitByte(0x26)		// ReadParam instruction
	}
	else
	{
		OnBytecodeEmitByte(0x25)		// ReadStack instruction
	}

	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(offset)
	OnBytecodeEmitInteger(size)
}

OnBytecodePushBoolean : boolean literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000003)		// Boolean type signature
	OnBytecodeEmitBoolean(literal)
}

OnBytecodePushLiteralString : integer literalhandle
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x02000000)		// String type signature
	OnBytecodeEmitInteger(literalhandle)
}

OnBytecodePushLiteralInteger : integer literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(literal)
}

OnBytecodePushLiteralInteger16 : integer16 literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000002)		// Integer16 type signature
	OnBytecodeEmitInteger16(literal)
}

OnBytecodePushTypeAnnotation : integer annotation
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(annotation)
}

OnBytecodePushLiteralFunction : integer name
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x09000000)		// Function family signature (N.B. not the actual function type!)
	OnBytecodeEmitInteger(name)
}

OnBytecodePushLiteralReal : real value
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000004)		// Real type signature
	OnBytecodeEmitReal(value)
}

OnBytecodeEmitFunctionSignature : integer typeid, integer rettype, integer paramcount
{
	OnBytecodeEmitByte(0x28)			// FuncSig instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(rettype)
	OnBytecodeEmitInteger(paramcount)
}

OnBytecodeEmitFunctionSigParam : integer paramtype
{
	OnBytecodeEmitInteger(paramtype)
	OnBytecodeEmitBoolean(false)
}


GetTypeSize : integer typeid -> integer size = 0
{
	if(typeid == 0x01000001)			// Integer
	{
		size = 4
	}
	elseif(typeid == 0x01000002)			// Integer16
	{
		size = 2
	}
	elseif(typeid == 0x01000003)			// Boolean
	{
		size = 1
	}
	elseif(typeid == 0x01000004)			// Real
	{
		size = 4
	}
	elseif(typeid == 0x02000000)			// StringHandle
	{
		size = 4
	}
	elseif(IsStructureType(typeid))			// StructureHandle
	{
		size = 4
	}
	elseif((typeid & 0xff000000) == 0x07000000)	// SumType
	{
		size = 4 + GetLargestSumTypeBaseSize(typeid)
	}
	elseif(typeid == 0x00000004)			// Nothing
	{
		size = 0
	}
	else
	{
		print("Undefined type for size retrieval - " ; cast(string, typeid))
		assert(false)
	}
}


//
// Data structures for holding the internal representation of a compiled program
//

structure StringTableEntry :
	integer Handle,
	string Data

structure TypeAlias :
	integer TypeID,
	integer AliasNameHandle,
	integer BaseNameHandle

structure StructureMemberVariable :
	integer Name,
	integer Type,
	integer TypeNameHandle,
	OptionalTemplateArgs TemplateArgs

structure StructureMemberFunctionRef :
	integer Name,
	FunctionSignature ref Signature


type StructureMember : StructureMemberVariable | StructureMemberFunctionRef

structure StructureDefinition :
	integer Name,
	integer Type,
	integer ConstructorName,
	integer AnonConstructorName,
	integer CopyConstructorName,
	list<StructureMember> ref Members,
	boolean IsTemplate


structure IdentifierAtom :
	integer Handle,
	integer Type,
	boolean IsReference

structure StringHandleAtom :
	integer Handle

structure OperatorInvokeAtom :
	integer OperatorName

structure TypeAnnotationAtom :
	integer Type

structure RefBinding :
	integer Identifier,
	integer StructureName,
	boolean IsReference,
	boolean InputIsReference
	
structure CompoundAtom :
	list<RefBinding> ref Bindings,
	integer Type

structure AtomSentinel :
	integer dummy


type ExpressionAtom : 	integer | integer16 | boolean | real | StringHandleAtom |
			IdentifierAtom | OperatorInvokeAtom | TypeAnnotationAtom | RefBinding |
			CompoundAtom |
			Statement |
			ParentheticalExpression |
			AtomSentinel


structure Expression :
	list<ExpressionAtom> ref Atoms,
	integer Type

type OptionalExpression : Expression | nothing

structure ExpressionList :
	list<Expression> ref Expressions

type OptionalExpressionList : ExpressionList | nothing


type OptionalTemplateArgs : TemplateArgumentList | nothing

type ExpressionOrAssignment : Expression | Assignment | AssignmentCompound

structure Statement :
	integer Name,
	OptionalExpressionList Parameters,
	integer Type,
	boolean TopLevel,
	OptionalTemplateArgs TemplateArgs

structure Assignment :
	integer Operator,
	integer LHSName,
	integer LHSType,
	integer Annotation,
	ExpressionOrAssignment RHS

structure AssignmentCompound :
	integer Operator,
	simplelist<integer> LHS,			// TODO - JIT bug - making this a reference type causes bogosity
	integer LHSType,
	integer Annotation,
	ExpressionOrAssignment RHS

structure PreOpStatement :
	integer Operator,
	simplelist<integer> ref Operand,
	integer Type

structure PostOpStatement :
	integer Operator,
	simplelist<integer> ref Operand,
	integer Type

type ExpressionOrPrePostOp : Expression | PreOpStatement | PostOpStatement


structure ParentheticalExpression :
	ExpressionOrPrePostOp Inner


type CodeBlockEntry : Statement | PreOpStatement | PostOpStatement |
		      Assignment | AssignmentCompound | EntityChain

structure CodeBlock :
	list<CodeBlockEntry> ref Entries

type OptionalCodeBlock : CodeBlock | nothing

structure Entity :
	integer Tag,
	integer PostfixTag,
	OptionalExpression Param,
	OptionalCodeBlock Code


structure EntityList :
	list<Entity> ref ActualList

type OptionalEntityList : EntityList | nothing


structure EntityChain :
	OptionalEntityList Entries
		
		
structure UnresolvedParameter :
	integer NameHandle,
	integer TypeNameHandle,
	integer ResolvedType,
	boolean HasRefTag,
	OptionalExpression PatternMatchValue,
	OptionalTemplateArgs TemplateArgs
		
structure FunctionParams :
	list<UnresolvedParameter> ref Params
	
type OptionalParameters : FunctionParams | nothing

structure Overload :
	integer NormalName,
	integer MangledName

structure FunctionDefinition :
	integer RawName,
	integer Name,
	boolean IsTemplate,
	OptionalExpression Return,
	OptionalCodeBlock Code,
	boolean AnonymousReturn,
	integer InvokeTag,
	OptionalParameters Params,
	boolean InferenceDone
	

structure Variable :
	integer Name,
	integer VarType,
	integer Origin,
	integer Offset

structure Scope :
	integer Name,
	integer ParentName,
	list<Variable> Variables,
	integer ParamOffset,
	integer LocalOffset


structure Parameter :
	integer Name,
	integer Type
	

structure ContextStackEntry :
	integer EntryType,
	integer EntryName

structure SumTypeBase :
	integer Name,
	OptionalTemplateArgs TemplateArgs

structure SumType :
	integer Name,
	integer Type,
	list<SumTypeBase> ref Bases,
	boolean IsTemplate


structure FunctionSignature :
	integer Name,
	list<Parameter> ref Parameters,
	integer ReturnTypeName

structure PendingTypeMatcher :
	integer OverloadName,
	integer MatcherName
	
structure PendingPatternMatcher :
	integer RawName,
	integer OverloadName,
	integer MatcherName

structure TypeMatcher :
	integer Name,
	list<FunctionSignature> ref Overloads


structure FunctionTag :
	integer FunctionName,
	string TagName,
	list<string> ref Parameters


structure TemplateParameter :
	integer ParamName,
	integer ParamType

structure TemplateArgument :
	integer ReplaceWith

structure TemplateArgumentList :
	list<TemplateArgument> ref Args

structure TemplateFunction :
	integer FunctionDefName,
	list<TemplateParameter> ref Parameters

structure TemplateStructure :
	integer StructureDefName,
	list<TemplateParameter> ref Parameters

structure TemplateSumType :
	integer SumTypeName,
	list<TemplateParameter> ref Parameters

structure TemplateInstance :
	integer DefName,
	integer InstanceName,
	list<TemplateArgument> ref Arguments


//
// Callback invoked when the code generation process can begin
//

OnCodeGenProcessProgram :
{
	GenerateTypeMatcherMappings(Functions)
	GeneratePendingTypeMatchers(PendingTypeMatchers)

	CodeGenEmitStrings(GlobalStrings)
	CodeGenEmitSumTypes(SumTypes)
	CodeGenRearrangeStructures(Structures)
	CodeGenEmitStructures(Structures)
	CodeGenEmitFunctionSignatures(FunctionSignatures)
	
	if(GlobalCodeBlockName != 0)
	{
		CodeGenEmitSpecificScope(Scopes, GlobalCodeBlockName)
	}
	
	CodeGenEmitScopes(Scopes)
	CodeGenEmitFunctionTags(FunctionTags)
	CodeGenEmitGlobalBlockPrologue(GlobalCodeBlock)
	CodeGenEmitFunctions(Functions)
	CodeGenEmitGlobalBlockEpilogue(GlobalCodeBlock)
	CodeGenEmitTypeMatchers(TypeMatchers)
	CodeGenEmitPatternMatchers(PendingPatternMatchers)
	CodeGenEmitConstructors(Structures)
}

OnCodeGenRegisterString : integer handle, string data
{
	StringTableEntry entry = handle, data
	prepend<StringTableEntry>(GlobalStrings, entry)

	if(handle > CurrentStringHandle)
	{
		CurrentStringHandle = handle
	}
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer typenamehandle, boolean isref, boolean templated
{
	integer refnum = 0
	if(isref)
	{
		refnum = 0x80000000
	}

	StructureMemberVariable member = membername, refnum, typenamehandle, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
		member.TemplateArgs = arglist
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}
	
	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettypename
{
	list<Parameter> p = dummyparam, nothing
	FunctionSignature signature = name, p, rettypename
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype
{
	Parameter param = 1, paramtype
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, simplelist<integer> ref typenames
{
	OnCodeGenRegisterStructureMemFuncSigParamList(structurename, structuretype, membername, typenames.next)
	
	if(typenames.value != 0)
	{
		OnCodeGenRegisterStructureMemFuncSigParam(structurename, structuretype, membername, typenames.value)
	}
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, nothing



FindStructureAndAddMember : list<StructureDefinition> ref structures, integer structurename, integer structuretype, StructureMember ref member
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMember(structures.value.Members, structures.value.Members.next, member)
	}
	else
	{
		FindStructureAndAddMember(structures.next, structurename, structuretype, member)
	}
}

FindStructureAndAddMember : nothing, integer structurename, integer structuretype, StructureMember ref member
{
	list<StructureMember> members = member, nothing
	StructureDefinition def = structurename, structuretype, 0, 0, 0, members, false

	AppendStructure(Structures, Structures.next, def)
}

AppendStructure : list<StructureDefinition> ref structures, list<StructureDefinition> ref tail, StructureDefinition ref def
{
	AppendStructure(tail, tail.next, def)
}

AppendStructure : list<StructureDefinition> ref structures, nothing, StructureDefinition ref def
{
	list<StructureDefinition> newtail = def, nothing
	structures.next = newtail
}

AppendStructureMember : list<StructureMember> ref members, list<StructureMember> ref tail, StructureMember ref member
{
	AppendStructureMember(tail, tail.next, member)
}

AppendStructureMember : list<StructureMember> ref members, nothing, StructureMember ref member
{
	list<StructureMember> newtail = member, nothing
	members.next = newtail
}


FindStructureAndAddMemberParam : list<StructureDefinition> ref structures, integer structurename, integer structuretype, integer membername, Parameter ref param
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMemberParam(structures.value.Members, membername, param)
	}
	else
	{
		FindStructureAndAddMemberParam(structures.next, structurename, structuretype, membername, param)
	}
}

AppendStructureMemberParam : list<StructureMember> ref members, integer membername, Parameter ref param
{
	boolean match = CheckMemberForAddingParam(members.value, membername, param)
	if(!match)
	{
		AppendStructureMemberParam(members.next, membername, param)
	}
}

CheckMemberForAddingParam : StructureMemberVariable ref member, integer membername, Parameter ref param -> false

CheckMemberForAddingParam : StructureMemberFunctionRef ref member, integer membername, Parameter ref param -> boolean ret = false
{
	if(member.Name == membername)
	{
		AppendParameter(member.Signature.Parameters, param)
		ret = true
	}
}



OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname
{
	FindStructureAndSetConstructors(Structures, structurename, constructorname, anonname, copyname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, constructorname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, anonname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, copyname)
}

FindStructureAndSetConstructors : list<StructureDefinition> ref structures, integer structurename, integer constructorname, integer anonname, integer copyname
{
	if(structures.value.Name == structurename)
	{	
		structures.value.ConstructorName = constructorname
		structures.value.AnonConstructorName = anonname
		structures.value.CopyConstructorName = copyname
	}
	else
	{
		FindStructureAndSetConstructors(structures.next, structurename, constructorname, anonname, copyname)
	}
}

FindStructureAndSetConstructors : nothing, integer structurename, integer constructorname, integer anonname, integer copyname



OnCodeGenRegisterSumTypeBase : integer sumtypename, integer sumtypeid, integer basetypeid, boolean templated
{
	FindSumTypeAndAddBase(SumTypes, sumtypename, sumtypeid, basetypeid, templated)
}


FindSumTypeAndAddBase : list<SumType> ref sumtypes, integer sumtypename, integer sumtypeid, integer basetypeid, boolean templated
{
	if(sumtypes.value.Type == sumtypeid)
	{
		SumTypeBase base = basetypeid, nothing
		
		if(templated)
		{
			PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
			TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
			base.TemplateArgs = arglist
			
			PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
		}
		
		prepend<SumTypeBase>(sumtypes.value.Bases, base)
	}
	else
	{
		FindSumTypeAndAddBase(sumtypes.next, sumtypename, sumtypeid, basetypeid, templated)
	}
}

FindSumTypeAndAddBase : nothing, integer sumtypename, integer sumtypeid, integer basetypeid, boolean templated
{
	SumTypeBase base = basetypeid, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
		base.TemplateArgs = arglist
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}	
	
	list<SumTypeBase> bases = base, nothing
	SumType st = sumtypename, sumtypeid, bases, false
	prepend<SumType>(SumTypes, st)
}


SetUpSumTypeTemplate : list<SumType> ref sumtypes, integer sumtypeid
{
	if(sumtypes.value.Type == sumtypeid)
	{
		sumtypes.value.IsTemplate = true
		CreateSumTypeTemplateAndAttachParams(sumtypes.value.Name, TemplateParameterQueue)
		
		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
	else
	{
		SetUpSumTypeTemplate(sumtypes.next, sumtypeid)
	}
}

SetUpSumTypeTemplate : nothing, integer sumtypeid
{
	print("Sum type not found!")
	assert(false)
}


OnCodeGenRegisterScope : integer scopename, integer parentname
{
	list<Variable> v = dummyvar, nothing
	Scope scope = scopename, parentname, v, 0, 0
	prepend<Scope>(Scopes, scope)
}

OnCodeGenRegisterVariable : integer scopename, integer varname, integer vartype, integer origin
{
	StoreVariableInScope(Scopes, scopename, varname, vartype, false, origin)
}

StoreVariableInScope : list<Scope> ref scopes, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	if(scopes.value.Name == scopename)
	{
		integer size = 4		// TODO - actual variable sizes

		if((vartype & 0xff000000) == 0x07000000)		// Sum type family signature
		{
			size = 8
		}

		integer offset = -1
		if(origin == 1)			// VARIABLE_ORIGIN_PARAMETER
		{
			if(isref)
			{
				size = 8
			}

			offset = scopes.value.ParamOffset
			scopes.value.ParamOffset = scopes.value.ParamOffset + size
		}
		else
		{
			offset = scopes.value.LocalOffset
			scopes.value.LocalOffset = scopes.value.LocalOffset + size
		}

		Variable var = varname, vartype, origin, offset
		append(scopes.value.Variables, var)
	}
	else
	{
		StoreVariableInScope(scopes.next, scopename, varname, vartype, isref, origin)
	}
}

StoreVariableInScope : nothing, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	print("No scope available for identifier " ; GetPooledString(GlobalStrings, scopename))
	assert(false)
}


OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
}


RegisterOverloadForFunction : integer rawname -> integer mangledname = rawname
{
	integer existingcount = CountOverloads(Overloads, rawname)
	if(existingcount > 0)
	{
		mangledname = PoolString(GetPooledString(GlobalStrings, rawname) ; "@overload@" ; cast(string, existingcount))
	}
	
	Overload overload = rawname, mangledname
	prepend<Overload>(Overloads, overload)
}


CountOverloads : list<Overload> ref overloads, integer rawname -> integer count = 0
{
	if(rawname == overloads.value.NormalName)
	{
		++count
	}
	
	count += CountOverloads(overloads.next, rawname)
}

CountOverloads : nothing, integer rawname -> 0


OnCodeGenRegisterFunction : integer funcname, integer rawfuncname, boolean istemplate
{
	FunctionDefinition func = rawfuncname, funcname, istemplate, nothing, nothing, false, 0, nothing, false
	prepend<FunctionDefinition>(Functions, func)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack
	
	if(istemplate)
	{
		CreateFunctionTemplateAndAttachParams(funcname, TemplateParameterQueue)
		
		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
}

IRRegisterFunctionParam : integer paramname, integer paramtypename, boolean isref, boolean templated
{
	UnresolvedParameter p = paramname, paramtypename, 0, isref, nothing, nothing
	
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
		p.TemplateArgs = arglist
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}
	
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, FunctionParams ref params, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(params.Params, params.Params.next, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	OptionalParameters params = newlist
	func.Params = params
}


AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, list<UnresolvedParameter> ref tail, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(tail, tail.next, p)
}

AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	thelist.next = newlist
}


OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyexpression
	ScratchExpressions.value = d

	Functions.value.AnonymousReturn = anonymous
	InFuncRetHack = true
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	PopContext(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToSubStatement(ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToSubStatement(ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
		InFuncRetHack = false
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		assert(CodeBlockDepth(CurrentCodeBlockStack) == 1)
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		AppendEntityToChain(ChainStack, entity)
		PopEntityStack(EntityStack, EntityStack.next)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		EntityChain chain = ChainStack.value
		CodeBlockEntry cbe = chain
		AppendEntryToCurrentCodeBlock(cbe)
		PopChain(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		Expression expr = ScratchExpressions.value
		ExpressionOrPrePostOp epp = expr
		ParentheticalExpression parenthetical = epp
		ExpressionAtom atom = parenthetical
		PopExpression(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}

PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	print("No contexts available")
	assert(false)
}

PopExpression : list<Expression> ref thelist, list<Expression> ref next
{
	thelist = next
}

PopExpression : list<Expression> ref thelist, nothing



PopCodeBlock : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref next
{
	stack = next
}

PopCodeBlock : list<OptionalCodeBlock> ref stack, nothing
{
	list<OptionalCodeBlock> newlist = nothing, nothing
	stack = newlist
}


PopEntityStack : list<Entity> ref stack, list<Entity> ref next
{
	stack = next
}

PopEntityStack : list<Entity> ref stack, nothing


PopChain : list<EntityChain> ref stack, list<EntityChain> ref next
{
	stack = next
}

PopChain : list<EntityChain> ref stack, nothing



PopCurrentStatementAndAppendToScratchExpression : list<Expression> ref expressions, list<Expression> ref tail
{
	Statement stmt = SubStatements.value
	ExpressionAtom atom = stmt

	expressions = tail

	PlaceAtomInScratchExpression(atom)
	PopSubStatement(SubStatements, SubStatements.next)
}

SetReturnExpression : FunctionDefinition ref funcdef, Expression ref expr
{
	funcdef.Return = expr

	Expression d = dummyexpression
	ScratchExpressions.value = d
}

SetGlobalCodeBlock : CodeBlock ref block
{
	GlobalCodeBlock = block
}

SetGlobalCodeBlock : nothing


PopSubStatement : list<Statement> ref statements, list<Statement> ref tail
{
	statements = tail
}



AppendExpressionToSubStatement : Expression ref expr
{
	AppendExpressionToStatement(SubStatements.value, expr)
}


OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	list<FunctionSignature> dsl = dummysignature, nothing
	TypeMatcher matcher = matchername, dsl
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


PlaceAtomInScratchExpression : ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(ScratchExpressions.value.Atoms.value))
	{
		list<ExpressionAtom> atoms = atom, nothing
		ScratchExpressions.value = Expression(atoms, 0)
	}
	else
	{
		AppendAtomToExpression(ScratchExpressions.value.Atoms, ScratchExpressions.value.Atoms.next, atom)
	}
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0xff000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(TypeAliases, literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifierReference : integer idhandle
{
	IdentifierAtom id = idhandle, 0, true
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterTypeAnnotation : integer annotationtype
{
	TypeAnnotationAtom taa = annotationtype
	ExpressionAtom atom = taa
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}


ExpressionAtomIsSentinel : AtomSentinel 	   ref sentinel    -> true
ExpressionAtomIsSentinel : StringHandleAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : IdentifierAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : OperatorInvokeAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : TypeAnnotationAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : integer 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : integer16 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : boolean 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : real 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : Statement		   ref nonsentinel -> false
ExpressionAtomIsSentinel : RefBinding              ref nonsentinel -> false
ExpressionAtomIsSentinel : CompoundAtom            ref nonsentinel -> false
ExpressionAtomIsSentinel : ParentheticalExpression ref nonsentinel -> false



AppendAtomToExpression : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, ExpressionAtom ref atom
{
	AppendAtomToExpression(tail, tail.next, atom)
}

AppendAtomToExpression : list<ExpressionAtom> ref atoms, nothing, ExpressionAtom ref atom
{
	list<ExpressionAtom> newatoms = atom, nothing
	atoms.next = newatoms
}


OnCodeGenEnterStatement : integer statementname, integer statementtype, boolean toplevel, boolean hastemplateargs
{
	Statement statement = statementname, nothing, statementtype, toplevel, nothing
	
	if(hastemplateargs)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
		statement.TemplateArgs = arglist
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}
	
	OnCodeGenEmplaceStatement(statement)
}

OnCodeGenEmplaceStatement : Statement ref statement
{
	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statement.Name
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}

OnCodeGenEnterAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpressions.value = Expression(dummyatomlist, 0)
}


OnCodeGenChainAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}


OnCodeGenEnterAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundMember : integer membername
{
	FindCurrentFunctionAndAppendCompoundMember(membername)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpressions.value = Expression(dummyatomlist, 0)
}



OnCodeGenChainAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}

OnCodeGenChainAssignmentCompoundMember : integer membername
{
	FindCurrentFunctionAndChainCompoundMember(membername)
}

OnCodeGenChainAssignmentCompoundEnd :
{
}


OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}



AppendEntryToCurrentAssignmentChain : Assignment ref a
{
	AppendEntryToCurrentAssignmentChainWorker(CurrentCodeBlockStack, a)
}

AppendEntryToCurrentAssignmentChain : AssignmentCompound ref a
{
	AppendEntryToCurrentAssignmentChainWorker(CurrentCodeBlockStack, a)
}

AppendEntryToCurrentAssignmentChainWorker : list<OptionalCodeBlock> ref blockstack, Assignment ref a
{
	AppendEntryToAssignmentChain(blockstack, blockstack.next, a)
}

AppendEntryToCurrentAssignmentChainWorker : list<OptionalCodeBlock> ref blockstack, AssignmentCompound ref a
{
	AppendEntryToAssignmentChain(blockstack, blockstack.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref tail, Assignment ref a
{
	AppendEntryToAssignmentChain(tail, tail.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, nothing, Assignment ref a
{
	GetTailAssignmentAndChain(stack.value, a)
}


AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref tail, AssignmentCompound ref a
{
	AppendEntryToAssignmentChain(tail, tail.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, nothing, AssignmentCompound ref a
{
	GetTailAssignmentAndChain(stack.value, a)
}


GetTailAssignmentAndChain : CodeBlock ref codeblock, Assignment ref a
{
	FindTailAssignmentAndChain(codeblock.Entries, codeblock.Entries.next, a)
}

GetTailAssignmentAndChain : CodeBlock ref codeblock, AssignmentCompound ref a
{
	FindTailAssignmentAndChain(codeblock.Entries, codeblock.Entries.next, a)
}


FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, Assignment ref a
{
	FindTailAssignmentAndChain(tail, tail.next, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, nothing, Assignment ref a
{
	ChainAssignment(entries.value, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, AssignmentCompound ref a
{
	FindTailAssignmentAndChain(tail, tail.next, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, nothing, AssignmentCompound ref a
{
	ChainAssignment(entries.value, a)
}

ChainAssignment : Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

ChainAssignment : AssignmentCompound ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}


ChainAssignment : Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

ChainAssignment : AssignmentCompound ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}


AddAssignmentToChain : Assignment ref tomodify, Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : Assignment ref tomodify, Expression ref expr, Assignment ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Expression ref expr, Assignment ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : Assignment ref tomodify, Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : Assignment ref tomodify, Expression ref expr, AssignmentCompound ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Expression ref expr, AssignmentCompound ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}


AppendEntryToCurrentCodeBlock : CodeBlockEntry ref cbe
{
	AppendEntryToCurrentCodeBlockWorker(CurrentCodeBlockStack, cbe)
}

AppendEntryToCurrentCodeBlockWorker : list<OptionalCodeBlock> ref blockstack, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(blockstack, blockstack.value, entry)
}

AppendEntryToCurrentCodeBlockWorker : nothing, CodeBlockEntry ref entry
{
	print("No code block is being processed")
	assert(false)
}


FindCurrentFunctionAndAppendCompoundMember : integer membername
{
	FindLastAssignmentAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}

FindCurrentFunctionAndChainCompoundMember : integer membername
{
	FindLastAssignmentAndChainCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}


FindLastAssignmentAndAppendCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(code.Entries, code.Entries.next, membername)
}

FindLastAssignmentAndChainCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndChainCompoundMember(code.Entries, code.Entries.next, membername)
}



AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, CodeBlock ref code, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(code.Entries, entry)
}

AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> stmtlist = entry, nothing
	CodeBlock block = stmtlist
	OptionalCodeBlock blockwrap = block
	stack.value = blockwrap
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(entries, entries.next, entry)
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> newlist = entry, nothing
	entries.next = newlist
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, CodeBlockEntry ref value
{
	AppendEntryToCodeBlock(tail, tail.next, value)
}


FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}


FindLastAssignmentAndChainCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndChainCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndChainCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	ChainCompoundMemberHelper(entries.value, membername)
}


ChainCompoundMemberHelper : Assignment ref a, integer membername
{
	ChainCompoundMember(a, a.RHS, membername)
}

ChainCompoundMemberHelper : AssignmentCompound ref a, integer membername
{
	ChainCompoundMember(a, a.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, Assignment ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : AssignmentCompound ref tomodify, Assignment ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, AssignmentCompound ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : AssignmentCompound ref tomodify, AssignmentCompound ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, Expression ref rhs, integer membername
{
	print("Fatal error - parser tried to associate a member with a non-compound assignment")
	assert(false)
}

ChainCompoundMember : AssignmentCompound ref tomodify, Expression ref rhs, integer membername
{
	AppendCompoundMemberHelper(tomodify, membername)
}


AppendCompoundMemberHelper : AssignmentCompound ref a, integer membername
{
	AppendCompoundMember(a.LHS, a.LHS.next, membername)
}

AppendCompoundMemberHelper : PreOpStatement ref s, integer membername
{
	AppendCompoundMember(s.Operand, s.Operand.next, membername)
}

AppendCompoundMemberHelper : PostOpStatement ref s, integer membername
{
	AppendCompoundMember(s.Operand, s.Operand.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, simplelist<integer> ref tail, integer membername
{
	AppendCompoundMember(tail, tail.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, nothing, integer membername
{
	simplelist<integer> newtail = membername, nothing
	members.next = newtail
}



FindCurrentStatementAndAppendExpression : Expression ref expression
{
	FindLastStatementInBlockAndAppendExpression(CurrentCodeBlockStack.value, expression)
}

FindCurrentStatementAndAppendExpression : nothing


FindCurrentAssignmentAndSetExpression : Expression ref expression
{
	FindLastAssignmentInBlockAndSetExpression(CurrentCodeBlockStack.value, expression)
}



FindLastStatementInBlockAndAppendExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastStatementAndAppendExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastStatementInBlockAndAppendExpression : nothing, Expression ref expression
{
	print("Not processing an active code block!")
	assert(false)
}


FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastStatementAndAppendExpression(tail, tail.next, expression)
}

FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	AppendExpressionToStatement(codeblockentries.value, expression)
}


AppendExpressionToStatement : Statement ref statement, Expression ref expression
{
	AppendExpressionToStatementParams(statement, statement.Parameters, expression)
}

AppendExpressionToStatementParams : Statement ref statement, ExpressionList ref parameters, Expression ref expression
{
	AppendExpression(parameters.Expressions, parameters.Expressions.next, expression)
}

AppendExpressionToStatementParams : Statement ref statement, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	ExpressionList params = newlist
	statement.Parameters = params
}

AppendExpression : list<Expression> ref expressions, list<Expression> ref tail, Expression ref expression
{
	AppendExpression(tail, tail.next, expression)
}

AppendExpression : list<Expression> ref expressions, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	expressions.next = newlist
}


FindLastAssignmentInBlockAndSetExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastAssignmentAndSetExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastAssignmentAndSetExpression(tail, tail.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	SetAssignmentExpression(codeblockentries.value, expression)
}

SetAssignmentExpression : Assignment ref assignment, Expression ref expression
{
	FollowChainAndSetExpression(assignment, assignment.RHS, expression)
}

SetAssignmentExpression : AssignmentCompound ref assignment, Expression ref expression
{
	FollowChainAndSetExpression(assignment, assignment.RHS, expression)
}


FollowChainAndSetExpression : Assignment ref assignment, Assignment ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : Assignment ref assignment, AssignmentCompound ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : AssignmentCompound ref assignment, Assignment ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : AssignmentCompound ref assignment, AssignmentCompound ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : Assignment ref tomodify, Expression ref rhs, Expression ref newrhs
{
	ExpressionOrAssignment wrap = newrhs
	tomodify.RHS = wrap
}

FollowChainAndSetExpression : AssignmentCompound ref tomodify, Expression ref rhs, Expression ref newrhs
{
	ExpressionOrAssignment wrap = newrhs
	tomodify.RHS = wrap
}



SetFunctionCodeBlock : FunctionDefinition ref funcdef, OptionalCodeBlock ref optblock
{
	SetFunctionCodeBlockWorker(funcdef, optblock)
}

SetFunctionCodeBlock : nothing, OptionalCodeBlock ref optblock
{
	print("No function in flight")
	assert(false)
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, CodeBlock ref block
{
	funcdef.Code = block
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, nothing



CodeGenEmitStrings : list<StringTableEntry> ref table
{
	map<StringTableEntry>(table, CodeGenEmitSingleString)
}

CodeGenEmitSingleString : StringTableEntry entry			// TODO - this should be passed by ref
{
	if(entry.Handle != 0)
	{
		OnBytecodePoolString(entry.Handle, entry.Data)
	}
}


CodeGenEmitStructures : list<StructureDefinition> ref structures
{
	CodeGenEmitStructures(structures.next)
	CodeGenEmitSingleStructure(structures.value)
}

CodeGenEmitStructures : nothing


CodeGenEmitSingleStructure : StructureDefinition ref def
{
	if((def.Name != 0) && (!def.IsTemplate))
	{
		integer membercount = CountMembers(def.Members)
		OnBytecodeDefineStructure(def.Type, membercount)
		CodeGenEmitMembers(def.Members)
	}
}

CodeGenEmitMembers : list<StructureMember> ref members
{
	CodeGenEmitMember(members.value)
	CodeGenEmitMembers(members.next)
}

CodeGenEmitMembers : nothing

CodeGenEmitMember : StructureMemberVariable ref memvar
{
	OnBytecodeStructureMember(memvar.Name, memvar.Type)
}

CodeGenEmitMember : StructureMemberFunctionRef ref member
{
	OnBytecodeStructureMember(member.Name, GetMemberTypeDecompose(member))
}


CountMembers : list<StructureMember> ref members -> integer count = 0
{
	CountMembers(members, count)
}

CountMembers : list<StructureMember> ref members, integer ref count
{
	++count
	CountMembers(members.next, count)
}

CountMembers : nothing, integer ref count





CodeGenEmitScopes : list<Scope> ref scopes
{
	CodeGenEmitScopes(scopes.next)
	CodeGenEmitSingleScope(scopes.value, scopes.value.Name)
}

CodeGenEmitScopes : nothing


CodeGenEmitSingleScope : Scope ref scope, integer funcname
{
	if((scope.Name != 0) && (scope.Name != GlobalCodeBlockName))
	{
		integer parentname = scope.ParentName
		if((parentname == 0) && (scope.Name != GlobalCodeBlockName))
		{
			parentname = GlobalCodeBlockName
		}
		
		integer varcount = CountScopeVariables(scope)
		OnBytecodeLexicalScope(scope.Name, parentname, varcount)
		CodeGenEmitVariables(scope.Variables, funcname)
	}
}


CodeGenEmitSpecificScope : list<Scope> ref scopes, integer scopename
{
	if(scopes.value.Name == scopename)
	{
		integer varcount = CountScopeVariables(scopes.value)
		OnBytecodeLexicalScope(scopes.value.Name, 0, varcount)
		CodeGenEmitVariables(scopes.value.Variables, 0)
	}
	else
	{
		CodeGenEmitSpecificScope(scopes.next, scopename)
	}
}


CountScopeVariables : Scope ref scope -> integer count = 0
{
	CountScopeVariables(scope.Variables, count)
}

CountScopeVariables : list<Variable> ref variables, integer ref count
{
	if(variables.value.Name != 0)
	{
		++count
	}

	CountScopeVariables(variables.next, count)
}

CountScopeVariables : nothing, integer ref count


CodeGenEmitVariables : list<Variable> ref vars, integer funcname
{
	CodeGenEmitSingleVariable(vars.value, funcname)
	CodeGenEmitVariables(vars.next, funcname)
}

CodeGenEmitVariables : nothing, integer funcname


CodeGenEmitSingleVariable : Variable ref var, integer funcname
{
	if(var.Name != 0)
	{
		integer basetype = var.VarType
		while((basetype & 0x7f000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(TypeAliases, basetype)
		}


		if((var.Origin == 2) && (listcontains(CustomConstructors, funcname)))
		{
			OnBytecodeLexicalScopeEntry(var.Name, basetype, 0)
		}
		else
		{
			OnBytecodeLexicalScopeEntry(var.Name, basetype, var.Origin)
		}
	}
}


CodeGenEmitFunctions : list<FunctionDefinition> ref table
{
	if(!table.value.IsTemplate)
	{
		CodeGenEmitSingleFunction(table.value)
	}
	
	CodeGenEmitFunctions(table.next)
}

CodeGenEmitFunctions : nothing


CodeGenEmitSingleFunction : FunctionDefinition ref def
{
	if(def.Name != 0)
	{
		EmittingFunctionName = def.Name
		OnBytecodeEnterFunction(def.Name)
		CodeGenEmitFunctionReturn(def.Return)

		if(def.InvokeTag != 0)
		{
			OnBytecodeInvoke(def.InvokeTag)
		}

		CodeGenEmitCodeBlock(def.Code)
		if(listcontains(CustomConstructors, def.Name))
		{
			OnBytecodePushVarNoCopy(FindReturnVariableName())
			OnBytecodeBindReference(0, 0)			// TODO - kind of a hack
			OnBytecodeAssign()
		}
		else
		{
			if(def.AnonymousReturn)
			{
				CodeGenEmitReturnRegisterAnonymous(def.Return)
			}
			else
			{
				CodeGenEmitReturnRegister(def.Return)
			}
		}
		OnBytecodeExitFunction()
	}
}

CodeGenEmitFunctionReturn : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitFunctionReturn : nothing


CodeGenEmitReturnRegister : Expression ref expr
{
	integer index = FindReturnVariableIndex()
	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegister : nothing


CodeGenEmitReturnRegisterAnonymous : Expression ref expr
{
	integer index = FindReturnVariableIndex()

	OnBytecodeBindReference(0, index)
	OnBytecodeAssign()

	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegisterAnonymous : nothing



CodeGenEmitCodeBlock : CodeBlock ref block
{
	CodeGenEmitCodeBlockEntries(block.Entries)
}

CodeGenEmitCodeBlock : nothing


CodeGenEmitCodeBlockEntries : list<CodeBlockEntry> ref entries
{
	CodeGenEmitSingleCodeBlockEntry(entries.value)
	CodeGenEmitCodeBlockEntries(entries.next)
}

CodeGenEmitCodeBlockEntries : nothing


CodeGenEmitSingleCodeBlockEntry : Statement ref s
{
	boolean sumtype = SumTypeExists(s.Name)
	boolean constructssumtype = false
	if((s.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtype = true
	}

	boolean constructorcall = StructureConstructorExists(Structures, s.Name)

	CodeGenEmitExpressionList(s.Parameters, constructssumtype, constructorcall)

	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(EmittingFunctionName, s.Name, var)
	if((var.Name != 0) && ((var.VarType & 0xff000000) == 0x09000000))
	{
		OnBytecodeInvokeIndirect(s.Name)
	}
	elseif(sumtype)
	{
		OnBytecodeConstructSumType()
	}
	elseif(FunctionIsAutoGenOrHasIR(s.Name))
	{
		OnBytecodeInvokeOffset(s.Name)
	}
	else
	{
		OnBytecodeInvoke(s.Name)
	}
}

CodeGenEmitAssignmentRHS : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitAssignmentRHS : Assignment ref a
{
	CodeGenEmitAssignmentRHS(a.RHS)
		
	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
	
	CodeGenEmitBindingsForVariable(a.LHSName)
	OnBytecodeReadReference()
}

CodeGenEmitSingleCodeBlockEntry : Assignment ref a
{
	boolean sideeffects = false
	
	string op = substring(GetPooledString(GlobalStrings, a.Operator), 0, 1)
	if(op != "=")			// TODO - Pathetic hack
	{
		sideeffects = true
		CodeGenEmitBindingsForVariable(a.LHSName)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)
	
	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}

CodeGenEmitSingleCodeBlockEntry : AssignmentCompound ref a
{
	boolean sideeffects = false
	if(GetPooledString(GlobalStrings, a.Operator) != "=")
	{
		sideeffects = true
		CodeGenEmitBindingsForOperand(a.LHS)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)
	
	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHS.value, frames)
	OnBytecodeBindReference(frames, index)

	integer typeid = MakeNonReferenceType(FindVariableType(a.LHS.value))

	integer structurename = GetNameOfStructureByType(typeid)
	BindAssignmentMembers(a.LHS.next, structurename)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()	
	}
	else
	{
		OnBytecodeAssign()
	}
}


CodeGenEmitBindingsForOperand : simplelist<integer> ref operand
{
	integer frames = 0
	integer index = FindVariable(operand.value, frames)
	OnBytecodeBindReference(frames, index)

	integer structurename = GetNameOfStructureByType(FindVariableType(operand.value))
	BindAssignmentMembers(operand.next, structurename)
}

CodeGenEmitBindingsForVariable : integer operand
{
	integer frames = 0
	integer index = FindVariable(operand, frames)
	OnBytecodeBindReference(frames, index)	
}


CodeGenEmitSingleCodeBlockEntry : PreOpStatement ref preop
{
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(preop.Operator)
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeAssign()
	// TODO - push extra copy of value LAST if in a parenthetical
}

CodeGenEmitSingleCodeBlockEntry : PostOpStatement ref postop
{
	// TODO - push extra copy of value FIRST if in a parenthetical
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(postop.Operator)
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeAssign()
}



CodeGenEmitSingleCodeBlockEntry : EntityChain ref chain
{
	OnBytecodeBeginChain()
	CodeGenEmitEntityChain(chain.Entries)
	OnBytecodeEndChain()
}


CodeGenEmitEntityChain : EntityList ref entities
{
	CodeGenEmitEntityList(entities.ActualList)
}

CodeGenEmitEntityList : list<Entity> ref thelist
{
	if(thelist.value.Tag != 0)
	{
		CodeGenEmitExpression(thelist.value.Param, false, false)
		OnBytecodeEnterEntity(thelist.value.Tag, 0)
		CodeGenEmitCodeBlock(thelist.value.Code)
		OnBytecodeExitEntity()
	}

	CodeGenEmitEntityList(thelist.next)
}

CodeGenEmitEntityList : nothing


BindAssignmentMembers : simplelist<integer> ref lhsmembers, integer structurename
{
	integer membertype = GetStructureMemberType(Structures, structurename, lhsmembers.value)
	integer memberoffset = GetStructureMemberOffset(Structures, structurename, lhsmembers.value)

	OnBytecodeBindStructReference(membertype, memberoffset)

	// Recurse
	BindAssignmentMembers(lhsmembers.next, GetNameOfType(membertype))
}

BindAssignmentMembers : nothing, integer structurename


ComputeCompoundAssignmentLHSType : AssignmentCompound ref assignment, integer scopename -> integer typeid = 0
{
	integer rootname = assignment.LHS.value
	
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(scopename, rootname, var)
	
	integer vartypename = GetNameOfType(var.VarType)
	typeid = ComputeCompoundAssignmentLHSTypeMembers(assignment.LHS.next, vartypename)
}

ComputeCompoundAssignmentLHSTypeMembers : simplelist<integer> ref lhsmembers, integer structurename -> integer typeid = 0
{
	integer membertype = GetStructureMemberType(Structures, structurename, lhsmembers.value)
	typeid = ComputeCompoundAssignmentLHSTypeMembers(lhsmembers.next, GetNameOfType(membertype))
}

ComputeCompoundAssignmentLHSTypeMembers : nothing, integer structurename -> integer typeid = GetTypeByName(structurename)




CodeGenEmitExpressionList : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpressionList : ExpressionList ref expressions, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionList(expressions.Expressions, constructssumtype, constructorcall)
}

CodeGenEmitExpressionList : list<Expression> ref expressions, boolean constructssumtype, boolean constructorcall
{
	boolean constructssumtypetemp = constructssumtype
	if((expressions.value.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtypetemp = true
	}

	CodeGenEmitExpressionAtoms(expressions.value.Atoms, constructssumtypetemp, constructorcall)
	CodeGenEmitExpressionList(expressions.next, constructssumtype, constructorcall)
}

CodeGenEmitExpression : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpression : Expression ref expr, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionAtoms(expr.Atoms, constructssumtype, constructorcall)
}

CodeGenEmitExpressionAtoms : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean constructorcall
{
	boolean needsref = false
	CodeGenEmitExpressionAtomsWorker(atoms, constructssumtype, needsref, constructorcall)
	if(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

CodeGenEmitExpressionAtomsWorker : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean ref needsref, boolean constructorcall
{
	boolean thisneedsref = CodeGenCheckAtomForReadRef(atoms.value)
	if(thisneedsref)
	{
		needsref = true
	}
	elseif(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
		needsref = false
	}

	CodeGenEmitSingleAtom(atoms.value, constructorcall)
	CodeGenEmitExpressionAtomsWorker(atoms.next, constructssumtype, needsref, constructorcall)
}

CodeGenEmitExpressionAtomsWorker : nothing, boolean constructssumtype, boolean ref needsref, boolean constructorcall


CodeGenCheckAtomForReadRef : RefBinding ref atom -> !atom.IsReference
CodeGenCheckAtomForReadRef : CompoundAtom ref atom -> false

CodeGenCheckAtomForReadRef : integer ref atom -> false
CodeGenCheckAtomForReadRef : integer16 ref atom -> false
CodeGenCheckAtomForReadRef : boolean ref atom -> false
CodeGenCheckAtomForReadRef : real ref atom -> false
CodeGenCheckAtomForReadRef : IdentifierAtom ref atom -> false
CodeGenCheckAtomForReadRef : StringHandleAtom ref atom -> false
CodeGenCheckAtomForReadRef : OperatorInvokeAtom ref atom -> false
CodeGenCheckAtomForReadRef : TypeAnnotationAtom ref atom -> false
CodeGenCheckAtomForReadRef : Statement ref atom -> false
CodeGenCheckAtomForReadRef : ParentheticalExpression ref atom -> false
CodeGenCheckAtomForReadRef : AtomSentinel ref atom -> false




CodeGenEmitSingleAtom : integer ref literalinteger, boolean constructor
{
	OnBytecodePushLiteralInteger(literalinteger)
}

CodeGenEmitSingleAtom : integer16 ref literalinteger16, boolean constructor
{
	OnBytecodePushLiteralInteger16(literalinteger16)
}

CodeGenEmitSingleAtom : boolean ref literalboolean, boolean constructor
{
	OnBytecodePushBoolean(literalboolean)
}

CodeGenEmitSingleAtom : real ref literalreal, boolean constructor
{
	OnBytecodePushLiteralReal(literalreal)
}

CodeGenEmitSingleAtom : StringHandleAtom ref atom, boolean constructor
{
	OnBytecodePushLiteralString(atom.Handle)
}

CodeGenEmitSingleAtom : OperatorInvokeAtom ref atom, boolean constructor
{
	OnBytecodeInvoke(atom.OperatorName)
}

CodeGenEmitSingleAtom : IdentifierAtom ref idatom, boolean constructor
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		OnBytecodePushLiteralInteger(0)
	}
	else
	{
		if(FunctionIsAutoGenOrHasIR(idatom.Handle))
		{
			OnBytecodePushLiteralFunction(idatom.Handle)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			OnBytecodePushLiteralString(idatom.Handle)
		}	
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if((!constructor) && (!idatom.IsReference))
				{
					OnBytecodePushLiteralString(idatom.Handle)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				OnBytecodePushLiteralFunction(idatom.Handle)
			}
			else
			{
				if(idatom.IsReference)
				{	
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)

					if(frames == 0)
					{
						OnBytecodePushVarValue(idatom.Handle, idatom.Type)
					}
					else
					{
						Variable var = 0, 0, 0, 0
						FindVariableDataInScope(EmittingFunctionName, idatom.Handle, var)
						
						if(var.Name == 0)
						{
							print("Code generation error - missing local variable " ; GetPooledString(GlobalStrings, idatom.Handle) ; " in scope " ; GetPooledString(GlobalStrings, EmittingFunctionName))
							assert(false)
						}
						OnBytecodePushLocal(false, frames, var.Offset, 0)
					}
				}
			}
		}
	}
}

CodeGenEmitSingleAtom : TypeAnnotationAtom ref atom, boolean constructor
{
	OnBytecodePushTypeAnnotation(MakeNonReferenceType(atom.Type))
}

CodeGenEmitSingleAtom : Statement ref atom, boolean constructor
{
	CodeGenEmitSingleCodeBlockEntry(atom)
}

CodeGenEmitSingleAtom : RefBinding ref atom, boolean constructor
{
	integer memtype = GetStructureMemberType(Structures, atom.StructureName, atom.Identifier)
	integer memoffset = GetStructureMemberOffset(Structures, atom.StructureName, atom.Identifier)
	OnBytecodeBindStructReference(memtype, memoffset)
}

CodeGenEmitSingleAtom : ParentheticalExpression ref expr, boolean constructor
{
	CodeGenEmitExpression(expr.Inner, false, false)
}

CodeGenEmitSingleAtom : CompoundAtom ref atom, boolean constructor
{
	integer frames = 0
	integer index = FindVariable(atom.Bindings.value.Identifier, frames)
	OnBytecodeBindReference(frames, index)
	
	EmitCompoundBindings(atom.Bindings, atom.Bindings.next)
	
	if(!IsReferenceType(atom.Type))
	{
		if((atom.Type & 0x7f000000) == 0x07000000)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

EmitCompoundBindings : list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(EmittingFunctionName, bindings.value.Identifier, var)
	
	integer lhstypename = GetNameOfType(var.VarType)

	integer memtype = GetStructureMemberType(Structures, lhstypename, tail.value.Identifier)
	integer memoffset = GetStructureMemberOffset(Structures, lhstypename, tail.value.Identifier)
	OnBytecodeBindStructReference(memtype, memoffset)

	EmitCompoundSubsequentBindings(tail.next)
}

EmitCompoundSubsequentBindings : nothing

EmitCompoundSubsequentBindings : list<RefBinding> ref bindings
{
	CodeGenEmitSingleAtom(bindings.value, false)
	EmitCompoundSubsequentBindings(bindings.next)
}


CodeGenEmitSingleAtom : AtomSentinel ref sentinel, boolean constructor


GetNameOfStructureByType : integer typeid -> integer name = 0
{
	name = GetNameOfStructureByType(Structures, typeid)
}

GetNameOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.Name
	}
	else
	{
		name = GetNameOfStructureByType(structures.next, typeid)
	}
}

GetNameOfStructureByType : nothing, integer typeid -> integer name = 0



GetSizeOfStructureByType : integer typeid -> integer size = 0
{
	size = GetSizeOfStructureByType(Structures, typeid)
}

GetSizeOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer size = 0
{
	if(structures.value.Type == typeid)
	{
		size = GetTotalMemberSize(structures.value.Members)
	}
	else
	{
		size = GetSizeOfStructureByType(structures.next, typeid)
	}
}

GetSizeOfStructureByType : nothing, integer typeid -> integer name = 0


GetTotalMemberSize : list<StructureMember> ref members -> integer size = 0
{
	size = GetMemberSize(members.value) + GetTotalMemberSize(members.next)
}

GetTotalMemberSize : nothing -> integer size = 0



GetStructureMemberType : list<StructureDefinition> ref structures, integer structurename, integer membername -> integer rtype = 0
{
	if(structures.value.Name == structurename)
	{
		rtype = GetMemberType(structures.value.Members, membername)
	}
	else
	{
		rtype = GetStructureMemberType(structures.next, structurename, membername)
	}
}

GetStructureMemberType : nothing, integer structurename, integer membername -> integer rtype = 0

GetMemberType : list<StructureMember> ref members, integer membername -> integer rtype = 0
{
	if(GetMemberName(members.value) == membername)
	{
		rtype = GetMemberTypeDecompose(members.value)
	}
	else
	{
		rtype = GetMemberType(members.next, membername)
	}
}

GetMemberType : nothing, integer membername -> integer rtype = 0

GetMemberTypeDecompose : StructureMemberVariable ref memvar -> integer rtype = memvar.Type

GetMemberTypeDecompose : StructureMemberFunctionRef ref member -> integer rtype = FindOrCreateFunctionSignatureType(member.Signature)


GetMemberName : StructureMemberVariable ref memvar -> integer name = memvar.Name

GetMemberName : StructureMemberFunctionRef ref member -> integer name = member.Name


GetMemberOffset : list<StructureMember> ref members, integer membername -> integer offset = 0
{
	integer counter = 0
	GetMemberOffset(members, membername, counter)
	offset = counter
}

GetMemberOffset : list<StructureMember> ref members, integer membername, integer ref counter
{
	if(GetMemberName(members.value) != membername)
	{
		if(GetMemberName(members.value) != 0)
		{
			counter += GetMemberSize(members.value)
		}
		GetMemberOffset(members.next, membername, counter)
	}
}

GetMemberOffset : nothing, integer membername, integer ref counter

GetMemberSize : StructureMemberVariable ref memvar -> integer r = GetTypeSize(memvar.Type)

GetMemberSize : StructureMemberFunctionRef ref member -> 4



GetStructureMemberOffset : list<StructureDefinition> ref structures, integer structurename, integer membername -> integer offset = 0
{
	if(structures.value.Name == structurename)
	{
		offset = GetMemberOffset(structures.value.Members, membername)
	}
	else
	{
		offset = GetStructureMemberOffset(structures.next, structurename, membername)
	}
}

GetStructureMemberOffset : nothing, integer structurename, integer membername -> 0



CodeGenEmitSumTypes : list<SumType> ref sumtypes
{
	CodeGenEmitSingleSumType(sumtypes.value)
	CodeGenEmitSumTypes(sumtypes.next)
}

CodeGenEmitSumTypes : nothing


CodeGenEmitSingleSumType : SumType ref sumtype
{
	if((sumtype.Type != 0) && (!sumtype.IsTemplate))
	{
		OnBytecodeEmitByte(0x1f)			// SumTypeDef instruction
		OnBytecodeEmitInteger(sumtype.Type)
		OnBytecodeEmitInteger(CountSumTypeBases(sumtype.Bases))
		CodeGenEmitSumTypeBase(sumtype.Bases)
	}
}

CountSumTypeBases : list<SumTypeBase> ref bases -> integer count = 0
{
	count = CountSumTypeBases(bases.next)

	if(bases.value.Name != 0)
	{
		++count
	}
}

CountSumTypeBases : nothing -> integer count = 0

CodeGenEmitSumTypeBase : list<SumTypeBase> ref bases
{
	CodeGenEmitSumTypeBase(bases.next)

	if(bases.value.Name != 0)
	{
		OnBytecodeEmitInteger(bases.value.Name)
	}
}

CodeGenEmitSumTypeBase : nothing


SumTypeExists : integer typename -> boolean exists = SumTypeExists(SumTypes, typename)

SumTypeExists : list<SumType> ref sumtypes, integer typename -> boolean exists = false
{
	if(sumtypes.value.Name == typename)
	{
		exists = true
	}
	else
	{
		exists = SumTypeExists(sumtypes.next, typename)
	}
}

SumTypeExists : nothing, integer typename -> boolean exists = false


FindSumTypeName : integer typeid -> integer name = FindSumTypeName(SumTypes, typeid)

FindSumTypeName : list<SumType> ref sumtypes, integer typeid -> integer name = 0
{
	if(sumtypes.value.Type == typeid)
	{
		name = sumtypes.value.Name
	}
	else
	{
		name = FindSumTypeName(sumtypes.next, typeid)
	}
}

FindSumTypeName : nothing, integer typeid -> 0


SumTypeHasBase : list<SumType> ref sumtypes, integer sumtypeid, integer basetypeid -> boolean hasbase = false
{
	if(basetypeid == 0)
	{
		return()
	}
	
	if(sumtypeid == 0)
	{
		return()
	}

	if(sumtypes.value.Type == sumtypeid)
	{
		hasbase = CheckBaseTypes(sumtypes.value.Bases, basetypeid)
	}
	else
	{
		hasbase = SumTypeHasBase(sumtypes.next, sumtypeid, basetypeid)
	}
}

SumTypeHasBase : nothing, integer sumtypeid, integer basetypeid -> false


CheckBaseTypes : list<SumTypeBase> ref bases, integer basetypeid -> boolean hasbase = false
{
	if(bases.value.Name == basetypeid)
	{
		hasbase = true
	}
	else
	{
		hasbase = CheckBaseTypes(bases.next, basetypeid)
	}
}

CheckBaseTypes : nothing, integer basetypeid -> false




FunctionIsAutoGenOrHasIR : integer funcname -> boolean ret = false
{
	if(FunctionExists(Functions, funcname))
	{
		ret = true
	}
	elseif(TypeMatcherExists(TypeMatchers, funcname))
	{
		ret = true
	}
	elseif(PatternMatcherExists(PendingPatternMatchers, funcname))
	{
		ret = true
	}
	elseif(FunctionIsAutoGen(AutoGeneratedFunctionNames, funcname))
	{
		ret = true
	}
}

FunctionExists : list<FunctionDefinition> ref funcs, integer funcname -> boolean ret = false
{
	if(funcs.value.Name == funcname)
	{
		ret = true
	}
	else
	{
		ret = FunctionExists(funcs.next, funcname)
	}
}

FunctionExists : nothing, integer funcname -> boolean ret = false


FunctionIsAutoGen : simplelist<integer> ref genlist, integer target -> boolean ret = false
{
	if(genlist.value == target)
	{
		ret = true
	}
	else
	{
		ret = FunctionIsAutoGen(genlist.next, target)
	}
}

FunctionIsAutoGen : nothing, integer target -> boolean ret = false



TypeMatcherExists : list<TypeMatcher> ref matchers, integer matchername -> boolean ret = false
{
	if(matchers.value.Name == matchername)
	{
		ret = true
	}
	else
	{
		ret = TypeMatcherExists(matchers.next, matchername)
	}
}

TypeMatcherExists : nothing, integer matchername -> boolean ret = false



FindVariable : integer name, integer ref frames -> integer index = FindVariableInScope(EmittingFunctionName, name)
{
	if(index < 0)
	{
		index = FindVariableInScope(GlobalCodeBlockName, name)
		frames = -1
	}
}



FindVariableInScope : integer scopename, integer varname -> integer index = FindVariableInScopeList(Scopes, scopename, varname)

FindVariableInScopeList : list<Scope> ref scopes, integer scopename, integer varname -> integer index = -1
{
	if(scopes.value.Name == scopename)
	{
		index = 0
		FindVariableInSingleScope(scopes.value.Variables, varname, index)
	}
	else
	{
		index = FindVariableInScopeList(scopes.next, scopename, varname)
	}
}

FindVariableInScopeList : nothing, integer scopename, integer varname -> integer index = -1


FindVariableInSingleScope : list<Variable> ref vars, integer varname, integer ref index
{
	if(vars.value.Name != varname)
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindVariableInSingleScope(vars.next, varname, index)
	}
}

FindVariableInSingleScope : nothing, integer varname, integer ref index
{
	index = -1
}


FindReturnVariableIndex : -> integer index = FindReturnVariableInScopeList(Scopes, EmittingFunctionName)

FindReturnVariableName: -> integer index = FindReturnVariableNameInScopeList(Scopes, EmittingFunctionName)


FindReturnVariableInScopeList : list<Scope> ref scopes, integer scopename -> integer index = -1
{
	if(scopes.value.Name == scopename)
	{
		index = 0
		FindReturnVariableInSingleScope(scopes.value.Variables, index)
	}
	else
	{
		index = FindReturnVariableInScopeList(scopes.next, scopename)
	}
}

FindReturnVariableInSingleScope : list<Variable> ref vars, integer ref index
{
	if(vars.value.Origin != 2)		// VARIABLE_ORIGIN_RETURN
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindReturnVariableInSingleScope(vars.next, index)
	}
}

FindReturnVariableInSingleScope : nothing, integer ref index
{
	index = -1
}


FindReturnVariableNameInScopeList : list<Scope> ref scopes, integer scopename -> integer name = 0
{
	if(scopes.value.Name == scopename)
	{
		FindReturnVariableNameInSingleScope(scopes.value.Variables, name)
	}
	else
	{
		name = FindReturnVariableNameInScopeList(scopes.next, scopename)
	}
}

FindReturnVariableNameInSingleScope : list<Variable> ref vars, integer ref name
{
	if(vars.value.Origin == 2)		// VARIABLE_ORIGIN_RETURN
	{
		name = vars.value.Name
	}
	else
	{
		FindReturnVariableNameInSingleScope(vars.next, name)
	}
}

FindReturnVariableNameInSingleScope : nothing, integer ref name
{
	name = 0
}



FindVariableType : integer varname -> integer rettype = 0
{
	Variable var = 0, 0, 0, 0
	if(!FindVariableDataInScope(EmittingFunctionName, varname, var))
	{
		FindVariableDataInScope(GlobalCodeBlockName, varname, var)
	}
	rettype = var.VarType
}


FindVariableDataInScope : integer scopename, integer varname, Variable ref outvar 
	->
	boolean found = FindVariableDataInScopeList(Scopes, scopename, varname, outvar)

FindVariableDataInScopeList : list<Scope> ref scopes, integer scopename, integer varname, Variable ref outvar -> boolean found = false
{
	if(scopes.value.Name == scopename)
	{
		found = FindVariableDataInSingleScope(scopes.value.Variables, varname, outvar)
		if((!found) && (GlobalCodeBlockName != 0) && (scopename != GlobalCodeBlockName))
		{
			found = FindVariableDataInScopeList(Scopes, GlobalCodeBlockName, varname, outvar)
		}
	}
	else
	{
		found = FindVariableDataInScopeList(scopes.next, scopename, varname, outvar)
	}
}

FindVariableDataInScopeList : nothing, integer scopename, integer varname, Variable ref outvar -> boolean found = false

FindVariableDataInSingleScope : list<Variable> ref vars, integer varname, Variable ref outvar -> boolean found = false
{
	if(vars.value.Name == varname)
	{
		outvar = vars.value
		found = true
	}
	else
	{
		found = FindVariableDataInSingleScope(vars.next, varname, outvar)
	}
}

FindVariableDataInSingleScope : nothing, integer varname, Variable ref outvar -> boolean found = false



CodeGenEmitTypeMatchers : list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{
		CodeGenEmitSingleTypeMatcher(matchers.value)
	}

	CodeGenEmitTypeMatchers(matchers.next)
}

CodeGenEmitTypeMatchers : nothing


CodeGenEmitSingleTypeMatcher : TypeMatcher ref matcher
{
	OnBytecodeLexicalScope(matcher.Name, 0, 0)
	OnBytecodeEnterTypeResolver(matcher.Name)
	CodeGenEmitTypeMatcherOverloads(matcher.Overloads)
	OnBytecodeExitTypeResolver()
}


OnCodeGenRegisterTypeMatchParam : integer matchername, integer overloadname, integer varname, integer vartype
{
	Parameter p = varname, vartype
	FindTypeMatcherAndAppendOverloadParameter(TypeMatchers, matchername, overloadname, p)
}

FindTypeMatcherAndAppendOverloadParameter : list<TypeMatcher> ref matchers, integer matchername, integer overloadname, Parameter ref p
{
	if(matchers.value.Name == matchername)
	{
		FindTMOverloadAndAppendParameter(matchers.value.Overloads, matchers.value.Overloads, overloadname, p)
	}
	else
	{
		FindTypeMatcherAndAppendOverloadParameter(matchers.next, matchername, overloadname, p)
	}
}

FindTypeMatcherAndAppendOverloadParameter : nothing, integer matchername, integer overloadname, Parameter ref p
{
	print("No type matcher available")
	assert(false)
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, list<FunctionSignature> ref signatures, integer overloadname, Parameter ref p
{
	if(signatures.value.Name == overloadname)
	{
		AppendParameter(signatures.value.Parameters, p)
	}
	else
	{
		FindTMOverloadAndAppendParameter(originallist, signatures.next, overloadname, p)
	}
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, nothing, integer overloadname, Parameter ref p
{
	list<Parameter> paramlist = p, nothing
	FunctionSignature sig = overloadname, paramlist, 0
	prepend<FunctionSignature>(originallist, sig)
}

AppendParameter : list<Parameter> ref params, Parameter ref p
{
	AppendParameterRecurse(params, params.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, list<Parameter> ref tail, Parameter ref p
{
	AppendParameterRecurse(tail, tail.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, nothing, Parameter ref p
{
	list<Parameter> newlist = p, nothing
	params.next = newlist
}


CodeGenEmitTypeMatcherOverloads : list<FunctionSignature> ref signatures
{
	CodeGenEmitTypeMatcherOverloads(signatures.next)

	if(signatures.value.Name != 0)
	{
		OnBytecodeEmitByte(0x20)				// TypeMatch instruction
		OnBytecodeEmitInteger(signatures.value.Name)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(CountParameters(signatures.value.Parameters))
		
		CodeGenEmitTypeMatcherParams(signatures.value.Parameters)
	}
}

CodeGenEmitTypeMatcherOverloads : nothing


CountParameters : list<Parameter> ref params -> integer count = 0
{
	count = CountParameters(params.next)

	if(params.value.Type != 0)
	{
		++count
	}
}

CountParameters : nothing -> integer count = 0


CodeGenEmitTypeMatcherParams : list<Parameter> ref params
{
	CodeGenEmitTypeMatcherParams(params.next)

	if(params.value.Name != 0)
	{
		integer refflag = 0
		if(IsReferenceType(params.value.Type))
		{
			refflag = 1
		}

		OnBytecodeEmitByte(refflag)
		OnBytecodeEmitInteger(MakeNonReferenceType(params.value.Type))
	}
}

CodeGenEmitTypeMatcherParams : nothing



OnCodeGenRegisterFunctionInvokeTag : integer funcname, integer invoketarget
{
	FindFunctionAndSetInvokeTag(Functions, funcname, invoketarget)
}

FindFunctionAndSetInvokeTag : list<FunctionDefinition> ref functions, integer funcname, integer invoketarget
{
	if(functions.value.Name == funcname)
	{
		functions.value.InvokeTag = invoketarget
	}
	else
	{
		FindFunctionAndSetInvokeTag(functions.next, funcname, invoketarget)
	}
}

FindFunctionAndSetInvokeTag : nothing, integer funcname, integer invoketarget
{
	print("Cannot tag non-existent function")
	assert(false)
}

OnCodeGenRegisterFunctionTag : integer funcname, string tagname, integer rawfuncname
{
	list<string> dtp = "", nothing
	FunctionTag tag = funcname, tagname, dtp
	prepend<FunctionTag>(FunctionTags, tag)

	if(tagname == "constructor")
	{
		simpleprepend<integer>(CustomConstructors, funcname)
		
		integer baseconstructorname = PoolString(GetPooledString(GlobalStrings, rawfuncname) ; "@@constructor")
		
		Overload overload = baseconstructorname, funcname
		prepend<Overload>(Overloads, overload)
		
		PrependFunctionParameter(Functions, funcname, PoolString("@id"), 0x81000000)		// reference to identifier type signature
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParam(FunctionTags.value.Parameters, FunctionTags.value.Parameters.next, param)
}

AppendFunctionTagParam : list<string> ref params, list<string> ref tail, string param
{
	AppendFunctionTagParam(tail, tail.next, param)
}

AppendFunctionTagParam : list<string> ref params, nothing, string param
{
	list<string> newlist = param, nothing
	params.next = newlist
}


CodeGenEmitFunctionTags : list<FunctionTag> ref tags
{
	CodeGenEmitSingleFunctionTag(tags.value)
	CodeGenEmitFunctionTags(tags.next)
}

CodeGenEmitFunctionTags : nothing


CodeGenEmitSingleFunctionTag : FunctionTag ref tag
{
	if(tag.FunctionName != 0)
	{
		if(tag.TagName != "")
		{
			OnBytecodeEmitByte(0x1a)
			OnBytecodeEmitInteger(tag.FunctionName)
			OnBytecodeEmitInteger(CountTagParams(tag.Parameters))
			OnBytecodeEmitString(tag.TagName)

			CodeGenEmitFunctionTagParams(tag.Parameters)
		}
	}
}


CodeGenEmitFunctionTagParams : list<string> ref params
{
	if(params.value != "")
	{
		OnBytecodeEmitString(params.value)
	}

	CodeGenEmitFunctionTagParams(params.next)
}

CodeGenEmitFunctionTagParams : nothing


CountTagParams : list<string> ref params -> integer count = 0
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0


CodeGenEmitConstructors : list<StructureDefinition> ref structures
{
	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		EmitCtorTag(structures.value.ConstructorName)
		EmitCtorTag(structures.value.AnonConstructorName)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCtorTag(structures.value.CopyConstructorName)
		}

		EmitConstructor(structures.value)
		EmitAnonConstructor(structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCopyConstructor(structures.value)
		}
	}

	CodeGenEmitConstructors(structures.next)
}

CodeGenEmitConstructors : nothing

EmitCtorTag : integer funcname
{
	OnBytecodeEmitByte(0x1a)
	OnBytecodeEmitInteger(funcname)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitString("@@autogen@constructor")
}


EmitConstructor : StructureDefinition ref def
{
	integer idhandle = FindString(GlobalStrings, "identifier")

	OnBytecodeLexicalScope(def.ConstructorName, 0, CountMembers(def.Members) + 1)
	OnBytecodeLexicalScopeEntry(idhandle, 0x81000000, 1)
	EmitScopeEntriesForMembers(def.Members)

	OnBytecodeEnterFunction(def.ConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, idhandle)

	OnBytecodeExitFunction()
}

EmitAnonConstructor : StructureDefinition ref def
{
	integer membercount = CountMembers(def.Members)
	OnBytecodeLexicalScope(def.AnonConstructorName, 0, membercount + 1)
	EmitScopeEntriesForMembers(def.Members)
	OnBytecodeLexicalScopeEntry(def.AnonConstructorName, def.Type, 2)

	OnBytecodeEnterFunction(def.AnonConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, membercount)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, def.AnonConstructorName)

	OnBytecodeSetReturnRegister(membercount)
	OnBytecodeExitFunction()
}

EmitCopyConstructor : StructureDefinition ref def
{
	OnBytecodeLexicalScope(def.CopyConstructorName, 0, 2)
	OnBytecodeLexicalScopeEntry(FindString(GlobalStrings, "identifier"), 0x81000000, 1)
	OnBytecodeLexicalScopeEntry(def.Name, def.Type, 1)

	OnBytecodeEnterFunction(def.CopyConstructorName)
	OnBytecodePushVarNoCopy(def.Name)
	OnBytecodeCopyStructure()
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()
	OnBytecodeExitFunction()
}


EmitScopeEntriesForMembers : list<StructureMember> ref members
{
	EmitScopeEntryForMember(members.value)
	EmitScopeEntriesForMembers(members.next)
}

EmitScopeEntriesForMembers : nothing


EmitScopeEntryForMember : StructureMemberVariable ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, memvar.Type, 1)
	}
}

EmitScopeEntryForMember : StructureMemberFunctionRef ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, GetMemberTypeDecompose(memvar), 1)
	}
}



EmitMemberDataCopies : list<StructureMember> ref members, integer idhandle
{
	EmitMemberDataCopy(members.value, idhandle)
	EmitMemberDataCopies(members.next, idhandle)
}

EmitMemberDataCopies : nothing, integer idhandle

EmitMemberDataCopy : StructureMemberVariable ref memvar, integer idhandle
{
	if(memvar.Name != 0)
	{
		OnBytecodePushVarValue(memvar.Name, memvar.Type)
		OnBytecodeCopyToStructure(idhandle, memvar.Name)
	}
}

EmitMemberDataCopy : StructureMemberFunctionRef ref member, integer idhandle
{
	if(member.Name != 0)
	{
		OnBytecodePushVarValue(member.Name, 0x09000000)
		OnBytecodeCopyToStructure(idhandle, member.Name)
	}
}


FindString : list<StringTableEntry> ref strings, string target -> integer handle = 0
{
	if(strings.value.Data == target)
	{
		handle = strings.value.Handle
	}
	else
	{
		handle = FindString(strings.next, target)
	}
}

FindString : nothing, string target -> integer handle = 0



GetNameOfType : integer typeid -> integer name = 0
{
	typeid = MakeNonReferenceType(typeid)
	if(typeid == 0x01000001)
	{
		name = FindString(GlobalStrings, "integer")
	}
	elseif(typeid == 0x01000002)
	{
		name = FindString(GlobalStrings, "integer16")
	}
	elseif(typeid == 0x01000003)
	{
		name = FindString(GlobalStrings, "boolean")
	}
	elseif(typeid == 0x01000004)
	{
		name = FindString(GlobalStrings, "real")
	}
	elseif(typeid == 0x02000000)
	{
		name = FindString(GlobalStrings, "string")
	}
	elseif(typeid == 0x02000001)
	{
		name = FindString(GlobalStrings, "buffer")
	}
	elseif(typeid == 0x00000004)
	{
		name = FindString(GlobalStrings, "nothing")
	}
	elseif(typeid == 0x01000000)
	{
		name = FindString(GlobalStrings, "identifier")
	}
	elseif(IsStructureType(typeid))
	{
		name = GetNameOfStructureByType(typeid)
	}
	elseif((typeid & 0xff000000) == 0x07000000)
	{
		name = FindSumTypeName(typeid)
	}
	elseif((typeid & 0x7f000000) == 0x09000000)
	{
		name = PoolString("{function} " ; cast(string, typeid))
	}
	else
	{
		print("Unknown type " ; cast(string, typeid))
		assert(false)
	}
}

GetTypeByName : integer name -> integer typeid = 0
{
	integer unaliasedname = UnaliasType(TypeWeakAliases, name)
	while(unaliasedname != name)
	{
		name = unaliasedname
		unaliasedname = UnaliasType(TypeWeakAliases, name)
	}
	name = unaliasedname

	if(name == FindString(GlobalStrings, "identifier"))
	{
		typeid = 0x01000000
	}
	elseif(name == FindString(GlobalStrings, "integer"))
	{
		typeid = 0x01000001
	}
	elseif(name == FindString(GlobalStrings, "integer16"))
	{
		typeid = 0x01000002
	}
	elseif(name == FindString(GlobalStrings, "boolean"))
	{
		typeid = 0x01000003
	}
	elseif(name == FindString(GlobalStrings, "real"))
	{
		typeid = 0x01000004
	}
	elseif(name == FindString(GlobalStrings, "string"))
	{
		typeid = 0x02000000
	}
	elseif(name == FindString(GlobalStrings, "nothing"))
	{
		typeid = 0x00000004
	}
	elseif(name == FindString(GlobalStrings, "buffer"))
	{
		typeid = 0x02000001
	}
	else
	{
		integer structuretype = GetStructureTypeByName(Structures, name)
		if(structuretype != 0)
		{
			typeid = structuretype
			return()
		}
		
		integer strongaliastype = FindTypeAliasByName(TypeAliases, name)
		if(strongaliastype != 0)
		{
			typeid = strongaliastype
			return()
		}
		
		integer sumtype = FindSumTypeByName(SumTypes, name)
		if(sumtype != 0)
		{			
			typeid = sumtype
			return()
		}
	}
}


FindSumTypeByName : list<SumType> ref sumtypes, integer name -> integer typeid = 0
{
	if((sumtypes.value.Type != 0) && (sumtypes.value.Name == name))
	{
		typeid = sumtypes.value.Type
		return()
	}
	
	typeid = FindSumTypeByName(sumtypes.next, name)
}

FindSumTypeByName : nothing, integer name -> 0


UnaliasType : list<TypeAlias> ref aliases, integer namehandle -> integer unaliasedname = 0
{
	if(aliases.value.AliasNameHandle == namehandle)
	{
		unaliasedname = aliases.value.BaseNameHandle
	}
	else
	{
		unaliasedname = UnaliasType(aliases.next, namehandle)
	}
}

UnaliasType : nothing, integer namehandle -> integer unaliasedname = namehandle



GetStructureTypeByName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0
{
	if(structures.value.Name == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureTypeByName(structures.next, name)
	}
}

GetStructureTypeByName : nothing, integer name -> 0



// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	simplelist<integer> processed = 0, nothing
	boolean changed = CodeGenRearrangeStructuresRecurse(thelist, processed)

	if(changed)
	{
		CodeGenRearrangeStructures(thelist)
	}
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref thelist, simplelist<integer> ref processed -> boolean changed = false
{
	if((thelist.value.Name != 0) && (!thelist.value.IsTemplate))
	{
		simplelist<integer> dependencies = 0, nothing
		ParseStructDependencies(thelist.value.Members, dependencies)

		if(MissingDependency(dependencies, processed))
		{
			SwapDown(thelist, thelist.next)
			changed = true
		}

		simpleprepend<integer>(processed, thelist.value.Type)
	}

	if(!changed)
	{
		CodeGenRearrangeStructuresRecurse(thelist.next, processed)
	}
}

CodeGenRearrangeStructuresRecurse : nothing, simplelist<integer> ref processed -> false


SwapDown : list<StructureDefinition> ref thelist, list<StructureDefinition> ref tail
{
	StructureDefinition temp = tail.value
	tail.value = thelist.value
	thelist.value = temp
}

SwapDown : list<StructureDefinition> ref thelist, nothing



ParseStructDependencies : list<StructureMember> ref members, simplelist<integer> ref out
{
	integer dependency = GetMemberDependency(members.value)
	if(dependency != 0)
	{
		simpleprepend<integer>(out, dependency)
	}

	ParseStructDependencies(members.next, out)
}

ParseStructDependencies : nothing, simplelist<integer> ref out


GetMemberDependency : StructureMemberVariable ref var -> integer dep = 0
{
	if(var.Name != 0)
	{
		if(IsStructureType(var.Type))
		{
			dep = var.Type
		}
	}
}

GetMemberDependency : StructureMemberFunctionRef ref member -> 0


MissingDependency : simplelist<integer> ref dependencies, simplelist<integer> ref processed -> boolean missing = true
{
	// TODO - clean up this horrible code
	if(dependencies.value != 0)
	{
		if(listcontains(processed, dependencies.value))
		{
			missing = false
		}
		else
		{
			missing = MissingDependency(dependencies.next, processed)
		}
	}
	else
	{
		missing = MissingDependency(dependencies.next, processed)
	}
}

MissingDependency : nothing, simplelist<integer> ref processed -> boolean missing = false			// TODO - is this really correct?!


OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	Expression d = dummyexpression
	ScratchExpressions.value = d
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = ScratchExpressions.value
	EntityStack.value.Param = expr

	OptionalCodeBlock block = nothing
	prepend<OptionalCodeBlock>(CurrentCodeBlockStack, block)
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


AppendEntityToChain : list<EntityChain> ref chainstack, Entity ref e
{
	AppendEntityToChainUnwrap(chainstack.value.Entries, e)
}

AppendEntityToChainUnwrap : EntityList ref entitylist, Entity ref e
{
	AppendEntityToChainWorker(entitylist.ActualList, entitylist.ActualList.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, list<Entity> ref tail, Entity ref e
{
	AppendEntityToChainWorker(tail, tail.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, nothing, Entity ref e
{
	list<Entity> newtail = e, nothing
	chain.next = newtail
}


FindTypeAliasBase : list<TypeAlias> ref aliases, integer aliastype -> integer basetype = 0
{
	if(aliases.value.TypeID == aliastype)
	{
		basetype = GetTypeByName(aliases.value.BaseNameHandle)
	}
	else
	{
		basetype = FindTypeAliasBase(aliases.next, aliastype)
	}
}

FindTypeAliasBase : nothing, integer aliastype -> integer basetype = 0


FindTypeAliasByName : list<TypeAlias> ref aliases, integer aliasname -> integer aliastype = 0
{
	if(aliases.value.AliasNameHandle == aliasname)
	{
		aliastype = aliases.value.TypeID
	}
	else
	{
		aliastype = FindTypeAliasByName(aliases.next, aliasname)
	}
}

FindTypeAliasByName : nothing, integer aliasname -> 0


OnCodeGenRegisterAlias : integer aliastype, integer aliasname, integer base
{
	TypeAlias newalias = aliastype, aliasname, base
	prepend<TypeAlias>(TypeAliases, newalias)
}

OnCodeGenRegisterWeakAlias : integer aliastype, integer aliasname, integer basename
{
	TypeAlias newalias = aliastype, aliasname, basename
	prepend<TypeAlias>(TypeWeakAliases, newalias)
}


OnCodeGenRegisterFunctionSig : integer sigtype, integer rettypename
{
	list<Parameter> d = dummyparam, nothing
	FunctionSignature sig = sigtype, d, rettypename
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype
{
	Parameter param = 1, paramtype
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigParamList : simplelist<integer> ref paramtypenames
{
	OnCodeGenRegisterFunctionSigParamList(paramtypenames.next)
	
	if(paramtypenames.value != 0)
	{
		OnCodeGenRegisterFunctionSigParam(GetTypeByName(paramtypenames.value))		// TODO - defer higher order function parameter type resolution until type inference
	}
}

OnCodeGenRegisterFunctionSigParamList : nothing


OnCodeGenRegisterFunctionSigEnd :
{
	// TODO - dead code?
}

CodeGenEmitFunctionSignatures : list<FunctionSignature> ref thelist
{
	CodeGenEmitSingleFunctionSignature(thelist.value)
	CodeGenEmitFunctionSignatures(thelist.next)
}

CodeGenEmitFunctionSignatures : nothing


CodeGenEmitSingleFunctionSignature : FunctionSignature ref signature
{
	if(signature.Name != 0)
	{
		integer rettype = GetTypeByName(signature.ReturnTypeName)
		if(rettype == 0)
		{
			rettype = 0x00000002		// void
		}
		
		OnBytecodeEmitFunctionSignature(signature.Name, rettype, CountParameters(signature.Parameters))
		CodeGenEmitFunctionSigParams(signature.Parameters)
	}
}

CodeGenEmitFunctionSigParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		OnBytecodeEmitFunctionSigParam(params.value.Type)
	}
	CodeGenEmitFunctionSigParams(params.next)
}

CodeGenEmitFunctionSigParams : nothing


OnCodeGenRegisterParenthetical : 
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyexpression
	prepend<Expression>(ScratchExpressions, d)
}


OnCodeGenPreparePreOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist, 0

	PreOpOnDeck = preop
}

OnCodeGenPreparePreOpCompoundOperand : integer operand
{
	AppendCompoundMemberHelper(PreOpOnDeck, operand)
}

OnCodeGenCompletePreOpStatement : boolean substatement
{
	if(substatement)
	{
		ExpressionOrPrePostOp wrap = PreOpOnDeck
		ParentheticalExpression parenthetical = wrap
		ExpressionAtom atom = parenthetical
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		CodeBlockEntry cbe = PreOpOnDeck
		AppendEntryToCurrentCodeBlock(cbe)
	}
}

OnCodeGenAddPreOpCompoundOperand : integer operand
{
	FindLastPreOpAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, operand)
}

FindLastPreOpAndAppendCompoundMemberHelper : CodeBlock ref codeblock, integer operand
{
	FindLastPreOpAndAppendCompoundMember(codeblock.Entries, codeblock.Entries.next, operand)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastPreOpAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist, 0
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}


GetLargestSumTypeBaseSize : integer typeid -> integer size = FindSumTypeAndGetBaseMaxSize(SumTypes, typeid)

FindSumTypeAndGetBaseMaxSize : list<SumType> ref sumtypes, integer typeid -> integer size = 0
{
	if(sumtypes.value.Type == typeid)
	{
		GetBaseMaxSize(sumtypes.value.Bases, size)
	}
	else
	{
		size = FindSumTypeAndGetBaseMaxSize(sumtypes.next, typeid)
	}
}

FindSumTypeAndGetBaseMaxSize : nothing, integer typeid -> 0


GetBaseMaxSize : list<SumTypeBase> ref basetypes, integer ref outsize
{
	integer typename = basetypes.value.Name
	if(typename != 0)
	{
		integer thissize = GetTypeSize(typename)
		if(thissize > outsize)
		{
			outsize = thissize
		}
	}

	GetBaseMaxSize(basetypes.next, outsize)
}

GetBaseMaxSize : nothing, integer ref outsize



OnCodeGenSetExpressionType : integer typeid
{
	ScratchExpressions.value.Type = typeid
}

OnCodeGenShiftParameter :
{
	if(InFuncRetHack)
	{
		AppendExpressionToSubStatement(ScratchExpressions.value)
	}
	elseif(PeekContext(ContextStack, 1) != STACK_TYPE_SUBSTATEMENT)
	{
		FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
	}
	else
	{
		AppendExpressionToSubStatement(ScratchExpressions.value)
	}

	Expression d = dummyexpression
	ScratchExpressions.value = d
}

PeekContext : list<ContextStackEntry> ref stack, integer depth -> integer peek = STACK_TYPE_GLOBAL
{
	if(depth == 0)
	{
		peek = stack.value.EntryType
	}
	else
	{
		peek = PeekContext(stack.next, depth - 1)
	}
}


CodeGenEmitGlobalBlockPrologue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeEnterEntity(4, GlobalCodeBlockName)
		CodeGenEmitCodeBlock(block)
		OnBytecodeInvokeOffset(FindString(GlobalStrings, "entrypoint"))
		OnBytecodeHalt()
	}
}

CodeGenEmitGlobalBlockEpilogue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeExitEntity()
	}
}


IsStructureType : integer typeid -> boolean ret = false
{
	if((typeid & 0x7f000000) == 0x03000000)
	{
		ret = true
	}
	elseif((typeid & 0x7f000000) == 0x08000000)
	{
		ret = true
	}
}

IsReferenceType : integer typeid -> boolean ret = false
{
	if((typeid & 0x80000000) != 0)
	{
		ret = true
	}
}

MakeReferenceType : integer typeid -> integer reftypeid = typeid
{
	if(!IsReferenceType(typeid))
	{
		reftypeid = typeid + 0x80000000
	}
}

MakeNonReferenceType : integer typeid -> (typeid & 0x7fffffff)


append_recurse : list<Variable> ref thelist, nothing, Variable ref value
{
	list<Variable> newlist = value, nothing
	thelist.next = newlist
}

append_recurse : list<Variable> ref thelist, list<Variable> ref tail, Variable ref value
{
	append_recurse(tail, tail.next, value)
}


append : list<Variable> ref thelist, Variable ref value
{
	append_recurse(thelist, thelist.next, value)
}



CodeBlockDepth : list<OptionalCodeBlock> ref stack -> integer count = 0
{
	count = CodeBlockDepth(stack.next) + 1
}

CodeBlockDepth : nothing -> 0



IRProcess : -> boolean success = true
{
	if(!IRCompileTimeCodeExecution())
	{
		success = false
		return()
	}

	if(!IRTypeInference())
	{
		success = false
		return()
	}

	if(!IRValidate())
	{
		success = false
		return()
	}
}


IRCompileTimeCodeExecution : -> boolean success = true
{
	if(!CompileTimeCodeExecution(Functions))
	{
		success = false
	}
}



CompileTimeCodeExecution : nothing -> true


CompileTimeCodeExecution : list<FunctionDefinition> ref functions -> boolean success = true
{
	if(!CompileTimeCodeExecution(functions.value))
	{
		success = false
	}
	
	if(!CompileTimeCodeExecution(functions.next))
	{
		success = false
	}
}


CompileTimeCodeExecution : FunctionDefinition ref func -> boolean success = true
{
	// TODO
}

GeneratePendingTypeMatchers : list<PendingTypeMatcher> ref pendingmatchers -> boolean success = true
{
	if(!GeneratePendingTypeMatcher(pendingmatchers.value))
	{
		success = false
	}
	
	if(!GeneratePendingTypeMatchers(pendingmatchers.next))
	{
		success = false
	}
}

GeneratePendingTypeMatchers : nothing -> true

GeneratePendingTypeMatcher : PendingTypeMatcher ref matcher -> boolean success = true
{
	if(matcher.OverloadName == 0)
	{
		return()
	}

	if(!TypeMatcherExists(TypeMatchers, matcher.MatcherName))
	{
		OnCodeGenEnterTypeMatcher(matcher.MatcherName)
		OnCodeGenExitContext()
	}
	
	EnsureTypeMatcherIsConfigured(Functions, matcher.OverloadName, matcher.MatcherName)
}

EnsureTypeMatcherIsConfigured : list<FunctionDefinition> ref functions, integer overloadname, integer matchername
{
	if(functions.value.Name == overloadname)
	{
		CreateTypeMatcherEntryForFunction(functions.value, matchername)
		return()
	}

	EnsureTypeMatcherIsConfigured(functions.next, overloadname, matchername)
}

EnsureTypeMatcherIsConfigured : nothing, integer overloadname, integer matchername
{
	print("Failed to generate type matcher " ; GetPooledString(GlobalStrings, matchername))
	print("Missing overload " ; GetPooledString(GlobalStrings, overloadname))
	assert(false)
}


CreateTypeMatcherEntryForFunction : FunctionDefinition ref func, integer matchername
{
	integer name = func.Name		// TODO - more dumb compiler bug
	WalkParametersForTypeMatcher(func.Params, matchername, name)
}

WalkParametersForTypeMatcher : FunctionParams ref params, integer matchername, integer overloadname
{
	WalkParametersForTypeMatcherUnwrapped(params.Params, matchername, overloadname)
}


WalkParametersForTypeMatcherUnwrapped : list<UnresolvedParameter> ref params, integer matchername, integer overloadname
{
	if(params.value.NameHandle != 0)
	{
		OnCodeGenRegisterTypeMatchParam(matchername, overloadname, params.value.NameHandle, params.value.ResolvedType)
	}
	
	WalkParametersForTypeMatcherUnwrapped(params.next, matchername, overloadname)
}

WalkParametersForTypeMatcherUnwrapped : nothing, integer matchername, integer overloadname



DumpTypeList : simplelist<integer> ref types
{
	if(types.value != 0)
	{
		print(" Potential type: " ; GetPooledString(GlobalStrings, GetNameOfType(types.value)))
	}
	
	DumpTypeList(types.next)
}

DumpTypeList : nothing


structure InferenceContext :
	integer ScopeName,
	integer StatementName,
	simplelist<integer> ref ExpectedTypes,
	boolean FunctionReturn,
	integer NumParameters,
	boolean TopLevelStatement

structure TypePossibilityList :
	simplelist<integer> ref Types,
	boolean Consumed

structure InferencePossibility :
	integer FunctionName,
	list<TypePossibilityList> ref ParameterTypes,
	TypePossibilityList ref ReturnType

structure ExpressionInferenceStackEntry :
	list<InferencePossibility> ref PossibilityList


IRTypeInference : -> boolean success = true
{
	simplelist<integer> temp = 0, nothing
	InferenceContext context = 0, 0, temp, false, 0, false
	
	if(!TypeInference(SumTypes, context))
	{
		success = false
	}
	
	if(!TypeInference(Structures, context))
	{
		success = false
	}

	if(GlobalCodeBlockName != 0)
	{
		InferenceContext globalcontext = GlobalCodeBlockName, 0, temp, false, 0, false
		if(!TypeInference(GlobalCodeBlock, globalcontext))
		{
			success = false
		}
	}

	if(!TypeInference(Functions, context))
	{
		success = false
	}
}

TypeInference : nothing, InferenceContext ref context -> true


TypeInference : list<SumType> ref sumtypes, InferenceContext ref context -> boolean success = true
{
	if(sumtypes.value.Type != 0)
	{
		if(!sumtypes.value.IsTemplate)
		{
			if(!ResolveSumTypeBases(sumtypes.value.Bases))
			{
				success = false
			}
		}
	}
	
	if(!TypeInference(sumtypes.next, context))
	{
		success = false
	}
}

ResolveSumTypeBases : list<SumTypeBase> ref bases -> boolean success = true
{
	if(bases.value.Name != 0)
	{
		integer resolvedtype = ResolveSingleBase(bases.value, bases.value.TemplateArgs)
			
		if(resolvedtype == 0)
		{
			print("Sum type has unknown base type")
			success = false
		}
		
		bases.value.Name = resolvedtype
	}
	
	if(!ResolveSumTypeBases(bases.next))
	{
		success = false
	}
}

ResolveSumTypeBases : nothing -> true

ResolveSingleBase : SumTypeBase ref base, nothing -> integer ret = GetTypeByName(base.Name)
ResolveSingleBase : SumTypeBase ref base, TemplateArgumentList ref args -> integer ret = GetTypeByName(InstantiateStructureTemplate(base.Name, args))


TypeInference : list<StructureDefinition> ref structures, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(structures.value, context))
	{
		success = false
	}
	
	if(!TypeInference(structures.next, context))
	{
		success = false
	}
}

TypeInference : StructureDefinition ref structuredef, InferenceContext ref context -> boolean success = true
{
	if(structuredef.Name == 0)
	{
		return()
	}
	
	if(structuredef.IsTemplate)
	{
		return()
	}

	if(!TypeInference(structuredef.Members, context))
	{
		success = false
	}
	
	string readablename = GetPooledString(GlobalStrings, structuredef.Name)
	integer ctorname = PoolString(readablename ; "@@constructor")
	integer anonname = PoolString(readablename ; "@@anonconstructor")
	integer copyname = PoolString(readablename ; "@@copyconstructor")
	OnCodeGenRegisterConstructors(structuredef.Name, ctorname, anonname, copyname)
	
	Overload anonoverload = ctorname, anonname
	prepend<Overload>(Overloads, anonoverload)
	
	Overload copyoverload = ctorname, copyname
	prepend<Overload>(Overloads, copyoverload)
}


TypeInference : list<StructureMember> ref members, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(members.value, context))
	{
		success = false
	}
	
	if(!TypeInference(members.next, context))
	{
		success = false
	}
}

TypeInference : StructureMemberVariable ref memvar, InferenceContext ref context -> boolean success = true
{
	if(memvar.Name == 0)
	{
		return()
	}

	integer pretype = memvar.Type
	memvar.Type = GetTypeByName(InstantiateStructureTemplate(memvar.TypeNameHandle, memvar.TemplateArgs))
	if(memvar.Type == 0)
	{
		memvar.Type = GetTypeByName(memvar.TypeNameHandle)
	}
	
	if(memvar.Type == 0)
	{
		print("Type not recognized: " ; GetPooledString(GlobalStrings, memvar.TypeNameHandle))
		success = false
	}
	else
	{
		memvar.Type = memvar.Type + pretype			// Hack to accept reference marker
	}
}

TypeInference : StructureMemberFunctionRef ref memfunc, InferenceContext ref context -> boolean success = true
{
	ResolveSignatureTypes(memfunc.Signature)
}


TypeInference : list<FunctionDefinition> ref functions, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(functions.value, context))
	{
		success = false
	}

	if(!TypeInference(functions.next, context))
	{
		success = false
	}
}

TypeInference : FunctionDefinition ref func, InferenceContext ref context -> boolean success = true
{
	if(func.IsTemplate)
	{
		return()
	}

	if(func.InferenceDone)
	{
		return()
	}
	
	func.InferenceDone = true

	simplelist<integer> temp = 0, nothing
	InferenceContext innercontext = func.Name, 0, temp, false, 0, false
	
	
	if(!TypeInference(func.Params, innercontext))
	{
		print("Parameters to function failed type inference")
		success = false
	}
	

	simplelist<integer> tempret = 0, nothing
	InferenceContext retcontext = func.Name, 0, tempret, true, 0, false

	if(!TypeInference(func.Return, retcontext))
	{
		print("Function return expression failed type inference")
		success = false
	}
	
	integer rettype = GetOptionalExpressionType(func.Return)
	if((rettype != 0) && (rettype != 0x00000002))	// void magic
	{
		if(func.AnonymousReturn)
		{
			OnCodeGenRegisterVariable(func.Name, PoolString("@@anonymousret"), rettype, 2)
		}
	}
	
	if(!TypeInference(func.Code, innercontext))
	{
		print(GetPooledString(GlobalStrings, func.Name) ; "() - Function code body failed type inference")
		success = false
	}
}

TypeInference : FunctionParams ref params, InferenceContext ref context -> boolean success = TypeInference(params.Params, context)

TypeInference : list<UnresolvedParameter> ref params, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(params.value, context))
	{
		success = false
	}
	
	if(!TypeInference(params.next, context))
	{
		success = false
	}
}

TypeInference : UnresolvedParameter ref param, InferenceContext ref context -> boolean success = true
{
	if((param.ResolvedType & 0x7f000000) == 0x09000000)
	{
		OnCodeGenRegisterVariable(context.ScopeName, param.NameHandle, param.ResolvedType, 1)
		return()
	}
	
	integer patternmatchtype = GetOptionalExpressionType(param.PatternMatchValue)
	if(patternmatchtype != 0)
	{
		param.ResolvedType = patternmatchtype
		return()
	}
	
	param.TypeNameHandle = MangleTemplateNameByHandle(param.TypeNameHandle, param.TemplateArgs)

	param.ResolvedType = GetTypeByName(param.TypeNameHandle)
	if(param.ResolvedType == 0)
	{
		print("Unknown parameter type: " ; GetPooledString(GlobalStrings, param.TypeNameHandle))
		success = false
	}
	else
	{
		if(param.HasRefTag)
		{
			param.ResolvedType = param.ResolvedType + 0x80000000
		}
		
		OnCodeGenRegisterVariable(context.ScopeName, param.NameHandle, param.ResolvedType, 1)
	}
}

TypeInference : CodeBlock ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.Entries, context))
	{
		success = false
	}
}

TypeInference : list<CodeBlockEntry> ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.value, context))
	{
		success = false
	}

	if(!TypeInference(code.next, context))
	{
		success = false
	}
}


TypeInference : PreOpStatement ref statement, InferenceContext ref context -> boolean success = true
{	
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(context.ScopeName, statement.Operand.value, var)
	
	integer operandtype = MakeNonReferenceType(var.VarType)

	if(countnonzero(statement.Operand) > 1)
	{
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}
	
	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype		// TODO - maybe don't assume that the operator returns the same type as it takes?
}


TypeInference : PostOpStatement ref statement, InferenceContext ref context -> boolean success = true
{	
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(context.ScopeName, statement.Operand.value, var)

	integer operandtype = MakeNonReferenceType(var.VarType)
	
	if(countnonzero(statement.Operand) > 1)
	{
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}
	
	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype
}


TypeInference : Statement ref statement, InferenceContext ref context -> boolean success = true
{
	statement.Name = InstantiateFunctionTemplate(statement.Name, statement.TemplateArgs)

	integer paramcount = CountExpressions(statement.Parameters)

	integer vartype = GetTypeByName(statement.Name)
	if(vartype != 0)
	{
		integer origin = 0
		if(context.FunctionReturn)
		{
			origin = 2
			SetFunctionReturnType(context.ScopeName, vartype)
		}
		
		while((vartype & 0x7f000000) == 0x05000000)
		{
			vartype = FindTypeAliasBase(TypeAliases, vartype)
		}
		
		if(IsStructureType(vartype))
		{
			statement.Name = GetConstructorName(Structures, vartype)
		}
		else
		{
			statement.Name = GetNameOfType(vartype)
		}
		
		if(statement.TopLevel)
		{
			ConstructVariableFromStatement(statement, context.ScopeName, vartype, origin)
		}
	}

	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(context.ScopeName, statement.Name, var)
	if((var.Name != 0) && ((var.VarType & 0x7f000000) == 0x09000000))
	{
		// TODO - type checking on higher order functions
		
		statement.Type = GetSignatureReturnType(FunctionSignatures, var.VarType)
	}
	else
	{
		InferenceContext newcontext = context.ScopeName, statement.Name, context.ExpectedTypes, false, paramcount, statement.TopLevel

		if(!TypeInference(statement.Parameters, newcontext))
		{
			success = false
			print("Type inference failed for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
		}


		simplelist<integer> paramtypes = 0, nothing
		AccumulateParameterTypes(paramtypes, statement.Parameters)
		
		// This is the worst hack EVER.
		if(GetPooledString(GlobalStrings, statement.Name) == "cast")
		{
			statement.Name = GetCastOverload(statement.Parameters)
			
			if(statement.Name == 0)
			{
				success = false
				print("Invalid cast()")
			}
		}
		else
		{
			integer overloadname = FindOverloadWithParameterTypes(Overloads, statement.Name, paramtypes)
			if(overloadname != 0)
			{
				statement.Name = overloadname
			}
			else
			{
				success = false
				print("No matching overload for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
			}
		}
		
		if(context.FunctionReturn)
		{
			statement.Type = vartype
		}
		else
		{
			statement.Type = GetFunctionReturnType(Functions, statement.Name)
		}
		
		MakeParametersReferences(Functions, statement.Name, statement.Parameters)

		if(vartype != 0)
		{
			InsertAnnotationsForTypeMatchedParams(Functions, statement.Name, statement.Parameters)
		}
		elseif(IsPendingTypeMatcher(PendingTypeMatchers, statement.Name))
		{
			AnnotateAllParameters(statement.Parameters)
		}
	}
}

CountExpressions : nothing -> 0

CountExpressions : ExpressionList ref exprs -> integer count = CountExpressions(exprs.Expressions)

CountExpressions : list<Expression> ref exprs -> integer count = 1
{
	count += CountExpressions(exprs.next)
}


AnnotateAllParameters : ExpressionList ref exprs
{
	AnnotateAllParameters(exprs.Expressions)
}

AnnotateAllParameters : list<Expression> ref params
{
	AddTypeAnnotation(params.value)
	AnnotateAllParameters(params.next)
}

AnnotateAllParameters : nothing


AnnotateNonReferenceParameters : ExpressionList ref exprs
{
	AnnotateNonReferenceParameters(exprs.Expressions)
}

AnnotateNonReferenceParameters : list<Expression> ref params
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	AnnotateNonReferenceParameters(params.next)
}

AnnotateNonReferenceParameters : nothing



AddTypeAnnotation : nothing

AddTypeAnnotation : list<Expression> ref params
{
	AddTypeAnnotation(params.value)
}

AddTypeAnnotation : Expression ref expr
{
	integer typeid = expr.Type
	TypeAnnotationAtom atom = typeid
	ExpressionAtom wrap = atom
	AppendAtomToExpression(expr.Atoms, expr.Atoms.next, wrap)
}


AccumulateParameterTypes : simplelist<integer> ref types, OptionalExpressionList ref exprs
{
	AccumulateParameterTypesUnwrap(types, exprs)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, ExpressionList ref exprs
{
	AccumulateParameterTypesUnwrapped(exprs.Expressions, types)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, nothing

AccumulateParameterTypesUnwrapped : list<Expression> ref exprs, simplelist<integer> ref types
{
	AccumulateParameterTypesUnwrapped(exprs.next, types)
	simpleprepend<integer>(types, exprs.value.Type)
}

AccumulateParameterTypesUnwrapped : nothing, simplelist<integer> ref types


FindOverloadWithParameterTypes : list<Overload> ref overloads, integer rawname, simplelist<integer> ref types -> integer overloadname = rawname
{
	if(overloads.value.NormalName == rawname)
	{	
		if(FunctionMatchesParameterTypes(Functions, overloads.value.MangledName, types))
		{
			integer matchername = CheckForNeededPatternMatcher(PendingPatternMatchers, rawname)
			if(matchername != 0)
			{
				overloadname = matchername
			}
			else
			{
				overloadname = overloads.value.MangledName
			}		
			return()
		}
		elseif(countnonzero(types) == GetFunctionParameterCount(Functions, overloads.value.MangledName))
		{
			if(CheckForNeededTypeMatcher(types))
			{
				overloadname = FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName)
				FindOverloadWithParameterTypes(overloads.next, rawname, types)
				return()
			}
		}
	}

	overloadname = FindOverloadWithParameterTypes(overloads.next, rawname, types)
}


PopulateAllOverloadTypeMatchers : list<Overload> ref overloads, integer rawname, integer paramcount
{
	if(overloads.value.NormalName == rawname)
	{
		if(paramcount == GetFunctionParameterCount(Functions, overloads.value.MangledName))
		{			
			if(!IsFunctionTemplate(Functions, overloads.value.MangledName))
			{				
				FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName)
			}
		}
	}

	PopulateAllOverloadTypeMatchers(overloads.next, rawname, paramcount)
}

PopulateAllOverloadTypeMatchers : nothing, integer rawname, integer paramcount



GenerateTypeMatcherMappings : list<FunctionDefinition> ref functions
{
	if(functions.value.Name != 0)
	{
		if(!functions.value.IsTemplate)
		{
			if(AnyPendingTypeMatcherPointsToFunction(PendingTypeMatchers, functions.value.Name))
			{
				PopulateAllOverloadTypeMatchers(Overloads, functions.value.Name, CountUnresolvedParameters(functions.value.Params))
			}
		}
	}

	GenerateTypeMatcherMappings(functions.next)
}

GenerateTypeMatcherMappings : nothing


AnyPendingTypeMatcherPointsToFunction : list<PendingTypeMatcher> ref pending, integer mangledname -> boolean ret = false
{
	if(pending.value.OverloadName == mangledname)
	{
		ret = true
	}
	else
	{
		ret = AnyPendingTypeMatcherPointsToFunction(pending.next, mangledname)
	}
}

AnyPendingTypeMatcherPointsToFunction : nothing, integer mangledname -> false



GetFunctionParameterCount : list<FunctionDefinition> ref functions, integer funcname -> integer count = 0
{
	if(functions.value.Name == funcname)
	{
		count = CountUnresolvedParameters(functions.value.Params)
	}
	else
	{
		count = GetFunctionParameterCount(functions.next, funcname)
	}
}

GetFunctionParameterCount : nothing, integer funcname -> integer count = -1
{
	string readablename = GetPooledString(GlobalStrings, funcname)
	if(readablename == "substring@@withlength")
	{
		count = 3
	}
	elseif(readablename == "substring@@nolength")
	{
		count = 2
	}
}


IsFunctionTemplate : list<FunctionDefinition> ref functions, integer funcname -> boolean istemplate = false
{
	if(functions.value.Name == funcname)
	{
		istemplate = functions.value.IsTemplate
	}
	else
	{
		istemplate = IsFunctionTemplate(functions.next, funcname)
	}
}

IsFunctionTemplate : nothing, integer funcname -> false


CountUnresolvedParameters : FunctionParams ref params -> integer count = CountUnresolvedParametersUnwrapped(params.Params)
CountUnresolvedParameters : nothing -> 0

CountUnresolvedParametersUnwrapped : list<UnresolvedParameter> ref params -> integer count = 0
{
	if(params.value.NameHandle != 0)
	{
		 ++count
	}
	elseif(GetOptionalExpressionType(params.value.PatternMatchValue) != 0)
	{
		++count
	}
	
	count += CountUnresolvedParametersUnwrapped(params.next)
}

CountUnresolvedParametersUnwrapped : nothing -> 0


CheckForNeededTypeMatcher : simplelist<integer> ref types -> boolean needsmatcher = false
{
	if((types.value & 0x7f000000) == 0x07000000)
	{
		needsmatcher = true
	}
	else
	{
		needsmatcher = CheckForNeededTypeMatcher(types.next)
	}
}

CheckForNeededTypeMatcher : nothing -> false


FindOverloadWithParameterTypes : nothing, integer rawname, simplelist<integer> ref types -> integer overloadname = 0
{
	string readablename = GetPooledString(GlobalStrings, rawname)
	if(readablename == "substring")
	{
		integer withlen = PoolString("substring@@withlength")
		integer nolen = PoolString("substring@@nolength")
		
		if(FunctionMatchesParameterTypes(nothing, withlen, types))
		{
			overloadname = withlen
		}
		elseif(FunctionMatchesParameterTypes(nothing, nolen, types))
		{
			overloadname = nolen
		}
	}
	else
	{
		if(ConstructorMatchesParameterTypes(Structures, rawname, types))
		{
			overloadname = rawname
		}
		elseif((!StructureConstructorExists(Structures, rawname)) && (!FunctionExists(Functions, rawname)))
		{
			overloadname = rawname
		}
	}
}


FunctionMatchesParameterTypes : list<FunctionDefinition> ref functions, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	if(functions.value.Name == funcname)
	{
		match = CheckParameterTypesForMatch(functions.value.Params, types)
	}
	else
	{
		match = FunctionMatchesParameterTypes(functions.next, funcname, types)
	}
}

FunctionMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	string readablename = GetPooledString(GlobalStrings, funcname)
	if(readablename == "substring@@withlength")
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(readablename == "substring@@nolength")
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	else
	{
		match = ConstructorMatchesParameterTypes(Structures, funcname, types)
	}
}


ConstructorMatchesParameterTypes : list<StructureDefinition> ref structures, integer ctorname, simplelist<integer> ref types -> boolean match = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}
		
		match = CheckMemberTypes(structures.value.Members, types.next)
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		match = CheckMemberTypes(structures.value.Members, types)
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}
		
		match = CheckCopyType(types.next, structures.value.Type)
	}
	else
	{
		match = ConstructorMatchesParameterTypes(structures.next, ctorname, types)
	}
}

ConstructorMatchesParameterTypes : nothing, integer ctorname, simplelist<integer> ref types -> false


CheckCopyType : simplelist<integer> ref a, integer b -> boolean match = (a.value == b)


CheckParameterTypesForMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	integer count = countnonzero(types)
	if(count == 0)
	{
		match = true
	}
	elseif(count == 1)
	{
		if(types.value == 0x00000002)		// void type signature
		{
			match = true
		}
	}
}

CheckParameterTypesForMatch : FunctionParams ref params, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(params.Params, types)

CheckParameterTypesForMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	if(!ResolvedTypesMatch(params, types))
	{
		match = false
	}
}

CheckParameterTypesForMatch : simplelist<integer> ref atypes, simplelist<integer> ref btypes -> boolean match = TypesMatch(atypes, btypes)


TypesMatch : simplelist<integer> ref a, simplelist<integer> ref b -> boolean match = true
{
	if(a.value != b.value)
	{
		match = false
	}
	else
	{
		match = TypesMatch(a.next, b.next)
	}
}

TypesMatch : nothing, nothing -> true

TypesMatch : nothing, simplelist<integer> ref b -> boolean match = (b.value == 0)
TypesMatch : simplelist<integer> ref a, nothing -> boolean match = (a.value == 0)



ResolvedTypesMatch : nothing, nothing -> true

ResolvedTypesMatch : list<UnresolvedParameter> ref params, nothing -> false
ResolvedTypesMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}

ResolvedTypesMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	integer resolved = params.value.ResolvedType
	while((resolved & 0x7f000000) == 0x05000000)
	{
		resolved = FindTypeAliasBase(TypeAliases, resolved)
	}

	integer expected = types.value
	while((expected & 0x7f000000) == 0x0500000)
	{
		expected = FindTypeAliasBase(TypeAliases, expected)
	}

	if(resolved != expected)
	{
		match = false
	}
	else
	{
		listnode<UnresolvedParameter> n = params.next
		simplelistnode<integer> nt = types.next
		match = ResolvedTypesMatch(n, nt)			// TODO - this is some kind of compiler bug... or maybe a runtime bug?!
	}
}


GetAssignmentRHSType : Expression ref expr -> integer rettype = expr.Type
GetAssignmentRHSType : Assignment ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)
GetAssignmentRHSType : AssignmentCompound ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)


TypeInference : Assignment ref assignment, InferenceContext ref context -> boolean success = true
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(context.ScopeName, assignment.LHSName, var)

	simplelist<integer> temp = var.VarType, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}
		
	assignment.LHSType = var.VarType
	
	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?
		
		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}
	
	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : AssignmentCompound ref assignment, InferenceContext ref context -> boolean success = true
{
	integer hack = context.ScopeName
	integer lhstype = ComputeCompoundAssignmentLHSType(assignment, hack)
	
	simplelist<integer> temp = lhstype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}
	
	assignment.LHSType = lhstype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?
		
		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}
	
	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : EntityChain ref chain, InferenceContext ref context -> boolean success = TypeInference(chain.Entries, context)

TypeInference : EntityList ref entities, InferenceContext ref context -> boolean success = TypeInference(entities.ActualList, context)

TypeInference : list<Entity> ref entities, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(entities.value, context))
	{
		success = false
	}
	
	if(!TypeInference(entities.next, context))
	{
		success = false
	}
}

TypeInference : Entity ref entity, InferenceContext ref context -> boolean success = true
{
	simplelist<integer> temp = 0x01000003, nothing			// TODO - don't assume all entities take a boolean!
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false
	
	if(!TypeInference(entity.Param, newcontext))
	{
		success = false
	}
	
	if(!TypeInference(entity.Code, context))
	{
		success = false
	}
}


TypeInference : ExpressionList ref parameters, InferenceContext ref context -> boolean success = true
{
	if(!TypeInferenceExpressionList(parameters.Expressions, context, 0))
	{
		success = false
	}
}

TypeInferenceExpressionList : list<Expression> ref parameters, InferenceContext ref context, integer paramindex -> boolean success = true
{
	simplelist<integer> temp = 0, nothing
	GetExpectedParameterTypes(context.StatementName, paramindex, context.NumParameters, context.TopLevelStatement, temp)
	InferenceContext newcontext = context.ScopeName, context.StatementName, temp, context.FunctionReturn, context.NumParameters, context.TopLevelStatement

	if(!TypeInference(parameters.value, newcontext))
	{
		print("Parameter " ; cast(string, paramindex) ; " failed type inference!")	
		success = false
	}
	else
	{
		context.StatementName = newcontext.StatementName
	}

	if(!TypeInferenceExpressionList(parameters.next, context, paramindex + 1))
	{
		success = false
	}
}

TypeInferenceExpressionList : nothing, InferenceContext ref context, integer paramindex -> boolean success = true


TypeInference : Expression ref expression, InferenceContext ref context -> boolean success = true
{
	if(expression.Type != 0)
	{
		return()
	}

	if(ExpressionAtomIsSentinel(expression.Atoms.value))
	{
		expression.Type = 0x00000002
		return()
	}
	
	CoalesceMemberAccesses(expression.Atoms, context.ScopeName)
	ShuntingYard(expression.Atoms)

	InferencePossibility temp = scratchpossibility
	list<InferencePossibility> possibilities = temp, nothing
	ExpressionInferenceStackEntry stackentry = possibilities
	list<ExpressionInferenceStackEntry> stack = stackentry, nothing

	integer counter = 0
	integer scopename = context.ScopeName
		
	boolean flag = context.FunctionReturn		// TODO - stupid workaround for a compiler bug
	WalkAtomsForType(expression.Atoms, expression.Atoms.next, stack, counter, scopename, flag)
		
	integer possibilitycount = CountPossibilities(stack.value.PossibilityList)
	if(possibilitycount == 1)
	{
		if((!context.FunctionReturn) && (context.StatementName != 0))
		{
			simplelist<integer> types = 0, nothing
			EliminateImpossibleType(stack.value.PossibilityList.value.ReturnType.Types, context.ExpectedTypes, types)

			integer typecount = countnonzero(types)
			if(typecount == 1)
			{
				assert(types.value != 0)
				expression.Type = types.value
			}
			elseif(typecount > 1)
			{
				print("Multiple types possible:")
				DumpTypeList(types)
			}
			else
			{
				// TODO - demotion logic here is MESSY
				if((countnonzero(stack.value.PossibilityList.value.ReturnType.Types) == 1) && (countnonzero(context.ExpectedTypes) == 1) && (stack.value.PossibilityList.value.ReturnType.Types.value == 0x01000001) && (context.ExpectedTypes.value == 0x01000002))
				{
					expression.Type = 0x01000002
				}
				else
				{
					print("All types ruled out")
					DumpTypeList(stack.value.PossibilityList.value.ReturnType.Types)
					print("Expected types are")
					DumpTypeList(context.ExpectedTypes)
				}
			}
		}
		else
		{
			simplelist<integer> possibletypes = 0, nothing
			FilterTypesForDemotion(stack.value.PossibilityList.value.ReturnType.Types, possibletypes)
			
			integer typecount = countnonzero(possibletypes)
			if(typecount == 1)
			{
				expression.Type = possibletypes.value
				assert(expression.Type != 0)
			}
			elseif(context.FunctionReturn)
			{
				print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
				DumpTypeList(possibletypes)
			}
			else
			{
				print("Expression has " ; cast(string, typecount) ; " types possible")
				DumpTypeList(possibletypes)
			}
		}
	}
	else
	{
		// TODO - error context!
		if(possibilitycount > 0)
		{
			print("Multiple overloads possible:")
			DumpOverloadList(stack.value.PossibilityList)
		}
		else
		{
			print("No types possible in this expression:")
			DumpExpressionAtoms(expression.Atoms)
			print("End expression")
		}
	}

	if(expression.Type == 0)
	{
		success = false
	}
	elseif(expression.Type == 0x01000002)
	{
		DemoteAtomType(expression.Atoms)
	}
	elseif((expression.Type & 0x7f000000) == 0x09000000)
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
	elseif(IsStructureType(expression.Type))
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
}


CountPossibilities : list<InferencePossibility> ref thelist -> integer count = 0
{
	count = CountPossibilities(thelist.next)

	if(thelist.value.FunctionName != 0)
	{
		++count
	}
}

CountPossibilities : nothing -> 0


countnonzero : simplelist<integer> ref thelist -> integer count = 0
{
	count = countnonzero(thelist.next)

	if(thelist.value != 0)
	{
		++count
	}
}

countnonzero : nothing -> 0


SetAtomType : IdentifierAtom ref atom, integer typeid
{
	atom.Type = typeid
}

SetAtomType : CompoundAtom ref atom, integer typeid
{
	atom.Type = typeid
}

SetAtomType : Statement ref atom, integer typeid


WalkAtomsForType : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, integer funcname, boolean funcret -> boolean demotedtoright = false
{
	boolean didrightdemote = WalkAtomsForType(tail, tail.next, stack, counter, funcname, funcret)
	boolean unarycompensate = false
	
	if(IsOperatorInvoke(tail.value))
	{
		if(IsUnaryOperator(tail.value))
		{
			SetOperatorAtomToOverload(tail, stack.value.PossibilityList.value.FunctionName, 0)
			unarycompensate = true
		}
	}

	if(IsOperatorInvoke(atoms.value))
	{
		if(counter > 0)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter + 1)
			--counter
		}
		
		list<InferencePossibility> possibleoperators = scratchpossibility, nothing
		GetAtomTypeOperator(atoms.value, possibleoperators)
		
		ExpressionInferenceStackEntry entry = possibleoperators
		prepend<ExpressionInferenceStackEntry>(stack, entry)
	}
	else
	{
		list<InferencePossibility> out = scratchpossibility, nothing
		EliminateImpossibleParametersForAllOverloads(stack.value.PossibilityList, out, atoms.value, funcname, funcret)
				
		if(counter == 1)
		{
			list<InferencePossibility> filtered = scratchpossibility, nothing
			FilterOverloadsForTypeDemotion(out, filtered)
			stack.value.PossibilityList = filtered
		}
		else
		{
			stack.value.PossibilityList = out
		}
		
		if(CountPossibilities(stack.value.PossibilityList) == 1)
		{
			if(listcontains(stack.value.PossibilityList.value.ParameterTypes.value.Types, 0x01000002))
			{
				DemoteAtomType(atoms)
				demotedtoright = true
				
				if((!didrightdemote) && (!IsOperatorInvoke(tail.value)))
				{
					DemoteAtomType(tail)
				}
			}
		}
		elseif(didrightdemote)
		{
			DemoteAtomType(atoms)
		}
		
		++counter
		if(counter > 1)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter)
			++counter
		}
	
		if(AllOptionsConsumed(stack.value.PossibilityList.value.ParameterTypes))
		{
			TypePossibilityList rettypes = stack.value.PossibilityList.value.ReturnType
			rettypes.Consumed = true
			PopExpressionInferenceStack(stack, stack.next)			
			AddPossibleParamTypeForAllOverloads(stack.value.PossibilityList, rettypes)			
		}
	}
	
	if(unarycompensate)
	{
		++counter
	}	
}


AddPossibleParamTypeForAllOverloads : list<InferencePossibility> ref possibilities, TypePossibilityList ref paramtypes
{
	prepend<TypePossibilityList>(possibilities.value.ParameterTypes, paramtypes)

	AddPossibleParamTypeForAllOverloads(possibilities.next, paramtypes)
}

AddPossibleParamTypeForAllOverloads : nothing, TypePossibilityList ref paramtypes


AllOptionsConsumed : list<TypePossibilityList> ref options -> boolean allconsumed = true
{
	if((!options.value.Consumed) && (countnonzero(options.value.Types) > 0))
	{
		allconsumed = false
	}
	else
	{
		allconsumed = AllOptionsConsumed(options.next)
	}
}

AllOptionsConsumed : nothing -> true


PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail
{
	stack = tail
}

PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, nothing


WalkAtomsForType : list<ExpressionAtom> ref atoms, nothing, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, integer funcname, boolean funcret -> false
{
	if(IsOperatorInvoke(atoms.value))
	{
		GetAtomTypeOperator(atoms.value, stack.value.PossibilityList)
	}
	else
	{
		TypePossibilityList poss = scratchparams
		GetAtomType(atoms.value, poss, funcname, funcret)

		InferencePossibility newpossibility = -1, scratchparampossibles, poss
		prepend<InferencePossibility>(stack.value.PossibilityList, newpossibility)
	}
}


EliminateImpossibleParametersForAllOverloads : list<InferencePossibility> ref possibilities, list<InferencePossibility> ref out, ExpressionAtom ref atom, integer funcname, boolean funcret
{
	if(possibilities.value.FunctionName != 0)
	{
		if(EliminateImpossibleParameters(possibilities.value.ParameterTypes, atom, funcname, funcret))
		{
			prepend<InferencePossibility>(out, possibilities.value)
		}
	}
	
	EliminateImpossibleParametersForAllOverloads(possibilities.next, out, atom, funcname, funcret)
}

EliminateImpossibleParametersForAllOverloads : nothing, list<InferencePossibility> ref out, ExpressionAtom ref atom, integer funcname, boolean funcret


EliminateImpossibleParameters : list<TypePossibilityList> ref params, ExpressionAtom ref atom, integer funcname, boolean funcret -> boolean valid = true
{
	if(!params.value.Consumed)
	{
		TypePossibilityList poss = scratchparams
		GetAtomType(atom, poss, funcname, funcret)
		
		simplelist<integer> types = 0, nothing
		EliminateImpossibleType(params.value.Types, poss.Types, types)
				
		if(countnonzero(types) == 0)
		{
			valid = false
		}
		
		params.value.Types = types
		params.value.Consumed = true
	}
	else
	{
		if(!EliminateImpossibleParameters(params.next, atom, funcname, funcret))
		{
			valid = false
		}
	}
}


EliminateImpossibleParameters : nothing, ExpressionAtom ref atom, integer funcname, boolean funcret -> true


SetOperatorAtomToOverload : list<ExpressionAtom> ref atoms, integer overloadname, integer count
{
	if(count == 0)
	{
		if(!IsOperatorInvoke(atoms.value))
		{
			print("Internal error: operator " ; GetPooledString(GlobalStrings, overloadname) ; " cannot be placed in expression")
			DumpAtom(atoms.value)
			assert(false)
		}
		
		ChangeOperator(atoms.value, overloadname)
	}
	else
	{
		SetOperatorAtomToOverload(atoms.next, overloadname, count - 1)
	}
}

ChangeOperator : OperatorInvokeAtom ref atom, integer overloadname
{
	atom.OperatorName = overloadname
}



EliminateImpossibleType : simplelist<integer> ref possibles, simplelist<integer> ref filter, simplelist<integer> ref out
{
	EliminateImpossibleType(possibles.next, filter, out)
	
	if(possibles.value != 0)
	{
		integer expectedtype = TypeListContains(filter, possibles.value)
		if(expectedtype != 0)
		{
			simpleprepend<integer>(out, expectedtype)
		}
	}
}

EliminateImpossibleType : nothing, simplelist<integer> ref filter, simplelist<integer> ref out


GetAtomType : AtomSentinel       ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x00000002) }	// void magic
GetAtomType : StringHandleAtom   ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x02000000) }
GetAtomType : TypeAnnotationAtom ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000001) }
GetAtomType : integer16          ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000002) }
GetAtomType : boolean            ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000003) }
GetAtomType : real               ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000004) }

GetAtomType : integer            ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{
	AddPossibleParameter(possibilities.Types, 0x01000001)
	AddPossibleParameter(possibilities.Types, 0x01000002)			// Allow demotion later
}

GetAtomType : CompoundAtom       ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, atom.Type)  }

GetAtomType : Statement ref statement, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{	
	simplelist<integer> temp = 0, nothing
	InferenceContext newcontext = funcname, statement.Name, temp, funcret, 0, false
	
	if(TypeInference(statement, newcontext))
	{
		AddPossibleParameter(possibilities.Types, statement.Type)
	}
}

GetAtomType : RefBinding ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret

GetAtomType : ParentheticalExpression ref parenthetical, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{
	simplelist<integer> temp = 0, nothing
	InferenceContext newcontext = funcname, 0, temp, funcret, 0, false
		
	if(TypeInference(parenthetical.Inner, newcontext))
	{
		AddPossibleParameter(possibilities.Types, GetParentheticalType(parenthetical.Inner))
	}
	else
	{
		print("Parenthetical expression failed type inference")
	}
}

GetParentheticalType : PreOpStatement ref statement -> integer rettype = statement.Type
GetParentheticalType : PostOpStatement ref statement -> integer rettype = statement.Type
GetParentheticalType : Expression ref expr -> integer rettype = expr.Type

GetAtomTypeOperator : OperatorInvokeAtom ref atom, list<InferencePossibility> ref possibilities
{
	AddPossibilityPerOperatorOverload(atom.OperatorName, possibilities)
}

GetAtomType : IdentifierAtom ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{	
	if(GetPooledString(GlobalStrings, atom.Handle) == "nothing")
	{
		atom.Type = 0x00000004
		AddPossibleParameter(possibilities.Types, 0x00000004)
		return()
	}

	AddPossibleParameter(possibilities.Types, 0x01000000)
	
	if(GetTypeByName(atom.Handle) != 0)
	{
		return()
	}
	

	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(funcname, atom.Handle, var)
	if(var.Name != 0)
	{
		AddPossibleParameter(possibilities.Types, var.VarType)
	}
	else
	{
		if(FunctionExists(Functions, atom.Handle))
		{
			// TODO - overload resolution on higher order function name
			integer sigtype = FindFunctionAndGetSignatureType(Functions, atom.Handle)
			AddPossibleParameter(possibilities.Types, sigtype)
		}
		else
		{
			integer sigtype = FindBuiltinAndGetSignatureType(atom.Handle)
			if(sigtype != 0)
			{
				AddPossibleParameter(possibilities.Types, sigtype)
			}
			else
			{
				print(GetPooledString(GlobalStrings, atom.Handle) ; " is not a defined identifier!")
			}
		}
	}
}


IsOperatorInvoke : OperatorInvokeAtom 	   ref nonsentinel -> true

IsOperatorInvoke : AtomSentinel 	   ref sentinel    -> false
IsOperatorInvoke : StringHandleAtom 	   ref nonsentinel -> false
IsOperatorInvoke : IdentifierAtom 	   ref nonsentinel -> false
IsOperatorInvoke : TypeAnnotationAtom 	   ref nonsentinel -> false
IsOperatorInvoke : integer 		   ref nonsentinel -> false
IsOperatorInvoke : integer16 		   ref nonsentinel -> false
IsOperatorInvoke : boolean 		   ref nonsentinel -> false
IsOperatorInvoke : real 		   ref nonsentinel -> false
IsOperatorInvoke : Statement		   ref nonsentinel -> false
IsOperatorInvoke : RefBinding              ref nonsentinel -> false
IsOperatorInvoke : CompoundAtom		   ref nonsentinel -> false
IsOperatorInvoke : ParentheticalExpression ref nonsentinel -> false


IsMemberAccessOperator : OperatorInvokeAtom 	 ref nonsentinel -> boolean ismemberaccess = false
{
	if(GetPooledString(GlobalStrings, nonsentinel.OperatorName) == ".")
	{
		ismemberaccess = true
	}
}

IsMemberAccessOperator : AtomSentinel 	   	 ref sentinel    -> false
IsMemberAccessOperator : StringHandleAtom 	 ref nonsentinel -> false
IsMemberAccessOperator : IdentifierAtom 	 ref nonsentinel -> false
IsMemberAccessOperator : TypeAnnotationAtom 	 ref nonsentinel -> false
IsMemberAccessOperator : integer 		 ref nonsentinel -> false
IsMemberAccessOperator : integer16 		 ref nonsentinel -> false
IsMemberAccessOperator : boolean 		 ref nonsentinel -> false
IsMemberAccessOperator : real 		   	 ref nonsentinel -> false
IsMemberAccessOperator : Statement		 ref nonsentinel -> false
IsMemberAccessOperator : RefBinding              ref nonsentinel -> false
IsMemberAccessOperator : CompoundAtom            ref nonsentinel -> false
IsMemberAccessOperator : ParentheticalExpression ref nonsentinel -> false



MarkAtomAsReference : OperatorInvokeAtom      ref atom -> false
MarkAtomAsReference : AtomSentinel 	      ref atom -> false
MarkAtomAsReference : StringHandleAtom 	      ref atom -> false
MarkAtomAsReference : TypeAnnotationAtom      ref atom -> false
MarkAtomAsReference : integer 		      ref atom -> false
MarkAtomAsReference : integer16               ref atom -> false
MarkAtomAsReference : boolean 		      ref atom -> false
MarkAtomAsReference : real 		      ref atom -> false
MarkAtomAsReference : Statement		      ref atom -> false
MarkAtomAsReference : ParentheticalExpression ref atom -> false

MarkAtomAsReference : RefBinding              ref atom -> true

MarkAtomAsReference : IdentifierAtom          ref atom -> true
{
	atom.IsReference = true
}

MarkAtomAsReference : CompoundAtom            ref atom -> true
{
	atom.Type = MakeReferenceType(atom.Type)
}


AddPossibleParameter : simplelist<integer> ref possibilities, integer paramtype
{
	simpleprepend<integer>(possibilities, paramtype)
	
	if((paramtype & 0x7f000000) == 0x05000000)
	{
		simpleprepend<integer>(possibilities, FindTypeAliasBase(TypeAliases, paramtype))
	}
}

AddBinaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer param2type, integer rettype
{
	assert(functionname != 0)

	simplelist<integer> p1t = param1type, nothing
	simplelist<integer> p2t = param2type, nothing

	TypePossibilityList param1options = p1t, false
	TypePossibilityList param2options = p2t, false

	list<TypePossibilityList> paramtypes = scratchparams, nothing
	prepend<TypePossibilityList>(paramtypes, param2options)
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}

AddUnaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer rettype
{
	assert(functionname != 0)

	simplelist<integer> p1t = param1type, nothing

	TypePossibilityList param1options = p1t, false

	list<TypePossibilityList> paramtypes = scratchparams, nothing
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}


ShuntingYard : list<ExpressionAtom> ref atoms
{
	AtomSentinel sentinel = 0

	list<ExpressionAtom> outputqueue = sentinel, nothing
	list<ExpressionAtom> opstack = sentinel, nothing

	ShuntingYardWalk(atoms, outputqueue, opstack)
	ShuntingYardFlush(outputqueue, opstack)

	atoms = outputqueue
}

ShuntingYardWalk : nothing, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack

ShuntingYardWalk : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	ShuntingYardVisit(atoms.value, outputqueue, opstack)
	ShuntingYardWalk(atoms.next, outputqueue, opstack)
}

ShuntingYardVisit : AtomSentinel            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
ShuntingYardVisit : StringHandleAtom        ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : IdentifierAtom          ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : TypeAnnotationAtom      ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer16               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : boolean                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : real                    ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : Statement               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : RefBinding              ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : ParentheticalExpression ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : CompoundAtom            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }

ShuntingYardVisit : OperatorInvokeAtom ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	integer opprec = GetOperatorPrecedence(atom)
	boolean continueops = true

	while(continueops && (!ExpressionAtomIsSentinel(opstack.value)))
	{
		ExpressionAtom opatom2 = opstack.value
		integer op2prec = GetOperatorPrecedence(opatom2)

		// TODO - this whole section is hacky. Replace with break() calls and >= operator.

		if(IsUnaryOperator(atom))
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
			elseif(opprec == op2prec)
			{
				continueops = false
			}
		}
		else
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
		}

		if(continueops)
		{
			PlaceAtomInList(outputqueue, opatom2)
			ShuntingYardPopStack(opstack, opstack.next)
		}
	}

	ExpressionAtom wrap = atom
	prepend<ExpressionAtom>(opstack, wrap)
}

ShuntingYardFlush : list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	while(!ExpressionAtomIsSentinel(opstack.value))
	{
		PlaceAtomInList(outputqueue, opstack.value)
		ShuntingYardPopStack(opstack, opstack.next)
	}
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, list<ExpressionAtom> ref tail
{
	opstack = tail
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, nothing
{
	AtomSentinel sentinel = 0
	list<ExpressionAtom> newlist = sentinel, nothing
	opstack = newlist
}


IsUnaryOperator : OperatorInvokeAtom ref atom -> boolean isunary = false
{
	string basename = GetPooledString(GlobalStrings, atom.OperatorName)
	if(basename == "!")
	{
		isunary = true
	}
}


GetOperatorPrecedence : OperatorInvokeAtom ref atom -> integer precedence = 0
{
	string basename = GetPooledString(GlobalStrings, atom.OperatorName)
	if(basename == "==")
	{
		precedence = 0
	}
	elseif(basename == "!=")
	{
		precedence = 0
	}
	elseif(basename == ">")
	{
		precedence = 0
	}
	elseif(basename == "<")
	{
		precedence = 0
	}
	elseif(basename == "&&")
	{
		precedence = 0
	}
	elseif(basename == "&")
	{
		precedence = 1		// TODO - revisit all operator precedences
	}
	elseif(basename == ";")
	{
		precedence = 3
	}
	elseif(basename == "+")
	{
		precedence = 5
	}
	elseif(basename == "-")
	{
		precedence = 5
	}
	elseif(basename == "*")
	{
		precedence = 9
	}
	elseif(basename == "/")
	{
		precedence = 9
	}
	elseif(basename == "!")
	{
		precedence = 10
	}
	elseif(basename == ".")
	{
		precedence = 11
	}
	else
	{
		print("Unknown operator " ; basename)
		assert(false)
	}
}


ConstructVariableFromStatement : Statement ref statement, integer scopename, integer vartype, integer origin
{
	integer varname = ExtractConstructorIdentifier(statement.Parameters)
		
	if(varname != 0)
	{	
		// TODO - this is a HACK to bypass shadowing checks. We should check for actual variable shadowing instead.
		Variable var = 0, 0, 0, 0
		FindVariableDataInScope(scopename, varname, var)
		if(var.Name != 0)
		{
			return()
		}
		
		StoreVariableInScope(Scopes, scopename, varname, vartype, false, origin)
	}
}

ExtractConstructorIdentifier : ExpressionList ref parameters -> integer varname = ExtractConstructorIdentifier(parameters.Expressions)
ExtractConstructorIdentifier : list<Expression> ref parameters -> integer varname = ExtractIdentifier(parameters.value)
ExtractConstructorIdentifier : nothing -> 0

ExtractIdentifier : Expression ref expression -> integer id = ExtractIdentifier(expression.Atoms.value)

ExtractIdentifier : IdentifierAtom ref atom -> atom.Handle
{
	atom.Type = 0x81000000		// HACK - reference to identifier
}

ExtractIdentifier : AtomSentinel 	    ref sentinel    -> 0
ExtractIdentifier : StringHandleAtom 	    ref nonsentinel -> 0
ExtractIdentifier : OperatorInvokeAtom 	    ref nonsentinel -> 0
ExtractIdentifier : TypeAnnotationAtom 	    ref nonsentinel -> 0
ExtractIdentifier : integer 		    ref nonsentinel -> 0
ExtractIdentifier : integer16 		    ref nonsentinel -> 0
ExtractIdentifier : boolean 		    ref nonsentinel -> 0
ExtractIdentifier : real 		    ref nonsentinel -> 0
ExtractIdentifier : Statement		    ref nonsentinel -> 0
ExtractIdentifier : RefBinding              ref nonsentinel -> 0
ExtractIdentifier : CompoundAtom            ref nonsentinel -> 0
ExtractIdentifier : ParentheticalExpression ref nonsentinel -> 0


PlaceAtomInList : list<ExpressionAtom> ref atoms, ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(atoms.value))
	{
		list<ExpressionAtom> newatoms = atom, nothing
		atoms = newatoms
	}
	else
	{
		AppendAtomToExpression(atoms, atoms.next, atom)
	}
}



IRValidate : -> true



PoolString : string s -> integer handle = FindString(GlobalStrings, s)
{
	if(handle == 0)
	{
		++CurrentStringHandle
		OnCodeGenRegisterString(CurrentStringHandle, s)
		handle = CurrentStringHandle
	}
}



IREnterProgram :
{
}

IRExitProgram :
{
}


IREnterFunction : integer namehandle
{
	OnCodeGenRegisterScope(namehandle, 0)
}

IRExitFunction :
{
	OnCodeGenExitContext()
}

IREnterCodeBlock :
{
	// TODO
}

IRExitCodeBlock :
{
	//OnCodeGenExitContext()
}


IREnterStatement : string funcname, boolean istoplevel, boolean hastemplateargs
{
	integer namehandle = PoolString(funcname)
	OnCodeGenEnterStatement(namehandle, 0, istoplevel, hastemplateargs)
}

IRExitStatement :
{
	OnCodeGenExitContext()
}


IRAddOperator : string operatorname
{
	OnCodeGenRegisterOperatorInvoke(PoolString(operatorname))
}

IRAddLiteralString : string literal
{
	OnCodeGenRegisterLiteralString(PoolString(literal))
}

IRAddLiteralBoolean : boolean literal
{
	OnCodeGenRegisterLiteralBoolean(literal)
}

IRAddLiteralReal : real literal
{
	OnCodeGenRegisterLiteralReal(literal)
}

IRAddLiteralInteger : integer literal
{
	OnCodeGenRegisterLiteralInteger(literal, 0x01000001)		// We can demote the integer later
}

IRAddLiteralIdentifier : string token
{
	OnCodeGenRegisterAtomIdentifier(PoolString(token), 0)
}



GetPooledString : list<StringTableEntry> ref strings, integer handle -> string pooled = "" [nogc]
{
	if(strings.value.Handle == handle)
	{
		pooled = strings.value.Data
	}
	else
	{
		pooled = GetPooledString(strings.next, handle)
	}
}

GetPooledString : nothing, integer handle -> "" [nogc]
{
	print("String handle not pooled: " ; cast(string, handle))
	assert(false)
}


DumpAtom : AtomSentinel 	   ref sentinel    { print("Sentinel") }
DumpAtom : StringHandleAtom 	   ref nonsentinel { print("String handle " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : IdentifierAtom 	   ref nonsentinel { print("Identifier " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : OperatorInvokeAtom 	   ref nonsentinel { print("Operator " ; cast(string, nonsentinel.OperatorName)) }
DumpAtom : TypeAnnotationAtom 	   ref nonsentinel { print("Type annotation") }
DumpAtom : integer 		   ref nonsentinel { print("integer " ; cast(string, nonsentinel)) }
DumpAtom : integer16 		   ref nonsentinel { print("integer16") }
DumpAtom : boolean 		   ref nonsentinel { print("boolean") }
DumpAtom : real 		   ref nonsentinel { print("real " ; cast(string, nonsentinel)) }
DumpAtom : RefBinding              ref nonsentinel { print("RefBinding") }
DumpAtom : ParentheticalExpression ref nonsentinel { print("Parenthetical") }
DumpAtom : CompoundAtom            ref nonsentinel { print("Compound") }

DumpAtom : Statement		   ref nonsentinel
{
	print("Statement")
	print("BEGIN PARAMS")
	DumpParameterAtoms(nonsentinel.Parameters)
	print("END PARAMS")
}

DumpExpressionAtoms : list<ExpressionAtom> ref atoms
{
	DumpAtom(atoms.value)
	DumpExpressionAtoms(atoms.next)
}

DumpExpressionAtoms : nothing


DumpExpressionList : list<Expression> ref exprs
{
	print("BEGIN EXPR")
	DumpExpressionAtoms(exprs.value.Atoms)
	print("END EXPR")

	DumpExpressionList(exprs.next)
}

DumpExpressionList : nothing


DumpParameterAtoms : ExpressionList ref exprs
{
	DumpExpressionList(exprs.Expressions)
}

DumpParameterAtoms : nothing



AddPossibilityPerOperatorOverload : integer basenamehandle, list<InferencePossibility> ref possibilities
{
	string basename = GetPooledString(GlobalStrings, basenamehandle)
	if(basename == "==")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@integer"),   0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@integer16"), 0x01000002, 0x01000002, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@boolean"),   0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@real"),      0x01000004, 0x01000004, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@string"),    0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basename == "!=")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "!=@@integer"), 0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "!=@@boolean"), 0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "!=@@string"),  0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basename == ">")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, ">@@integer"), 0x01000001, 0x01000001, 0x01000003)
	}
	elseif(basename == "<")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "<@@integer"), 0x01000001, 0x01000001, 0x01000003)
	}	
	elseif(basename == "+")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "+@@integer"), 0x01000001, 0x01000001, 0x01000001)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "+@@real"), 0x01000004, 0x01000004, 0x01000004)
	}
	elseif(basename == "-")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "-@@integer"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == "*")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "*@@integer"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == "/")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "/@@integer"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == "&")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "&"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == "&&")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "&&"), 0x01000003, 0x01000003, 0x01000003)
	}
	elseif(basename == ";")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, ";"), 0x02000000, 0x02000000, 0x02000000)
	}
	elseif(basename == "!")
	{
		AddUnaryPossibility(possibilities, FindString(GlobalStrings, "!@@boolean"), 0x01000003, 0x01000003)
	}
	else
	{
		print("Unrecognized operator")
		assert(false)
	}
}


GetExpectedParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(Functions, funcname, paramindex, paramcount, toplevel, types)
	
	EnumerateOverloadsAndAddParameterTypes(Overloads, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : list<Overload> ref overloads, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(overloads.value.NormalName == funcname)
	{
		FindFunctionAndAddParameterTypes(Functions, overloads.value.MangledName, paramindex, paramcount, toplevel, types)
	}
	
	EnumerateOverloadsAndAddParameterTypes(overloads.next, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types


FindFunctionAndAddParameterTypes : list<FunctionDefinition> ref functions, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(functions.value.Name == funcname)
	{
		if(!functions.value.InferenceDone)
		{
			simplelist<integer> temp = 0, nothing
			InferenceContext context = 0, 0, temp, false, 0, false
			
			TypeInference(functions.value, context)
		}
		
		UnwrapParamsForTypeRetrieval(functions.value.Params, paramindex, paramcount, types)
	}
	else
	{
		FindFunctionAndAddParameterTypes(functions.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindFunctionAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(StructureConstructorExists(Structures, funcname))
	{
		FindConstructorAndAddParameterTypes(Structures, funcname, paramindex, paramcount, toplevel, types)
	}
	else
	{
		FindBuiltinAndAddParameterTypes(funcname, paramindex, paramcount, types)
	}
}

UnwrapParamsForTypeRetrieval : FunctionParams ref params, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveParamType(params.Params, paramindex, types)
	}
}

UnwrapParamsForTypeRetrieval : nothing, integer paramindex, integer paramcount, simplelist<integer> ref types


RetrieveParamType : list<UnresolvedParameter> ref params, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{	
		simpleprepend<integer>(types, params.value.ResolvedType)
		return()
	}
	
	RetrieveParamType(params.next, paramindex - 1, types)
}

RetrieveParamType : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many parameters to call!")
	assert(false)
}


GetFunctionReturnType : list<FunctionDefinition> ref functions, integer funcname -> integer rettype = 0
{
	if(functions.value.Name == funcname)
	{
		if(!functions.value.InferenceDone)
		{
			simplelist<integer> temp = 0, nothing
			InferenceContext context = 0, 0, temp, false, 0, false

			TypeInference(functions.value, context)
		}

		rettype = GetOptionalExpressionType(functions.value.Return)
	}
	else
	{
		rettype = GetFunctionReturnType(functions.next, funcname)
	}
}

GetFunctionReturnType : nothing, integer funcname -> integer rettype = GetPendingTypeMatcherReturnType(PendingTypeMatchers, funcname)


GetOptionalExpressionType : Expression ref expr -> expr.Type
GetOptionalExpressionType : nothing -> 0


FindBuiltinAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	integer ctype = GetTypeByName(funcname)
	if((ctype & 0xff000000) == 0x05000000)
	{
		funcname = GetNameOfType(FindTypeAliasBase(TypeAliases, ctype))
	}

	if((ctype & 0xff000000) == 0x07000000)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				FindSumTypeAndPrependTypesToList(SumTypes, ctype, types)
			}
		}
		return()
	}

	string readablename = GetPooledString(GlobalStrings, funcname)
	if(readablename == "passtest")
	{
		// No parameters
	}
	elseif(readablename == "assert")
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(readablename == "print")
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(readablename == "integer")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(readablename == "integer16")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(readablename == "boolean")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(readablename == "real")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(readablename == "string")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(readablename == "buffer")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(readablename == "narrowstring")
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(readablename == "substring@@withlength")
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(readablename == "substring@@nolength")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(readablename == "cast@@real_to_integer")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
}


PrependSumTypeBases : simplelist<integer> ref input, list<SumTypeBase> ref newentries
{
	simpleprepend<integer>(input, newentries.value.Name)
	PrependSumTypeBases(input, newentries.next)
}

PrependSumTypeBases : simplelist<integer> ref input, nothing


FindSumTypeAndPrependTypesToList : list<SumType> ref sumtypes, integer sumtypeid, simplelist<integer> ref types
{
	if(sumtypes.value.Type == sumtypeid)
	{
		PrependSumTypeBases(types, sumtypes.value.Bases)
	}
	else
	{
		FindSumTypeAndPrependTypesToList(sumtypes.next, sumtypeid, types)
	}
}


FindConstructorAndAddParameterTypes : list<StructureDefinition> ref structures, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	integer membercount = CountMembers(structures.value.Members)

	if((structures.value.ConstructorName == funcname) && (paramcount == membercount + 1))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		else
		{
			FindMemberAndAddParameterTypes(structures.value.Members, paramindex - 1, types)
		}
	}
	elseif((structures.value.AnonConstructorName == funcname) && (paramcount == membercount))
	{
		FindMemberAndAddParameterTypes(structures.value.Members, paramindex, types)
	}
	elseif((toplevel) && (structures.value.CopyConstructorName == funcname) && (paramcount == 2))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		elseif(paramindex == 1)
		{
			simpleprepend<integer>(types, structures.value.Type)
		}
	}
	else
	{
		FindConstructorAndAddParameterTypes(structures.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindConstructorAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types


FindMemberAndAddParameterTypes : list<StructureMember> ref members, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{
		AddParameterTypesForMember(members.value, types)
	}
	else
	{
		FindMemberAndAddParameterTypes(members.next, paramindex - 1, types)
	}
}

FindMemberAndAddParameterTypes : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many arguments to constructor")
	assert(false)
}


AddParameterTypesForMember : StructureMemberVariable ref memvar, simplelist<integer> ref types
{
	simpleprepend<integer>(types, memvar.Type)
}

AddParameterTypesForMember : StructureMemberFunctionRef ref memfunc, simplelist<integer> ref types
{
	simpleprepend<integer>(types, GetMemberTypeDecompose(memfunc))
}


GetConstructorName : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.ConstructorName
	}
	else
	{
		name = GetConstructorName(structures.next, typeid)
	}
}


StructureConstructorExists : list<StructureDefinition> ref structures, integer ctorname -> boolean exists = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		exists = true
	}
	else
	{
		exists = StructureConstructorExists(structures.next, ctorname)
	}
}

StructureConstructorExists : nothing, integer ctorname -> false


CoalesceMemberAccesses : list<ExpressionAtom> ref atoms, integer scopename
{
	while(SearchForMemberAccessStart(atoms, atoms.next, scopename))
	{
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, list<ExpressionAtom> ref current, integer scopename -> boolean found = false
{
	if(IsMemberAccessOperator(current.value))
	{
		CoalesceMemberAccessTriplet(previous, current, current.next, scopename)
		found = true
	}
	else
	{
		found = SearchForMemberAccessStart(current, current.next, scopename)
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, nothing, integer scopename -> false


CoalesceMemberAccessTriplet : list<ExpressionAtom> ref lhs, list<ExpressionAtom> ref op, list<ExpressionAtom> ref rhs, integer scopename
{
	CoalesceMemberAccessAtoms(lhs, lhs.value, rhs.value, scopename)
	lhs.next = rhs.next
}

CoalesceMemberAccessAtoms : list<ExpressionAtom> ref lhslist, ExpressionAtom ref lhs, ExpressionAtom ref rhs, integer scopename
{
	CoalesceMemberAccessAtomsUnwrapped(lhslist, lhs, rhs, scopename)
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, IdentifierAtom ref lhs, IdentifierAtom ref rhs, integer scopename
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(scopename, lhs.Handle, var)
	
	integer lhstypename = GetNameOfType(var.VarType)
	
	integer rhstype = GetStructureMemberType(Structures, lhstypename, rhs.Handle)
	integer rhstypename = GetNameOfType(rhstype)

	RefBinding lhsbinding = lhs.Handle, lhstypename, false, false
	RefBinding rhsbinding = rhs.Handle, rhstypename, false, false

	list<RefBinding> bindings = rhsbinding, nothing
	prepend<RefBinding>(bindings, lhsbinding)
	
	CompoundAtom compound = bindings, rhstype
	ExpressionAtom wrap = compound
	lhslist.value = wrap
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, CompoundAtom ref lhs, IdentifierAtom ref rhs, integer scopename
{
	integer typename = GetNameOfType(lhs.Type)
	
	RefBinding temp = rhs.Handle, typename, false, false
	AppendBinding(lhs.Bindings, lhs.Bindings.next, temp)

	lhs.Type = GetStructureMemberType(Structures, typename, rhs.Handle)
}

AppendBinding : list<RefBinding> ref bindings, list<RefBinding> ref tail, RefBinding ref binding
{
	AppendBinding(tail, tail.next, binding)
}

AppendBinding : list<RefBinding> ref bindings, nothing, RefBinding ref binding
{
	list<RefBinding> newtail = binding, nothing
	bindings.next = newtail
}


FindOrCreateTypeMatcher : integer rawname, integer overloadnamehandle -> integer matcherhandle = 0
{
	string matchername = GetPooledString(GlobalStrings, rawname) ; "@@typematcher"
	matcherhandle = PoolString(matchername)
	
	EnsureMatcherIsPending(PendingTypeMatchers, overloadnamehandle, matcherhandle)
}

EnsureMatcherIsPending : list<PendingTypeMatcher> ref pending, integer overloadname, integer matcher
{
	if(pending.value.OverloadName != overloadname)
	{
		EnsureMatcherIsPending(pending.next, overloadname, matcher)
	}
}

EnsureMatcherIsPending : nothing, integer overloadname, integer matcher
{
	PendingTypeMatcher m = overloadname, matcher
	prepend<PendingTypeMatcher>(PendingTypeMatchers, m)
}


IsPendingTypeMatcher : list<PendingTypeMatcher> ref pending, integer matchername -> boolean exists = false
{
	if(pending.value.MatcherName == matchername)
	{
		exists = true
	}
	else
	{
		exists = IsPendingTypeMatcher(pending.next, matchername)
	}
}

IsPendingTypeMatcher : nothing, integer matchername -> false


GetPendingTypeMatcherReturnType : list<PendingTypeMatcher> ref pending, integer matchername -> integer rettype = 0
{
	if(pending.value.MatcherName == matchername)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = GetFunctionReturnType(Functions, pending.value.OverloadName)
		return()
	}
	
	rettype = GetPendingTypeMatcherReturnType(pending.next, matchername)
}

GetPendingTypeMatcherReturnType : nothing, integer matchername -> integer typeid = GetPendingPatternMatcherReturnType(PendingPatternMatchers, matchername)



GetPendingPatternMatcherReturnType : list<PendingPatternMatcher> ref pending, integer matchername -> integer rettype = 0
{
	if(pending.value.MatcherName == matchername)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = GetFunctionReturnType(Functions, pending.value.OverloadName)
		return()
	}
	
	rettype = GetPendingPatternMatcherReturnType(pending.next, matchername)
}

GetPendingPatternMatcherReturnType : nothing, integer matchername -> integer typeid = GetBuiltInReturnType(matchername)



GetBuiltInReturnType : integer builtinname -> integer returntype = 0
{
	if(StructureConstructorExists(Structures, builtinname))
	{
		returntype = GetStructureByAnonConstructorName(Structures, builtinname)
		return()
	}

	string readablename = GetPooledString(GlobalStrings, builtinname)
	
	if(readablename == "narrowstring")
	{
		returntype = 0x02000001		// buffer type signature
	}
	elseif(readablename == "substring@@withlength")
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(readablename == "substring@@nolength")
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(readablename == "cast@@real_to_integer")
	{
		returntype = 0x01000001		// integer type signature
	}
}


InsertAnnotationsForTypeMatchedParams : list<FunctionDefinition> ref functions, integer overloadname, OptionalExpressionList ref paramexprs
{
	InsertAnnotationsForTypeMatchedParamsUnwrapper(functions, overloadname, paramexprs)
}

InsertAnnotationsForTypeMatchedParamsUnwrapper : list<FunctionDefinition> ref functions, integer overloadname, ExpressionList ref paramexprs
{
	InsertAnnotationsForTypeMatchedParamsUnwrap(functions, overloadname, paramexprs.Expressions)
}

InsertAnnotationsForTypeMatchedParamsUnwrap : list<FunctionDefinition> ref functions, integer overloadname, list<Expression> ref paramexprs
{
	if(functions.value.Name == overloadname)
	{
		AnnotateTypeMatchedParams(functions.value.Params, paramexprs)
	}
	else
	{
		InsertAnnotationsForTypeMatchedParamsUnwrap(functions.next, overloadname, paramexprs)
	}
}

InsertAnnotationsForTypeMatchedParamsUnwrap : nothing, integer overloadname, list<Expression> ref paramexprs
{
	FindConstructorAndAnnotateTypeMatchedParams(Structures, overloadname, paramexprs)
}

FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, list<Expression> ref paramexprs
{
	if(structures.value.ConstructorName == funcname)
	{
		listnode<Expression> ne = paramexprs.next
		AnnotateTypeMatchedParamsFromConstructor(structures.value.Members, ne)
	}
	else
	{
		FindConstructorAndAnnotateTypeMatchedParams(structures.next, funcname, paramexprs)
	}
}

FindConstructorAndAnnotateTypeMatchedParams : nothing, integer funcname, list<Expression> ref paramexprs
{
	if((GetTypeByName(funcname) & 0x7f000000) == 0x07000000)
	{
		AnnotateNonReferenceParameters(paramexprs.next)
	}
}


AnnotateTypeMatchedParamsFromConstructor : list<StructureMember> ref members, list<Expression> ref paramexprs
{
	integer membertype = GetMemberTypeDecompose(members.value)
	if((membertype & 0x7f000000) == 0x07000000)
	{
		if(paramexprs.value.Type != membertype)
		{
			AddTypeAnnotation(paramexprs.value)
		}
	}
	
	listnode<StructureMember> nm = members.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParamsFromConstructor(nm, ne)
}

AnnotateTypeMatchedParamsFromConstructor : nothing, nothing


AnnotateTypeMatchedParams : FunctionParams ref params, list<Expression> ref paramexprs
{
	AnnotateTypeMatchedParams(params.Params, paramexprs)
}

AnnotateTypeMatchedParams : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	if((params.value.ResolvedType & 0x7f000000) == 0x07000000)
	{
		//if(paramexprs.value.Type != params.value.ResolvedType)
		//{
			AddTypeAnnotation(paramexprs.value)
		//}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParams(np, ne)
}

AnnotateTypeMatchedParams : nothing, nothing

MakeParametersReferences : list<FunctionDefinition> ref functions, integer overloadname, OptionalExpressionList ref exprs
{
	MakeParametersReferencesUnwrap(functions, overloadname, exprs)
}

MakeParametersReferencesUnwrap : list<FunctionDefinition> ref functions, integer overloadname, nothing

MakeParametersReferencesUnwrap : list<FunctionDefinition> ref functions, integer overloadname, ExpressionList ref params
{
	if(functions.value.Name == overloadname)
	{
		WalkFunctionParamsAndSetReferences(functions.value.Params, params)
	}
	else
	{
		MakeParametersReferencesUnwrap(functions.next, overloadname, params)
	}
}

MakeParametersReferencesUnwrap : nothing, integer overloadname, ExpressionList ref params
{
	MakeParametersReferencesForTypeMatcher(PendingTypeMatchers, overloadname, params)
}

MakeParametersReferencesForTypeMatcher : list<PendingTypeMatcher> ref pending, integer matchername, ExpressionList ref params
{
	if(pending.value.MatcherName == matchername)
	{
		MakeParametersReferencesUnwrap(Functions, pending.value.OverloadName, params)
	}
	
	MakeParametersReferencesForTypeMatcher(pending.next, matchername, params)
}

MakeParametersReferencesForTypeMatcher : nothing, integer matchername, ExpressionList ref params
{
	MakeParametersReferencesForConstructor(Structures, matchername, params)
}


MakeParametersReferencesForConstructor : list<StructureDefinition> ref structures, integer constructorname, ExpressionList ref params
{
	if(structures.value.ConstructorName == constructorname)
	{
		MakeParametersReferencesForStructureMembers(structures.value.Members, params.Expressions.next)
	}
	else
	{
		MakeParametersReferencesForConstructor(structures.next, constructorname, params)
	}
}


MakeParametersReferencesForConstructor : nothing, integer constructorname, ExpressionList ref params


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, list<Expression> ref params
{
	if(IsMemberReferenceType(members.value))
	{
		if(!MarkAtomAsReference(params.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	
	MakeParametersReferencesForStructureMembers(members.next, params.next)
}

MakeParametersReferencesForStructureMembers : nothing, nothing



IsMemberReferenceType : StructureMemberVariable ref memvar -> boolean isref = IsReferenceType(memvar.Type)
IsMemberReferenceType : StructureMemberFunctionRef ref memfunc -> false



WalkFunctionParamsAndSetReferences : nothing, ExpressionList ref paramexprs

WalkFunctionParamsAndSetReferences : FunctionParams ref params, ExpressionList ref paramexprs
{
	WalkFunctionParamsAndSetReferencesUnwrapped(params.Params, paramexprs.Expressions)
}


WalkFunctionParamsAndSetReferencesUnwrapped : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	if(IsReferenceType(params.value.ResolvedType))
	{
		if(!MarkAtomAsReference(paramexprs.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	WalkFunctionParamsAndSetReferencesUnwrapped(np, ne)
}

WalkFunctionParamsAndSetReferencesUnwrapped : nothing, nothing


DemoteAtomType : list<ExpressionAtom> ref atoms
{
	PerformDemotion(atoms, atoms.value)
}

PerformDemotion : list<ExpressionAtom> ref atoms, integer ref atom
{
	integer16 newatom = cast(integer16, atom)
	ExpressionAtom wrap = newatom
	atoms.value = wrap
}

PerformDemotion : list<ExpressionAtom> ref atoms, IdentifierAtom ref atom


DumpOverloadList : list<InferencePossibility> ref possibilities
{
	if(possibilities.value.FunctionName != 0)
	{
		print(GetPooledString(GlobalStrings, possibilities.value.FunctionName))
	}
	
	DumpOverloadList(possibilities.next)
}

DumpOverloadList : nothing



FilterOverloadsForTypeDemotion : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false
	
	CheckIfContainsOnlyDemotedOverloads(in, hasdemoted, hassuperior, hasother)
	
	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedOverloads(in, out)
	}
	else
	{
		out = in
	}
}


FilterTypesForDemotion : simplelist<integer> ref in, simplelist<integer> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false
	
	CheckIfContainsOnlyDemotedTypes(in, hasdemoted, hassuperior, hasother)
	
	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedTypes(in, out)
	}
	else
	{
		out = in
	}	
}


CheckIfContainsOnlyDemotedOverloads : list<InferencePossibility> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value == 0x01000001)
		{
			hassuperior = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0x01000002)
		{
			hasdemoted = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0)
		{
		}
		else
		{
			hasother = true
		}
	}
	
	CheckIfContainsOnlyDemotedOverloads(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedOverloads : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother


StripDemotedOverloads : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value != 0x01000002)
		{
			prepend<InferencePossibility>(out, in.value)
		}
	}
	
	StripDemotedOverloads(in.next, out)
}

StripDemotedOverloads : nothing, list<InferencePossibility> ref out



CheckIfContainsOnlyDemotedTypes : simplelist<integer> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother
{
	if(in.value == 0x01000001)
	{
		hassuperior = true
	}
	elseif(in.value == 0x01000002)
	{
		hasdemoted = true
	}
	elseif(in.value == 0)
	{
	}
	else
	{
		hasother = true
	}
	
	CheckIfContainsOnlyDemotedTypes(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedTypes : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother


StripDemotedTypes : simplelist<integer> ref in, simplelist<integer> ref out
{
	if(in.value != 0)
	{
		if(in.value != 0x01000002)
		{
			simpleprepend<integer>(out, in.value)
		}
	}
	
	StripDemotedTypes(in.next, out)
}

StripDemotedTypes : nothing, simplelist<integer> ref out


InitBuiltInOverloads :
{
	Overload substrlength = PoolString("substring"), PoolString("substring@@withlength")
	prepend<Overload>(Overloads, substrlength)

	Overload substrnolen = PoolString("substring"), PoolString("substring@@nolength")
	prepend<Overload>(Overloads, substrnolen)
	
	Overload castrealtoint = PoolString("cast"), PoolString("cast@@real_to_integer")
	prepend<Overload>(Overloads, castrealtoint)
}



CheckMemberTypes : list<StructureMember> ref members, simplelist<integer> ref types -> boolean match = true
{
	integer membertype = GetMemberTypeDecompose(members.value)
	integer curtype = types.value

	if(membertype == curtype)
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	elseif(SumTypeHasBase(SumTypes, membertype, MakeNonReferenceType(curtype)))
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	else
	{
		match = false
	}
}

CheckMemberTypes : nothing, nothing -> true

CheckMemberTypes : list<StructureMember> ref members, nothing -> false

CheckMemberTypes : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}


GetStructureByAnonConstructorName : nothing, integer name -> 0

GetStructureByAnonConstructorName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0
{
	if(structures.value.AnonConstructorName == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureByAnonConstructorName(structures.next, name)
	}
}


stringcontains : string haystack, string needle -> boolean contains = false
{
	integer needlelen = length(needle)
	integer haystacklen = length(haystack)
	
	integer index = 0
	while(index < (haystacklen - needlelen))
	{
		if(substring(haystack, index, needlelen) == needle)
		{
			contains = true
			return()
		}
		
		++index
	}
}


PrependFunctionParameter : list<FunctionDefinition> ref functions, integer funcname, integer paramname, integer paramtype
{
	if(functions.value.Name == funcname)
	{
		UnresolvedParameter p = paramname, GetNameOfType(paramtype), paramtype, IsReferenceType(paramtype), nothing, nothing
		PrependUnresolvedParameter(functions.value.Params, p)
	}
	else
	{
		PrependFunctionParameter(functions.next, funcname, paramname, paramtype)
	}
}

PrependUnresolvedParameter : FunctionParams ref params, UnresolvedParameter ref p
{
	PrependUnresolvedParameter(params.Params, p)
}

PrependUnresolvedParameter : list<UnresolvedParameter> ref thelist, UnresolvedParameter ref p
{
	prepend<UnresolvedParameter>(thelist, p)
}

PrependUnresolvedParameter : nothing, UnresolvedParameter ref p
{
	print("Cannot set constructor tag on function with no parameters")
	assert(false)
}


GetSignatureReturnType : list<FunctionSignature> ref signatures, integer functype -> integer rettype = 0
{
	if(signatures.value.Name == functype)		// stupid overload of "name" to also mean "type"
	{
		rettype = GetTypeByName(signatures.value.ReturnTypeName)
	}
	else
	{
		rettype = GetSignatureReturnType(signatures.next, functype)
	}
}


FindOrCreateFunctionSignatureType : FunctionSignature ref signature -> integer typeid = 0
{
	typeid = FindMatchingSignature(FunctionSignatures, signature)
	if(typeid == 0)
	{
		FunctionSignature newsig = signature
		newsig.Name = (++GlobalFunctionTypeCounter)
		prepend<FunctionSignature>(FunctionSignatures, newsig)
		
		typeid = newsig.Name
	}
}

FindOrCreateFunctionSignatureType : simplelist<integer> ref paramtypenames, integer returntypename -> integer typeid = 0
{
	typeid = FindFunctionSignatureType(FunctionSignatures, paramtypenames, returntypename)
	if(typeid == 0)
	{
		OnCodeGenRegisterFunctionSig((++GlobalFunctionTypeCounter), returntypename)
		OnCodeGenRegisterFunctionSigParamList(paramtypenames)
		
		typeid = GlobalFunctionTypeCounter
	}
}

FindFunctionSignatureType : list<FunctionSignature> ref signatures, simplelist<integer> ref paramtypes, integer returntypename -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == returntypename)
	{
		if(SignatureMatchesParams(signatures.value.Parameters, paramtypes))
		{
			typeid = signatures.value.Name
			return()
		}
	}
	
	typeid = FindFunctionSignatureType(signatures.next, paramtypes, returntypename)
}

FindFunctionSignatureType : nothing, simplelist<integer> ref paramtypes, integer returntypename -> 0


SignatureMatchesParams : list<Parameter> ref params, simplelist<integer> ref paramtypes -> boolean match = true
{
	if(params.value.Name == 0)
	{
		match = SignatureMatchesParams(params.next, paramtypes)
	}
	elseif(params.value.Type != GetTypeByName(paramtypes.value))
	{
		match = false
	}
	else
	{
		match = SignatureMatchesParams(params.next, paramtypes.next)
	}
}

SignatureMatchesParams : nothing, simplelist<integer> ref paramtypes -> (paramtypes.value == 0)
SignatureMatchesParams : list<Parameter> ref params, nothing -> (params.value.Name == 0)

SignatureMatchesParams : nothing, nothing -> true


FindFunctionAndGetSignatureType : list<FunctionDefinition> ref functions, integer funcname -> integer typeid = 0
{
	if(functions.value.Name == funcname)
	{
		simplelist<integer> paramtypes = 0, nothing
		GetFunctionParameterTypes(functions.value.Params, paramtypes)
		
		typeid = FindFunctionSignatureType(FunctionSignatures, paramtypes, GetNameOfType(GetFunctionReturnType(functions, funcname)))
	}
	else
	{
		typeid = FindFunctionAndGetSignatureType(functions.next, funcname)
	}
}


GetFunctionParameterTypes : FunctionParams ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.Params, outtypenames)
}

GetFunctionParameterTypes : list<UnresolvedParameter> ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.next, outtypenames)
	simpleprepend<integer>(outtypenames, GetNameOfType(params.value.ResolvedType))
}

GetFunctionParameterTypes : nothing, simplelist<integer> ref outtypenames


FindMatchingSignature : list<FunctionSignature> ref signatures, FunctionSignature ref targetsig -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == targetsig.ReturnTypeName)
	{
		if(SignaturesMatch(signatures.value.Parameters, targetsig.Parameters))
		{
			typeid = signatures.value.Name
			return()
		}
	}
	
	typeid = FindMatchingSignature(signatures.next, targetsig)
}

FindMatchingSignature : nothing, FunctionSignature ref targetsig -> 0


SignaturesMatch : list<Parameter> ref a, list<Parameter> ref b -> boolean match = true
{
	if(a.value.Type != b.value.Type)
	{
		match = false
	}
	else
	{
		match = SignaturesMatch(a.next, b.next)
	}
}

SignaturesMatch : nothing, list<Parameter> ref b -> (b.value.Name == 0)
SignaturesMatch : list<Parameter> ref a, nothing -> (a.value.Name == 0)

SignaturesMatch : nothing, nothing -> true


DumpSignature : FunctionSignature ref sig
{
	print("  Function signature")
	DumpSignatureParams(sig.Parameters)
	print("  ->")
	if(sig.ReturnTypeName != 0)
	{
		print(GetPooledString(GlobalStrings, sig.ReturnTypeName))
	}
}

DumpSignatureParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		print(GetPooledString(GlobalStrings, GetNameOfType(params.value.Type)))
	}
	DumpSignatureParams(params.next)
}

DumpSignatureParams : nothing



ResolveSignatureTypes : FunctionSignature ref signature
{
	ResolveSignatureTypes(signature.Parameters)
}

ResolveSignatureTypes : list<Parameter> ref params
{
	params.value.Type = GetTypeByName(params.value.Type)
	ResolveSignatureTypes(params.next)
}

ResolveSignatureTypes : nothing



FindBuiltinAndGetSignatureType : integer builtinname -> integer typeid = 0
{
	string readablename = GetPooledString(GlobalStrings, builtinname)
	if(readablename == "passtest")
	{
		simplelist<integer> paramtypes = 0, nothing
		typeid = FindOrCreateFunctionSignatureType(paramtypes, 0)
	}
}


FindPrePostOperatorOverload : integer operatorname, integer operandtype -> integer overloadname = 0
{
	string readable = GetPooledString(GlobalStrings, operatorname)
	if(readable == "++")
	{
		if(operandtype == 0x01000001)
		{
			overloadname = FindString(GlobalStrings, "++@@integer")
		}
	}
	elseif(readable == "--")
	{
		if(operandtype == 0x01000001)
		{
			overloadname = FindString(GlobalStrings, "--@@integer")
		}
	}
}

FindAssignmentOperator : integer operatorname, integer lhstype, integer rhstype -> integer overloadname = operatorname
{
	string readable = GetPooledString(GlobalStrings, operatorname)
	if(readable == "+=")
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = FindString(GlobalStrings, "+=@@integer")
		}
	}
	elseif(readable == "-=")
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = FindString(GlobalStrings, "-=@@integer")
		}
	}
}


SetFunctionReturnType : integer funcname, integer rettype
{
	FindFunctionAndSetReturnType(Functions, funcname, rettype)
}

FindFunctionAndSetReturnType : list<FunctionDefinition> ref functions, integer funcname, integer rettype
{
	if(functions.value.Name == funcname)
	{
		SetOptionalExpressionType(functions.value.Return, rettype)
	}
	else
	{
		FindFunctionAndSetReturnType(functions.next, funcname, rettype)
	}
}

SetOptionalExpressionType : Expression ref expr, integer typeid
{
	expr.Type = typeid
}



CheckForNeededPatternMatcher : list<PendingPatternMatcher> ref patternmatchers, integer rawname -> integer matchername = 0
{
	if(patternmatchers.value.RawName == rawname)
	{
		matchername = patternmatchers.value.MatcherName
	}
	else
	{
		matchername = CheckForNeededPatternMatcher(patternmatchers.next, rawname)
	}
}

CheckForNeededPatternMatcher : nothing, integer rawname -> 0


EnsurePatternMatcherExists : list<PendingPatternMatcher> ref patternmatchers, integer rawname, integer mangledname
{
	if(patternmatchers.value.OverloadName == mangledname)
	{
		return()
	}
	
	EnsurePatternMatcherExists(patternmatchers.next, rawname, mangledname)
}

EnsurePatternMatcherExists : nothing, integer rawname, integer mangledname
{
	PendingPatternMatcher pm = rawname, mangledname, PoolString(GetPooledString(GlobalStrings, rawname) ; "@@patternmatch")
	prepend<PendingPatternMatcher>(PendingPatternMatchers, pm)
}



CodeGenEmitPatternMatchers : list<PendingPatternMatcher> ref matchers
{
	if(!listcontains(EmittedPatternMatchers, matchers.value.MatcherName))
	{
		OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
		OnBytecodeEmitInteger(matchers.value.MatcherName)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(0)

		OnBytecodeEnterPatternResolver(matchers.value.MatcherName)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, true)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, false)
		OnBytecodeExitPatternResolver()
		
		simpleprepend<integer>(EmittedPatternMatchers, matchers.value.MatcherName)
	}
	
	CodeGenEmitPatternMatchers(matchers.next)
}

CodeGenEmitPatternMatchers : nothing


EmitOverloadsForPatternMatcher : list<PendingPatternMatcher> ref matchers, integer matchername, boolean preferliterals
{
	if(matchername == matchers.value.MatcherName)
	{
		// TODO - filter down to matchers that fit the most general function pattern
		
		EmitPatternMatchOverload(Functions, matchers.value.OverloadName, preferliterals)		
	}

	EmitOverloadsForPatternMatcher(matchers.next, matchername, preferliterals)
}

EmitOverloadsForPatternMatcher : nothing, integer matchername, boolean preferliterals



EmitPatternMatchOverload : list<FunctionDefinition> ref functions, integer overloadname, boolean preferliterals
{
	if(functions.value.Name == overloadname)
	{
		boolean hasliterals = FunctionSignatureHasLiterals(functions.value.Params)
		if(hasliterals && preferliterals)
		{
			EmitPatternMatchingForFunction(functions.value)
		}
		elseif((!hasliterals) && (!preferliterals))
		{
			EmitPatternMatchingForFunction(functions.value)
		}
	}
	else
	{
		EmitPatternMatchOverload(functions.next, overloadname, preferliterals)
	}
}


FunctionSignatureHasLiterals : FunctionParams ref params -> boolean hasliterals = FunctionSignatureHasLiterals(params.Params)

FunctionSignatureHasLiterals : list<UnresolvedParameter> ref params -> boolean hasliterals = false
{
	integer exprtype = GetOptionalExpressionType(params.value.PatternMatchValue)
	if((exprtype != 0) && (exprtype != 0x00000002))
	{
		hasliterals = true
		return()
	}

	if(FunctionSignatureHasLiterals(params.next))
	{
		hasliterals = true
	}
}

FunctionSignatureHasLiterals : nothing -> false



EmitPatternMatchingForFunction : FunctionDefinition ref function
{
	OnBytecodeEmitByte(0x12)			// PatternMatch instruction
	OnBytecodeEmitInteger(function.Name)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitInteger(CountUnresolvedParameters(function.Params))
	EmitPatternMatchingForParameters(function.Params)
}

EmitPatternMatchingForParameters : FunctionParams ref params
{
	EmitPatternMatchingForParameters(params.Params)
}

EmitPatternMatchingForParameters : list<UnresolvedParameter> ref params
{
	integer parampatterntype = GetOptionalExpressionType(params.value.PatternMatchValue)
	OnBytecodeEmitInteger(MakeNonReferenceType(parampatterntype))

	if(parampatterntype != 0)
	{
		OnBytecodeEmitBoolean(true)
		EmitPatternMatchLiteral(params.value.PatternMatchValue)
	}
	else
	{
		OnBytecodeEmitBoolean(false)
	}

	EmitPatternMatchingForParameters(params.next)
}

EmitPatternMatchingForParameters : nothing


EmitPatternMatchLiteral : Expression ref expr
{
	EmitPatternMatchLiteralAtom(expr.Atoms.value)
}

EmitPatternMatchLiteralAtom : integer value
{
	OnBytecodeEmitInteger(value)
}


PatternMatcherExists : nothing, integer matchername -> false

PatternMatcherExists : list<PendingPatternMatcher> ref matchers, integer matchername -> boolean exists = false
{
	if(matchers.value.MatcherName == matchername)
	{
		exists = true
	}
	else
	{
		exists = PatternMatcherExists(matchers.next, matchername)
	}
}



GetCastOverload : nothing -> 0

GetCastOverload : ExpressionList ref params -> integer overloadname = FigureOutCastOverload(params.Expressions)


FigureOutCastOverload : list<Expression> ref params -> integer overloadname = 0
{
	integer idtype = GetTypeByName(GetIdentifier(params.value.Atoms.value))
	if(idtype != 0)
	{
		integer origintype = FigureOutCastOriginType(params.next)
		
		if((idtype == 0x01000001) && (origintype == 0x01000004))
		{
			overloadname = PoolString("cast@@real_to_integer")
		}
	}
}

FigureOutCastOverload : nothing -> 0



FigureOutCastOriginType : list<Expression> ref params -> integer origintype = params.value.Type

FigureOutCastOriginType : nothing -> 0


GetIdentifier : IdentifierAtom ref atom -> atom.Handle



IRRegisterTemplateParameter : integer paramtype, integer paramname
{
	TemplateParameter p = paramname, paramtype
	prepend<TemplateParameter>(TemplateParameterQueue, p)
}


CreateFunctionTemplateAndAttachParams : integer funcname, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateFunction templfunc = funcname, dummyparams
	prepend<TemplateFunction>(TemplateFunctions, templfunc)
}


CreateStructureTemplateAndAttachParams : integer structurename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateStructure templstructure = structurename, dummyparams
	prepend<TemplateStructure>(TemplateStructures, templstructure)
}


CreateSumTypeTemplateAndAttachParams : integer typename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateSumType templtype = typename, dummyparams
	prepend<TemplateSumType>(TemplateSumTypes, templtype)
}



TransferTemplateParamsFromQueue : list<TemplateParameter> ref out, list<TemplateParameter> ref queue
{
	if(queue.value.ParamType != 0)
	{
		TransferTemplateParamsFromQueue(out, queue.next)

		if(out.value.ParamType == 0)
		{
			out.value = queue.value
		}
		else
		{
			prepend<TemplateParameter>(out, queue.value)
		}
	}
}



PopTemplateArgStack : list<TemplateArgumentList> ref stack, list<TemplateArgumentList> ref next
{
	stack = next
}

PopTemplateArgList : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail
{
	thelist = tail
}


AppendTemplateArgument : list<TemplateArgument> ref thelist, TemplateArgument ref arg
{
	AppendTemplateArgumentRecurse(thelist, thelist.next, arg)
}


AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, nothing, TemplateArgument ref arg
{
	list<TemplateArgument> newlist = arg, nothing
	thelist.next = newlist
}

AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail, TemplateArgument ref arg
{
	AppendTemplateArgumentRecurse(tail, tail.next, arg)
}



InstantiateFunctionTemplate : integer templatename, nothing -> templatename

InstantiateFunctionTemplate : integer templatename, TemplateArgumentList ref args -> integer instancename = templatename
{
	integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, templatename, args.Args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}
	
	instancename = FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, templatename, args.Args)
	EnumerateOverloadsAndInstantiate(Overloads, templatename, args.Args)
}


EnumerateOverloadsAndInstantiate : list<Overload> ref overloads, integer templatename, list<TemplateArgument> ref args
{
	if(overloads.value.NormalName == templatename)
	{
		integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, overloads.value.MangledName, args)
		if(existing == 0)
		{
			FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, overloads.value.MangledName, args)
		}
	}
	
	EnumerateOverloadsAndInstantiate(overloads.next, templatename, args)
}

EnumerateOverloadsAndInstantiate : nothing, integer templatename, list<TemplateArgument> ref args


FindFunctionTemplateAndInstantiate : list<TemplateFunction> ref templates, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.FunctionDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = RegisterOverloadForFunction(PoolString(mangledname))
		
		// TODO - validate that args suit the formal template parameters!
		
		string basenamemangled = MangleTemplateName(basename, args)
		Overload overload = PoolString(basenamemangled), instancename
		prepend<Overload>(Overloads, overload)
		
		DoFunctionInstantiation(Functions, defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindFunctionTemplateAndInstantiate(templates.next, basename, defname, args)
	}
}


FindStructureTemplateAndInstantiate : list<TemplateStructure> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.StructureDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)
		
		// TODO - validate that args suit the formal template parameters!
		
		DoStructureInstantiation(Structures, defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindStructureTemplateAndInstantiate(templates.next, defname, args)
	}
}

FindStructureTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateSumType(defname, args)


InstantiateSumType : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateSumTypeInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}
	
	instancename = FindSumTypeTemplateAndInstantiate(TemplateSumTypes, defname, args)
}

FindSumTypeTemplateAndInstantiate : list<TemplateSumType> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.SumTypeName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)
		
		// TODO - validate that args suit the formal template parameters!

		DoSumTypeInstantiation(SumTypes, defname, instancename, templates.value.Parameters, args)		
	}
	else
	{
		instancename = FindSumTypeTemplateAndInstantiate(templates.next, defname, args)
	}
}


FindSumTypeTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	string namestr = GetPooledString(GlobalStrings, defname)
	print("Error - no template provided for '" ; namestr ; "', cannot create instance!")
}


DoStructureInstantiation : list<StructureDefinition> ref structures, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(structures.value.Name == defname)
	{
		assert(structures.value.IsTemplate)
		
		++GlobalTemplateInstanceCounter
		
		list<StructureMember> members = dummymember, nothing
		DoMemberListInstantiation(structures.value.Members, members, params, args)
		PopMember(members, members.next)
		
		StructureDefinition struct = instancename, GlobalTemplateInstanceCounter, 0, 0, 0, members, false
		prepend<StructureDefinition>(Structures, struct)

		TemplateInstance instance = defname, instancename, args
		prepend<TemplateInstance>(TemplateStructureInstances, instance)

		simplelist<integer> temp = 0, nothing
		InferenceContext context = 0, 0, temp, false, 0, false
		TypeInference(Structures.value, context)
	}
	else
	{
		DoStructureInstantiation(structures.next, defname, instancename, params, args)
	}
}


DoSumTypeInstantiation : list<SumType> ref sumtypes, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(sumtypes.value.Name == defname)
	{
		assert(sumtypes.value.IsTemplate)
		
		++GlobalSumTypeCounter
		
		list<SumTypeBase> bases = dummybasetype, nothing
		DoBaseTypeInstantiation(sumtypes.value.Bases, bases, params, args)
		
		SumType st = instancename, GlobalSumTypeCounter, bases, false
		prepend<SumType>(SumTypes, st)

		TemplateInstance instance = defname, instancename, args
		prepend<TemplateInstance>(TemplateSumTypeInstances, instance)

		ResolveSumTypeBases(SumTypes.value.Bases)
	}
	else
	{
		DoSumTypeInstantiation(sumtypes.next, defname, instancename, params, args)
	}
}

PopMember : list<StructureMember> ref members, list<StructureMember> ref tail
{
	members = tail
}

DoMemberListInstantiation : list<StructureMember> ref members, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	DoMemberInstantiation(members.value, out, params, args)	
	DoMemberListInstantiation(members.next, out, params, args)
}

DoMemberListInstantiation : nothing, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args

DoMemberInstantiation : StructureMemberVariable ref memvar, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(memvar.Name != 0)
	{	
		integer newtype = MapTemplateType(memvar.TypeNameHandle, params, args)
		StructureMemberVariable newmemvar = memvar.Name, 0, newtype, memvar.TemplateArgs
		RemapAllTemplateArguments(newmemvar.TemplateArgs, params, args)
		StructureMember newmember = newmemvar
		AppendStructureMember(out, out.next, newmember)
	}
}

DoBaseTypeInstantiation : list<SumTypeBase> ref bases, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	InstantiateBaseType(bases.value, out, params, args)	
	DoBaseTypeInstantiation(bases.next, out, params, args)
}

DoBaseTypeInstantiation : nothing, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args


InstantiateBaseType : SumTypeBase ref in, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(in.Name != 0)
	{
		integer newtype = MapTemplateType(in.Name, params, args)
		
		SumTypeBase newbase = newtype, in.TemplateArgs
		RemapAllTemplateArguments(newbase.TemplateArgs, params, args)
		prepend<SumTypeBase>(out, newbase)
	}
}

RemapAllTemplateArguments : TemplateArgumentList ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	RemapAllTemplateArguments(toremap.Args, params, args)
}

RemapAllTemplateArguments : list<TemplateArgument> ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(toremap.value.ReplaceWith != 0)
	{
		toremap.value.ReplaceWith = MapTemplateType(toremap.value.ReplaceWith, params, args)
	}
	
	RemapAllTemplateArguments(toremap.next, params, args)
}

RemapAllTemplateArguments : nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args


DoFunctionInstantiation : list<FunctionDefinition> ref functions, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(functions.value.Name == defname)
	{
		assert(functions.value.IsTemplate)
		
		FunctionDefinition func = defname, instancename, false, nothing, nothing, functions.value.AnonymousReturn, 0, nothing, false
		prepend<FunctionDefinition>(Functions, func)

		list<OptionalCodeBlock> newstack = nothing, nothing
		CurrentCodeBlockStack = newstack
		
		DoParameterInstantiation(functions.value.Params, params, args)
		DoReturnInstantiation(functions.value.Return, instancename, functions.value.AnonymousReturn, params, args)

		// TODO - traverse template and instantiate the following stuff
		//ParseFunctionTags(namehandle, rawnamehandle)

		IREnterFunction(instancename)
		OnCodeGenEnterFunctionBody(instancename)

		DoCodeBlockInstantiation(functions.value.Code, params, args)
		
		IRExitFunction()
		
		TemplateInstance instance = defname, instancename, args
		prepend<TemplateInstance>(TemplateFunctionInstances, instance)


		simplelist<integer> temp = 0, nothing
		InferenceContext context = 0, 0, temp, false, 0, false
		TypeInference(Functions.value, context)
	}
	else
	{
		DoFunctionInstantiation(functions.next, defname, instancename, params, args)
	}
}


DoParameterInstantiation : FunctionParams ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	DoParameterInstantiation(params.Params, templateparams, templateargs)
}

DoParameterInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoParameterInstantiation : list<UnresolvedParameter> ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer newtype = MapTemplateType(params.value.TypeNameHandle, templateparams, templateargs)
		
	UnresolvedParameter p = params.value.NameHandle, newtype, params.value.ResolvedType, params.value.HasRefTag, params.value.PatternMatchValue, nothing
	PropagateTemplateArgsForParameter(p, params.value.TemplateArgs, templateparams, templateargs)
	
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)

	DoParameterInstantiation(params.next, templateparams, templateargs)
}


PropagateTemplateArgsForParameter : UnresolvedParameter ref p, TemplateArgumentList ref check, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	TemplateArgumentList wrap = args
	RemapAllTemplateArguments(wrap, params, args)
	p.TemplateArgs = wrap
}

PropagateTemplateArgsForParameter : UnresolvedParameter ref p, nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args


DoReturnInstantiation : Expression ref retexpr, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterFunctionReturn(funcname, anonymous)
	InstantiateExpression(retexpr, true, templateparams, templateargs)
	OnCodeGenExitContext()
}

DoReturnInstantiation : nothing, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs


MapTemplateType : integer typenamehandle, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs -> integer newtypename = typenamehandle
{
	if(templateparams.value.ParamName == typenamehandle)
	{
		newtypename = templateargs.value.ReplaceWith
	}
	else
	{
		newtypename = MapTemplateType(typenamehandle, templateparams.next, templateargs.next)
	}
}

MapTemplateType : integer typenamehandle, nothing, nothing -> typenamehandle


MangleTemplateNameByHandle : integer defname, nothing -> integer mangled = defname

MangleTemplateNameByHandle : integer defname, TemplateArgumentList ref args -> integer mangled = PoolString(MangleTemplateName(defname, args.Args))


MangleTemplateName : integer defname, list<TemplateArgument> ref args -> string mangled = GetPooledString(GlobalStrings, defname) ; "@@templateinst@"
{
	mangled = mangled ; MangleTemplateArguments(args)
}

MangleTemplateArguments : list<TemplateArgument> ref args -> string mangled = GetPooledString(GlobalStrings, args.value.ReplaceWith)
{
	mangled = mangled; MangleTemplateArguments(args.next)
}

MangleTemplateArguments : nothing -> ""


FindFunctionTemplateAndInstantiate : nothing, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateStructureTemplate(defname, args)


InstantiateStructureTemplate : integer defname, TemplateArgumentList ref args -> integer instancename = InstantiateStructureTemplate(defname, args.Args)

InstantiateStructureTemplate : integer defname, nothing -> integer instancename = 0

InstantiateStructureTemplate : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateStructureInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}
	
	instancename = FindStructureTemplateAndInstantiate(TemplateStructures, defname, args)
}


FindExistingTemplateInstance : list<TemplateInstance> ref instances, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(instances.value.DefName == defname)
	{
		if(TemplateArgumentsMatch(instances.value.Arguments, args))
		{
			instancename = instances.value.InstanceName
			return()
		}
	}
	
	instancename = FindExistingTemplateInstance(instances.next, defname, args)
}

FindExistingTemplateInstance : nothing, integer defname, list<TemplateArgument> ref args -> 0



TemplateArgumentsMatch : list<TemplateArgument> ref a, list<TemplateArgument> ref b -> boolean match = true
{
	if(a.value.ReplaceWith != b.value.ReplaceWith)
	{
		match = false
	}
	else
	{
		match = TemplateArgumentsMatch(a.next, b.next)
	}
}

TemplateArgumentsMatch : nothing, list<TemplateArgument> ref b -> false
TemplateArgumentsMatch : list<TemplateArgument> ref a, nothing -> false
TemplateArgumentsMatch : nothing, nothing -> true



InstantiateExpression : Expression ref expr, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateAtoms(expr.Atoms, inret, templateparams, templateargs)
}

InstantiateAtoms : list<ExpressionAtom> ref atoms, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateSingleAtom(atoms.value, inret, templateparams, templateargs)
	InstantiateAtoms(atoms.next, inret, templateparams, templateargs)
}

InstantiateAtoms : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support ALL atom types
InstantiateSingleAtom : IdentifierAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterAtomIdentifier(atom.Handle, 0)
}

InstantiateSingleAtom : OperatorInvokeAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterOperatorInvoke(atom.OperatorName)
}

InstantiateSingleAtom : Statement ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer statementname = MapTemplateType(atom.Name, templateparams, templateargs)

	OnCodeGenEnterSubStatement()
	InstantiateStatement(statementname, inret, atom.TemplateArgs, templateargs)

	InstantiateExpressionList(atom.Parameters, false, templateparams, templateargs, 0)
	
	IRExitStatement()
	IRExitStatement()
}


InstantiateSingleAtom : AtomSentinel ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

InstantiateSingleAtom : boolean ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralBoolean(atom)
}

InstantiateSingleAtom : StringHandleAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralString(atom.Handle)
}


InstantiateStatement : integer statementname, boolean inret, nothing, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterStatement(statementname, 0, inret, false)
}

InstantiateStatement : integer statementname, boolean inret, TemplateArgumentList ref args, list<TemplateArgument> ref templateargs
{
	Statement statement = statementname, nothing, 0, inret, args
	PropagateTemplateArgsForStatement(statement, args, templateargs)
	OnCodeGenEmplaceStatement(statement)
}

PropagateTemplateArgsForStatement : Statement ref s, TemplateArgumentList ref check, list<TemplateArgument> ref args
{
	TemplateArgumentList wrap = args
	s.TemplateArgs = wrap
}

PropagateTemplateArgsForStatement : Statement ref s, nothing, list<TemplateArgument> ref args


InstantiateExpressionList : ExpressionList ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	InstantiateExpressionList(exprs.Expressions, inret, templateparams, templateargs, count)
}

InstantiateExpressionList : list<Expression> ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	if(count != 0)
	{
		OnCodeGenShiftParameter()
	}

	InstantiateExpression(exprs.value, inret, templateparams, templateargs)
	InstantiateExpressionList(exprs.next, inret, templateparams, templateargs, count + 1)
}

InstantiateExpressionList : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count


DoCodeBlockInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoCodeBlockInstantiation : CodeBlock ref code, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntries(code.Entries, templateparams, templateargs)
}

InstantiateCodeBlockEntries : list<CodeBlockEntry> ref entries, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntry(entries.value, templateparams, templateargs)
	InstantiateCodeBlockEntries(entries.next, templateparams, templateargs)
}

InstantiateCodeBlockEntries : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support all code block entry types
InstantiateCodeBlockEntry : Statement ref s, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateStatement(s.Name, true, s.TemplateArgs, templateargs)
	InstantiateExpressionList(s.Parameters, false, templateparams, templateargs, 0)
	
	IRExitStatement()
}

InstantiateCodeBlockEntry : Assignment ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support
	
	OnCodeGenEnterAssignment(a.Operator, a.LHSName, 0, 0)
	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCodeBlockEntry : AssignmentCompound ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support
	
	OnCodeGenEnterAssignmentCompound(a.Operator, a.LHS.value, 0, 0)
	InstantiateCompoundAssignmentLHS(a.LHS.next)
	OnCodeGenAssignmentCompoundEnd()

	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCompoundAssignmentLHS : simplelist<integer> ref lhs
{
	OnCodeGenAssignmentCompoundMember(lhs.value)
	InstantiateCompoundAssignmentLHS(lhs.next)
}

InstantiateCompoundAssignmentLHS : nothing



SetStructureToTemplate : list<StructureDefinition> ref structures, integer name
{
	if(structures.value.Name == name)
	{
		structures.value.IsTemplate = true

		CreateStructureTemplateAndAttachParams(name, TemplateParameterQueue)
		
		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
	else
	{
		SetStructureToTemplate(structures.next, name)
	}
}


structure tailhack :
	simplelistnode<string> tail
	
	
	
//
// EXE generation stuff
//

WriteFile : integer handle, buffer ref data, integer numbytes, integer ref written, integer ignored2 -> boolean ret = false [external("Kernel32.dll", "WriteFile", "stdcall")]

MakeExe : string filename
{
	integer imagesize = 0x6000		// TODO - fix this! Actually compute virtual size taken by the image
	integer resourcesize = 0


	integer GENERIC_WRITE = 0x40000000
	integer CREATE_ALWAYS = 2

	integer filehandle = CreateFile(filename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(filehandle == 0)
	{
		print("Cannot open " ; filename ; " to emit .EXE!")
		return()
	}


	integer position = 0
	position += WritePEHeader(filehandle, imagesize, resourcesize)
	
	position += WriteSectionHeader(filehandle, ".idata", 0x400, 0x1000, 0x344, 0x400, 0xc0000040)
	position += WriteSectionHeader(filehandle, ".text", 0x800, 0x2000, 0x150, 0x200, 0x60000020)
	position += WriteSectionHeader(filehandle, ".data", 0xa00, 0x3000, 0x29e, 0x400, 0x40000040)
	position += WriteSectionHeader(filehandle, ".rsrc", 0xe00, 0x4000, 0x10, 0x10, 0x40000040)
	position += WriteSectionHeader(filehandle, ".epoch", 0x1000, 0x5000, HackSize, HackSize, 0x40000040)
	
	print("Writing thunk table...")
	position += WritePadding(filehandle, position, 0x400)
	position += WriteThunkTable(filehandle)
	position += WritePadding(filehandle, position, 0x600)
	position += WriteThunkAddresses(filehandle)
	
	print("Writing bootstrap code...")
	position += WritePadding(filehandle, position, 0x800)
	position += WriteBootstrapCode(filehandle)

	position += WritePadding(filehandle, position, 0xa00)
	position += WriteStringTable(filehandle)
	
	position += WritePadding(filehandle, position, 0xe00)
	// TODO - emit resources
		
	// Output the Epoch bytecode section
	position += WritePadding(filehandle, position, 0x1000)
	print("Writing Epoch code block...")
	integer written = 0
	WriteFile(filehandle, Hack, HackSize, written, 0)

	CloseHandle(filehandle)
	
	print("Compilation complete.")
}


WriteStringTable : integer filehandle -> integer writtenbytes = 0
{
	buffer tablebuffer = 1024
	integer tablesize = 0
	
	
	EmitInteger(tablebuffer, tablesize, 0x63657845)
	EmitInteger(tablebuffer, tablesize, 0x42657475)
	EmitInteger(tablebuffer, tablesize, 0x43657479)
	EmitInteger(tablebuffer, tablesize, 0x0065646f)
	
	EmitInteger(tablebuffer, tablesize, 0x00700065)
	EmitInteger(tablebuffer, tablesize, 0x0063006f)
	EmitInteger(tablebuffer, tablesize, 0x00720068)
	EmitInteger(tablebuffer, tablesize, 0x006e0075)
	EmitInteger(tablebuffer, tablesize, 0x00690074)
	EmitInteger(tablebuffer, tablesize, 0x0065006d)
	EmitInteger(tablebuffer, tablesize, 0x0064002e)
	EmitInteger(tablebuffer, tablesize, 0x006c006c)
	EmitInteger16(tablebuffer, tablesize, 0x0000)
	
	// TODO - embed error strings
	
	
	integer written = 0
	WriteFile(filehandle, tablebuffer, tablesize, written, 0)
	
	writtenbytes = tablesize	
}


WriteThunkAddresses : integer filehandle -> integer writtenbytes = 0
{
	buffer thunkbuffer = 1024
	integer thunksize = 0
	
	
	EmitInteger(thunkbuffer, thunksize, 0x000010bc)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x00001096)
	EmitInteger(thunkbuffer, thunksize, 0x000010ec)
	EmitInteger(thunkbuffer, thunksize, 0x000010e4)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x000010b1)
	EmitInteger(thunkbuffer, thunksize, 0x00001114)
	
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)
	
	writtenbytes = thunksize
}


WriteBootstrapCode : integer filehandle -> integer writtenbytes = 0
{
	buffer codebuffer = 1024
	integer codesize = 0
	
	EmitInteger(codebuffer, codesize, 0x81ec8b55)
	EmitInteger(codebuffer, codesize, 0x000404ec)
	EmitInteger(codebuffer, codesize, 0x10685600)
	EmitInteger(codebuffer, codesize, 0xff004030)
	EmitInteger(codebuffer, codesize, 0x40110415)
	EmitInteger(codebuffer, codesize, 0x3bf63300)
	EmitInteger(codebuffer, codesize, 0x6a1a75c6)
	EmitInteger(codebuffer, codesize, 0x30326810)
	EmitInteger(codebuffer, codesize, 0x52680040)
	EmitInteger(codebuffer, codesize, 0x56004030)
	EmitInteger(codebuffer, codesize, 0x111415ff)
	EmitInteger(codebuffer, codesize, 0xc0330040)
	EmitInteger(codebuffer, codesize, 0x00008be9)
	EmitInteger(codebuffer, codesize, 0x30006800)
	EmitInteger(codebuffer, codesize, 0xff500040)
	EmitInteger(codebuffer, codesize, 0x40110015)
	EmitInteger(codebuffer, codesize, 0xfc458900)
	EmitInteger(codebuffer, codesize, 0x0e75c63b)
	EmitInteger(codebuffer, codesize, 0x3268106a)
	EmitInteger(codebuffer, codesize, 0x68004030)
	EmitInteger(codebuffer, codesize, 0x004030e8)
	EmitInteger(codebuffer, codesize, 0x6853d1eb)
	EmitInteger(codebuffer, codesize, 0x000001ff)
	EmitInteger(codebuffer, codesize, 0xfbfc858d)
	EmitInteger(codebuffer, codesize, 0x5650ffff)
	EmitInteger(codebuffer, codesize, 0x10fc15ff)
	EmitInteger(codebuffer, codesize, 0x6a560040)
	EmitInteger(codebuffer, codesize, 0x56036a20)
	EmitInteger(codebuffer, codesize, 0x0068016a)
	EmitInteger(codebuffer, codesize, 0x8d800000)
	EmitInteger(codebuffer, codesize, 0xfffbfc85)
	EmitInteger(codebuffer, codesize, 0x15ff50ff)
	EmitInteger(codebuffer, codesize, 0x004010f4)
	EmitInteger(codebuffer, codesize, 0xfb83d88b)
	EmitInteger(codebuffer, codesize, 0x6a0e75ff)
	EmitInteger(codebuffer, codesize, 0x30326810)
	EmitInteger(codebuffer, codesize, 0xf2680040)
	EmitInteger(codebuffer, codesize, 0xeb004031)
	EmitInteger(codebuffer, codesize, 0x5656561d)
	EmitInteger(codebuffer, codesize, 0x5356026a)
	EmitInteger(codebuffer, codesize, 0x10f015ff)
	EmitInteger(codebuffer, codesize, 0xc63b0040)
	EmitInteger(codebuffer, codesize, 0x106a1975)
	EmitInteger(codebuffer, codesize, 0x40303268)
	EmitInteger(codebuffer, codesize, 0x32326800)
	EmitInteger(codebuffer, codesize, 0xff560040)
	EmitInteger(codebuffer, codesize, 0x40111415)
	EmitInteger(codebuffer, codesize, 0x5bc03300)
	EmitInteger(codebuffer, codesize, 0x57c3c95e)
	EmitInteger(codebuffer, codesize, 0x6a565656)
	EmitInteger(codebuffer, codesize, 0x15ff5001)
	EmitInteger(codebuffer, codesize, 0x00401108)
	EmitInteger(codebuffer, codesize, 0xfe3bf88b)
	EmitInteger(codebuffer, codesize, 0x106a1875)
	EmitInteger(codebuffer, codesize, 0x40303268)
	EmitInteger(codebuffer, codesize, 0x326c6800)
	EmitInteger(codebuffer, codesize, 0xff560040)
	EmitInteger(codebuffer, codesize, 0x40111415)
	EmitInteger(codebuffer, codesize, 0x5fc03300)
	
	EmitByte(codebuffer, codesize, 0xeb)
	EmitByte(codebuffer, codesize, 0xd1)
	EmitByte(codebuffer, codesize, 0x68)
	EmitInteger(codebuffer, codesize, HackSize)
	EmitByte(codebuffer, codesize, 0x8d)
	EmitByte(codebuffer, codesize, 0x87)
	EmitInteger(codebuffer, codesize, 0x1000)		// TODO - actual offset of Epoch code beginning (pad for resources)
	EmitByte(codebuffer, codesize, 0x50)
	EmitByte(codebuffer, codesize, 0xff)
	EmitByte(codebuffer, codesize, 0x55)
	
	EmitInteger(codebuffer, codesize, 0x15ff57fc)
	EmitInteger(codebuffer, codesize, 0x0040110c)
	EmitInteger(codebuffer, codesize, 0xec15ff53)
	EmitInteger(codebuffer, codesize, 0x56004010)
	EmitInteger(codebuffer, codesize, 0x10f815ff)
	EmitInteger(codebuffer, codesize, 0x00000040)
	EmitInteger(codebuffer, codesize, 0x00000000)
	
	integer written = 0
	WriteFile(filehandle, codebuffer, codesize, written, 0)
	
	writtenbytes = codesize
}


WriteThunkTable : integer filehandle -> integer writtenbytes = 0
{
	buffer thunkbuffer = 1024
	integer thunksize = 0
	
	// CloseHandle
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x43)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x48)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// CreateFileMappingW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x43)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x67)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// CreateFileW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x43)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// ExitProcess
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x45)
	EmitByte(thunkbuffer, thunksize, 0x78)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x50)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x63)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// GetModuleFileNameW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x47)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x75)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x4e)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x6d)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)

	// GetProcAddress
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x47)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x50)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x63)
	EmitByte(thunkbuffer, thunksize, 0x41)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// LoadLibraryW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x4c)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x4c)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x62)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x79)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// MapViewOfFile
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x56)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x77)
	EmitByte(thunkbuffer, thunksize, 0x4f)
	EmitByte(thunkbuffer, thunksize, 0x66)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// UnmapViewOfFile
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x55)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x6d)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x56)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x77)
	EmitByte(thunkbuffer, thunksize, 0x4f)
	EmitByte(thunkbuffer, thunksize, 0x66)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// kernel32.dll
	EmitByte(thunkbuffer, thunksize, 0x6b)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x33)
	EmitByte(thunkbuffer, thunksize, 0x32)
	EmitByte(thunkbuffer, thunksize, 0x2e)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// MessageBoxW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x67)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x42)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x78)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// user32.dll
	EmitByte(thunkbuffer, thunksize, 0x75)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x33)
	EmitByte(thunkbuffer, thunksize, 0x32)
	EmitByte(thunkbuffer, thunksize, 0x2e)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	EmitInteger(thunkbuffer, thunksize, 0x00001000)
	EmitInteger(thunkbuffer, thunksize, 0x0000100e)
	EmitInteger(thunkbuffer, thunksize, 0x00001023)
	EmitInteger(thunkbuffer, thunksize, 0x00001031)
	EmitInteger(thunkbuffer, thunksize, 0x0000103f)
	EmitInteger(thunkbuffer, thunksize, 0x00001054)
	EmitInteger(thunkbuffer, thunksize, 0x00001065)
	EmitInteger(thunkbuffer, thunksize, 0x00001074)
	EmitInteger(thunkbuffer, thunksize, 0x00001084)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	
	EmitInteger(thunkbuffer, thunksize, 0x000010a3)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	
	// Yes, this appears twice.
	EmitInteger(thunkbuffer, thunksize, 0x00001000)
	EmitInteger(thunkbuffer, thunksize, 0x0000100e)
	EmitInteger(thunkbuffer, thunksize, 0x00001023)
	EmitInteger(thunkbuffer, thunksize, 0x00001031)
	EmitInteger(thunkbuffer, thunksize, 0x0000103f)
	EmitInteger(thunkbuffer, thunksize, 0x00001054)
	EmitInteger(thunkbuffer, thunksize, 0x00001065)
	EmitInteger(thunkbuffer, thunksize, 0x00001074)
	EmitInteger(thunkbuffer, thunksize, 0x00001084)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	
	EmitInteger(thunkbuffer, thunksize, 0x000010a3)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)	
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)
	
	writtenbytes = thunksize
}


WritePadding : integer filehandle, integer startpos, integer desiredpos -> integer writtenbytes = 0
{
	writtenbytes = desiredpos - startpos
	buffer empty = writtenbytes
	integer written = 0
	WriteFile(filehandle, empty, writtenbytes, written, 0)
}


WriteSectionHeader : integer filehandle, string sectionname, integer location, integer virtuallocation, integer sectionsize, integer sectionvirtualsize, integer flags -> integer writtenbytes = 0
{
	print("Writing header for section '" ; sectionname ; "'...")
	
	buffer headerbuffer = 256
	integer headersize = 0
	
	// This is a pitiful hack.
	
	integer count = 0
	assert(length(sectionname) < 8)
	
	while(count < length(sectionname))
	{
		string char = charat(sectionname, count)
		EmitSubstring(headerbuffer, headersize, char, 1)
		
		++count
	}
	
	while(count < 8)
	{
		EmitByte(headerbuffer, headersize, 0)
		++count
	}
	
	// End hack.
  
	EmitInteger(headerbuffer, headersize, sectionsize)
	EmitInteger(headerbuffer, headersize, virtuallocation)
	EmitInteger(headerbuffer, headersize, sectionvirtualsize)
	EmitInteger(headerbuffer, headersize, location)
	EmitInteger(headerbuffer, headersize, 0)
	EmitInteger(headerbuffer, headersize, 0)
	EmitInteger16(headerbuffer, headersize, 0)
	EmitInteger16(headerbuffer, headersize, 0)
	EmitInteger(headerbuffer, headersize, flags)
	
	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)
	
	writtenbytes = headersize
}


WritePEHeader : integer filehandle, integer imagesize, integer resourcesize -> integer writtenbytes = 0
{
	print("Writing PE headers...")
	
	buffer headerbuffer = 1024
	integer headersize = 0

	// Begin DOS header
	EmitInteger16(headerbuffer, headersize, 0x5a4d)		// e_magic
	EmitInteger16(headerbuffer, headersize, 0x90)		// e_cblp
	EmitInteger16(headerbuffer, headersize, 0x03)		// e_cp
	EmitInteger16(headerbuffer, headersize, 0)		// e_crlc
	EmitInteger16(headerbuffer, headersize, 0x04)		// e_cparhdr
	EmitInteger16(headerbuffer, headersize, 0)		// e_minalloc
	EmitInteger16(headerbuffer, headersize, 0xffff)		// e_maxalloc
	EmitInteger16(headerbuffer, headersize, 0)		// e_ss
	EmitInteger16(headerbuffer, headersize, 0xb8)		// e_sp
	EmitInteger16(headerbuffer, headersize, 0)		// e_csum
	EmitInteger16(headerbuffer, headersize, 0)		// e_ip
	EmitInteger16(headerbuffer, headersize, 0)		// e_cs
	EmitInteger16(headerbuffer, headersize, 0x40)		// e_lfarlc
	EmitInteger16(headerbuffer, headersize, 0)		// e_ovno
	
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[0]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[1]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[2]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[3]

	EmitInteger16(headerbuffer, headersize, 0)		// e_oemid
	EmitInteger16(headerbuffer, headersize, 0)		// e_oeminfo
	
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[0]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[1]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[2]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[3]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[4]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[5]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[6]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[7]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[8]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[9]
	
	EmitInteger(headerbuffer, headersize, 0xb0)		// e_lfanew
	
	
	// Begin DOS stub
	EmitByte(headerbuffer, headersize, 0x0e)
	EmitByte(headerbuffer, headersize, 0x1f)
	EmitByte(headerbuffer, headersize, 0xba)
	EmitByte(headerbuffer, headersize, 0x0e)
	EmitByte(headerbuffer, headersize, 0x00)
	EmitByte(headerbuffer, headersize, 0xb4)
	EmitByte(headerbuffer, headersize, 0x09)
	EmitByte(headerbuffer, headersize, 0xcd)
	EmitByte(headerbuffer, headersize, 0x21)
	EmitByte(headerbuffer, headersize, 0xb8)
	EmitByte(headerbuffer, headersize, 0x01)
	EmitByte(headerbuffer, headersize, 0x4c)
	EmitByte(headerbuffer, headersize, 0xcd)
	EmitByte(headerbuffer, headersize, 0x21)

	EmitByte(headerbuffer, headersize, 0x54)
	EmitByte(headerbuffer, headersize, 0x68)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x73)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x70)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x67)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x61)
	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x69)

	EmitByte(headerbuffer, headersize, 0x73)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x66)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x68)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x66)
	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x74)

	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x2e)
	EmitByte(headerbuffer, headersize, 0x0d)
	EmitByte(headerbuffer, headersize, 0x0a)
	EmitByte(headerbuffer, headersize, 0x49)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x77)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x6c)
	EmitByte(headerbuffer, headersize, 0x6c)
	EmitByte(headerbuffer, headersize, 0x20)

	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x79)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x75)

	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x70)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x76)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x63)
	EmitByte(headerbuffer, headersize, 0x6f)

	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x70)
	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x67)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x64)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x76)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x63)
	EmitByte(headerbuffer, headersize, 0x65)

	EmitByte(headerbuffer, headersize, 0x2e)
	EmitByte(headerbuffer, headersize, 0x0d)
	EmitByte(headerbuffer, headersize, 0x0a)
	EmitByte(headerbuffer, headersize, 0x24)
	
	EmitPadding(headerbuffer, headersize, 0xb0)
	
	
	// Begin NT headers
	EmitInteger(headerbuffer, headersize, 0x00004550)
	EmitInteger16(headerbuffer, headersize, 0x014c)			// Machine
	EmitInteger16(headerbuffer, headersize, 5)			// NumberOfSections
	EmitInteger(headerbuffer, headersize, 0x00000000)		// TimeDateStamp
	EmitInteger(headerbuffer, headersize, 0)			// PointerToSymbolTable
	EmitInteger(headerbuffer, headersize, 0)			// NumberOfSymbols
	EmitInteger16(headerbuffer, headersize, 0xe0)			// SizeOfOptionalHeader
	EmitInteger16(headerbuffer, headersize, 0x0103)			// Characteristics

	EmitInteger16(headerbuffer, headersize, 0x010b)			// Magic
	EmitByte(headerbuffer, headersize, 0x02)			// MajorLinkerVersion
	EmitByte(headerbuffer, headersize, 0x00)			// MinorLinkerVersion
	
	EmitInteger(headerbuffer, headersize, 0x1000)			// SizeOfCode
	EmitInteger(headerbuffer, headersize, 0x1000)			// SizeOfInitializedData
	EmitInteger(headerbuffer, headersize, 0)			// SizeOfUninitializedData
	EmitInteger(headerbuffer, headersize, 0x2000)			// AddressOfEntryPoint
	EmitInteger(headerbuffer, headersize, 0x800)			// BaseOfCode
	EmitInteger(headerbuffer, headersize, 0x1000)			// BaseOfData
	
	EmitInteger(headerbuffer, headersize, 0x400000)			// ImageBase
	EmitInteger(headerbuffer, headersize, 0x1000)			// SectionAlignment
	EmitInteger(headerbuffer, headersize, 0x200)			// FileAlignment
	
	EmitInteger16(headerbuffer, headersize, 0x04)			// MajorOperatingSystemVersion
	EmitInteger16(headerbuffer, headersize, 0x00)			// MinorOperatingSystemVersion
	EmitInteger16(headerbuffer, headersize, 0)			// MajorImageVersion
	EmitInteger16(headerbuffer, headersize, 0)			// MinorImageVersion
	EmitInteger16(headerbuffer, headersize, 0x04)			// MajorSubsystemVersion
	EmitInteger16(headerbuffer, headersize, 0x00)			// MinorSubsystemVersion

	EmitInteger(headerbuffer, headersize, 0)			// Win32VersionValue
	EmitInteger(headerbuffer, headersize, imagesize)		// SizeOfImage
	EmitInteger(headerbuffer, headersize, 0x400)			// SizeOfHeaders
	EmitInteger(headerbuffer, headersize, 0xf00d)			// Checksum
	
	EmitInteger16(headerbuffer, headersize, 3)			// Subsystem
	EmitInteger16(headerbuffer, headersize, 0)			// DllCharacteristics

	EmitInteger(headerbuffer, headersize, 0x10000)			// SizeOfStackReserve
	EmitInteger(headerbuffer, headersize, 0x1000)			// SizeOfStackCommit
	EmitInteger(headerbuffer, headersize, 0x10000)			// SizeOfHeapReserve
	EmitInteger(headerbuffer, headersize, 0x1000)			// SizeOfHeapCommit
	EmitInteger(headerbuffer, headersize, 0)			// LoaderFlags
	EmitInteger(headerbuffer, headersize, 0x10)			// NumberOfRvaAndSizes
	
	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 1
	EmitInteger(headerbuffer, headersize, 0)			// Size
	
	EmitInteger(headerbuffer, headersize, 0x1200)			// RVA virtual address 2
	EmitInteger(headerbuffer, headersize, 0x28)			// Size

	EmitInteger(headerbuffer, headersize, 0x4000)			// RVA virtual address 3
	EmitInteger(headerbuffer, headersize, resourcesize)		// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 4
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 5
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 6
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 7
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 8
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 9
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 10
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 11
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 12
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 13
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 14
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 15
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 16
	EmitInteger(headerbuffer, headersize, 0)			// Size


	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)
	
	writtenbytes = headersize
}


EmitInteger : buffer ref b, integer ref size, integer value
{
	writebuffer(b, size, (value) & 0xff)
	++size
	writebuffer(b, size, (value / 0x100) & 0xff)
	++size
	writebuffer(b, size, (value / 0x10000) & 0xff)
	++size
	writebuffer(b, size, (value / 0x1000000) & 0xff)
	++size
}

EmitInteger16 : buffer ref b, integer ref size, integer16 value
{
	integer v = cast(integer, value)
	writebuffer(b, size, (v) & 0xff)
	++size
	writebuffer(b, size, (v / 0x100) & 0xff)
	++size
}

EmitByte : buffer ref b, integer ref size, integer value
{
	writebuffer(b, size, (value) & 0xff)
	++size
}

EmitPadding : buffer ref b, integer ref size, integer targetsize
{
	while(size < targetsize)
	{
		EmitByte(b, size, 0x00)
	}
}

EmitSubstring : buffer ref b, integer ref size, string s, integer bytes
{
	writebuffer(b, size, s, bytes)
	size += bytes
}




DumpOverloadList : list<Overload> ref overloads
{
	DumpOverload(overloads.value)
	DumpOverloadList(overloads.next)
}

DumpOverloadList : nothing

DumpOverload : Overload ref overload
{
	print(GetPooledString(GlobalStrings, overload.NormalName) ; " -> " ; GetPooledString(GlobalStrings, overload.MangledName))
}


//
// Global state (just a hack while we bootstrap!)
//

global
{
	buffer Hack = 8192000
	integer HackSize = 0

	list<StringTableEntry> GlobalStrings = StringTableEntry(0, ""), nothing

	Variable dummyvar = 0, 0, 0, 0
	list<Variable> dummyvarlist = dummyvar, nothing
	Scope dummyscope = 0, 0, dummyvarlist, 0, 0
	list<Scope> Scopes = dummyscope, nothing
	
	Overload dummyoverload = 0, 0
	list<Overload> Overloads = dummyoverload, nothing

	FunctionDefinition dummyfunc = 0, 0, false, nothing, nothing, false, 0, nothing, false
	list<FunctionDefinition> Functions = dummyfunc, nothing

	SumTypeBase dummybasetype = 0, nothing
	list<SumTypeBase> dummybases = dummybasetype, nothing
	SumType dummysumtype = 0, 0, dummybases, false
	list<SumType> SumTypes = dummysumtype, nothing


	StructureMemberVariable dummymember = 0, 0, 0, nothing
	list<StructureMember> dummymembers = dummymember, nothing
	StructureDefinition dummystruct = 0, 0, 0, 0, 0, dummymembers, false
	list<StructureDefinition> Structures = dummystruct, nothing


	// TODO - convert to an enumeration
	integer STACK_TYPE_GLOBAL = 0
	integer STACK_TYPE_FUNCTION = 1
	integer STACK_TYPE_CODEBLOCK = 2
	integer STACK_TYPE_STATEMENT = 3
	integer STACK_TYPE_ASSIGNMENT = 4
	integer STACK_TYPE_TYPEMATCH = 5
	integer STACK_TYPE_SUBSTATEMENT = 6
	integer STACK_TYPE_FUNCRET = 7
	integer STACK_TYPE_ENTITY_PARAM = 8
	integer STACK_TYPE_ENTITY_CODE = 9
	integer STACK_TYPE_CHAIN = 10
	integer STACK_TYPE_PARENTHETICAL = 11

	ContextStackEntry GlobalStackEntry = STACK_TYPE_GLOBAL, 0
	list<ContextStackEntry> ContextStack = GlobalStackEntry, nothing

	AtomSentinel dummysentinel = 0
	list<ExpressionAtom> dummyatomlist = dummysentinel, nothing
	Expression dummyexpression = dummyatomlist, 0
	list<Expression> ScratchExpressions = dummyexpression, nothing
	Statement dummystatement = 0, nothing, 0, false, nothing
	list<Statement> SubStatements = dummystatement, nothing

	Parameter dummyparam = 0, 0
	list<Parameter> dummyparamlist = dummyparam, nothing
	FunctionSignature dummysignature = 0, dummyparamlist, 0
	list<FunctionSignature> dummysignaturelist = dummysignature, nothing
	TypeMatcher dummytypematch = 0, dummysignaturelist
	list<TypeMatcher> TypeMatchers = dummytypematch, nothing

	Entity dummyentity = 0, 0, nothing, nothing
	list<Entity> EntityStack = dummyentity, nothing


	list<string> dummytagparams = "", nothing
	FunctionTag dummytag = 0, "", dummytagparams
	list<FunctionTag> FunctionTags = dummytag, nothing

	integer EmittingFunctionName = 0

	list<OptionalCodeBlock> CurrentCodeBlockStack = nothing, nothing

	list<CodeBlockEntry> dummyblockentries = dummystatement, nothing
	CodeBlock GlobalCodeBlock = dummyblockentries
	integer GlobalCodeBlockName = 0

	list<Entity> chaincontents = dummyentity, nothing
	OptionalEntityList chaincontentswrap = chaincontents
	EntityChain dummychain = chaincontentswrap
	list<EntityChain> ChainStack = dummychain, nothing


	simplelist<integer> AutoGeneratedFunctionNames = 0, nothing
	simplelist<integer> CustomConstructors = 0, nothing

	TypeAlias dummyalias = 0, 0, 0
	list<TypeAlias> TypeAliases = dummyalias, nothing
	
	TypeAlias dummyweak = 0, 0, 0
	list<TypeAlias> TypeWeakAliases = dummyweak, nothing

	list<FunctionSignature> FunctionSignatures = dummysignature, nothing

	boolean InFuncRetHack = false

	integer CurrentStringHandle = 0

	simplelist<integer> scratchpossibletypes = 0, nothing
	TypePossibilityList scratchreturns = scratchpossibletypes, false
	TypePossibilityList scratchparams = scratchpossibletypes, false
	list<TypePossibilityList> scratchparampossibles = scratchparams, nothing
	InferencePossibility scratchpossibility = 0, scratchparampossibles, scratchreturns
	
	PendingTypeMatcher dummypending = 0, 0
	list<PendingTypeMatcher> PendingTypeMatchers = dummypending, nothing
	
	PendingPatternMatcher dummypatternpending = 0, 0, 0
	list<PendingPatternMatcher> PendingPatternMatchers = dummypatternpending, nothing

	simplelist<string> TokenStream = "", nothing
	tailhack TokenStreamTail = TokenStream

	simplelist<integer> EmittedPatternMatchers = 0, nothing

	TemplateParameter scratchtemplateparam = 0, 0
	list<TemplateParameter> TemplateParameterQueue = scratchtemplateparam, nothing

	list<TemplateParameter> dummytemplateparams = scratchtemplateparam, nothing
	TemplateFunction dummyfunctemplate = 0, dummytemplateparams
	list<TemplateFunction> TemplateFunctions = dummyfunctemplate, nothing

	TemplateArgument scratchtemplatearg = 0
	list<TemplateArgument> scratchtemplateargs = scratchtemplatearg, nothing
	TemplateArgumentList scratchtemplatearglist = scratchtemplateargs
	list<TemplateArgumentList> ScratchTemplateArgumentStack = scratchtemplatearglist, nothing

	TemplateInstance dummytemplateinst = 0, 0, scratchtemplateargs
	list<TemplateInstance> TemplateFunctionInstances = dummytemplateinst, nothing
	list<TemplateInstance> TemplateStructureInstances = dummytemplateinst, nothing
	list<TemplateInstance> TemplateSumTypeInstances = dummytemplateinst, nothing

	TemplateStructure dummystructuretemplate = 0, dummytemplateparams
	list<TemplateStructure> TemplateStructures = dummystructuretemplate, nothing
	
	TemplateSumType dummysumtypetemplate = 0, dummytemplateparams
	list<TemplateSumType> TemplateSumTypes = dummysumtypetemplate, nothing
	
	simplelist<integer> dummycompound = 0, nothing
	PreOpStatement PreOpOnDeck = 0, dummycompound, 0
	PostOpStatement PostOpOnDeck = 0, dummycompound, 0

	integer CHARACTER_CLASS_WHITE = 0
	integer CHARACTER_CLASS_IDENTIFIER = 1
	integer CHARACTER_CLASS_PUNCTUATION = 2
	integer CHARACTER_CLASS_COMMENT = 3
	integer CHARACTER_CLASS_PUNCTUATION_COMPOUND = 4
	integer CHARACTER_CLASS_STRING_LITERAL = 5
	integer CHARACTER_CLASS_LITERAL = 6

	integer GlobalStructureCounter = 0x03000000
	integer GlobalWeakAliasCounter = 0x04000000
	integer GlobalAliasCounter = 0x05000000
	integer GlobalSumTypeCounter = 0x07000000
	integer GlobalTemplateInstanceCounter = 0x08000000
	integer GlobalFunctionTypeCounter = 0x09000000
}


