//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//



//
// Singly linked list data structures
//

type simplelistnode<type T> : simplelist<T> | nothing

structure simplelist<type T> :
	T value,
	simplelistnode<T> next


type listnode<type T> : list<T> | nothing

structure list<type T> :
	T ref value,
	listnode<T> next


//
// List manipulation functions
//

simpleprepend<type T> : simplelist<T> ref thelist, T value [nogc]
{
	simplelist<T> newlist = value, thelist
	thelist = newlist
}

prepend<type T> : list<T> ref thelist, T ref value [nogc]
{
	list<T> newlist = value, thelist
	thelist = newlist
}


CloseHandle : integer handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]
CreateFile : string filename, integer access, integer sharemode, integer attributes, integer creation, integer flags, integer template -> integer ret = 0 [external("Kernel32.dll", "CreateFileW", "stdcall")]
CreateFileMapping : integer filehandle, integer attributes, integer protection, integer maxsizehigh, integer maxsizelow, integer name -> integer ret = 0 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
MapViewOfFile : integer handle, integer access, integer offsethigh, integer offsetlow, integer bytestomap -> integer ptr = 0 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]
UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]
GetFileSize : integer handle, integer ignored -> integer size = 0 [external("Kernel32.dll", "GetFileSize", "stdcall")]


timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime", "stdcall")]

structure largeint :
	integer low,
	integer high

QueryPerformanceCounter : largeint ref out -> boolean ret = false [external("Kernel32.dll", "QueryPerformanceCounter", "stdcall")]
QueryPerformanceFrequency : largeint ref out -> boolean ret = false [external("Kernel32.dll", "QueryPerformanceFrequency", "stdcall")]


ExecuteByteCodeBuffer : buffer ref code, integer len [external("EpochRuntime.dll", "ExecuteByteCodeDeferred", "stdcall")]



simple_append_recurse<type T> : simplelist<T> ref thelist, nothing, T value [nogc]
{
	simplelist<T> newlist = value, nothing
	thelist.next = newlist
}

simple_append_recurse<type T> : simplelist<T> ref thelist, simplelist<T> ref tail, T value [nogc]
{
	simple_append_recurse<T>(tail, tail.next, value)
}


simple_append<type T> : simplelist<T> ref thelist, T value [nogc]
{
	simple_append_recurse<T>(thelist, thelist.next, value)
}



entrypoint :
{
	print("Epoch Language Project")
	print("Command line compiler and tools interface")
	print("")

	if(cmdlineisvalid() && (cmdlinegetcount() > 1))
	{
		boolean makeexe = false
		
		string filename = cmdlineget(1)
		if(filename == "make")
		{
			filename = cmdlineget(2)
			makeexe = true
		}
		else
		{
			print("Executing: " ; filename)
			print("")
		}

		integer len = 0
		string contents = ReadFile(filename, len)
		
		if(len == 0)
		{
			return()
		}

		PrepareStringTable()
		InitBuiltInOverloads()
		
		largeint startqpc = 0, 0
		QueryPerformanceCounter(startqpc)

		integer startparsems = timeGetTime()
		boolean parseok = Parse(contents, len)
		integer durationparsems = timeGetTime() - startparsems

		print("Parsing completed in " ; cast(string, durationparsems) ; " milliseconds")
		if(!parseok)
		{
			return()
		}

		integer startprocessms = timeGetTime()
		boolean irok = IRProcess()
		integer durationprocessms = timeGetTime() - startprocessms

		print("Semantic analysis completed in " ; cast(string, durationprocessms) ; " milliseconds")
		if(!irok)
		{
			return()
		}

		integer startcodegenms = timeGetTime()
		OnCodeGenProcessProgram()
		integer durationcodegenms = timeGetTime() - startcodegenms

		print("Code generation completed in " ; cast(string, durationcodegenms) ; " milliseconds")
		print("")

		if(makeexe)
		{
			MakeExe("test.exe")
			
			largeint endqpc = 0, 0
			QueryPerformanceCounter(endqpc)
			
			integer stupidguess = endqpc.low - startqpc.low
			
			largeint freq = 0, 0
			QueryPerformanceFrequency(freq)
			
			integer duration = stupidguess * 1000 / freq.low
			
			print(cast(string, duration) ; " milliseconds elapsed")
		}
		else
		{
			ExecuteByteCodeBuffer(Hack, HackSize)
		}
	}
	else
	{
		print("Please specify a program to execute!")
	}
}


PrepareStringTable :
{
	integer counter = 0
	OnCodeGenRegisterString((++counter), "+")
	PooledStringHandleForPlus = counter
	
	OnCodeGenRegisterString((++counter), "-")
	PooledStringHandleForMinus = counter
	
	OnCodeGenRegisterString((++counter), "*")
	PooledStringHandleForMultiply = counter
	
	OnCodeGenRegisterString((++counter), "/")
	PooledStringHandleForDivide = counter
	
	OnCodeGenRegisterString((++counter), "+=@@real")
	
	OnCodeGenRegisterString((++counter), "+@@real")
	PooledStringHandleForPlusReal = counter
	
	OnCodeGenRegisterString((++counter), "-=@@real")
	OnCodeGenRegisterString((++counter), "-@@real")
	OnCodeGenRegisterString((++counter), "*@@real")
	OnCodeGenRegisterString((++counter), "/@@real")
	
	OnCodeGenRegisterString((++counter), "+=@@integer")
	PooledStringHandleForIncrementAssignInteger = counter
	
	OnCodeGenRegisterString((++counter), "+@@integer")
	PooledStringHandleForPlusInteger = counter
	
	OnCodeGenRegisterString((++counter), "-=@@integer")
	PooledStringHandleForDecrementAssignInteger = counter
	
	OnCodeGenRegisterString((++counter), "-@@integer")
	PooledStringHandleForMinusInteger = counter
	
	OnCodeGenRegisterString((++counter), "*@@integer")
	PooledStringHandleForMultiplyInteger = counter
	
	OnCodeGenRegisterString((++counter), "/@@integer")
	PooledStringHandleForDivideInteger = counter
	
	OnCodeGenRegisterString((++counter), "++@@integer")
	PooledStringHandleForPrePostIncrementInteger = counter
	
	OnCodeGenRegisterString((++counter), "--@@integer")
	PooledStringHandleForPrePostDecrementInteger = counter
	
	OnCodeGenRegisterString((++counter), "!@@integer")
	OnCodeGenRegisterString((++counter), "++@@real")
	OnCodeGenRegisterString((++counter), "--@@real")
	
	OnCodeGenRegisterString((++counter), "+=")
	PooledStringHandleForIncrementAssign = counter
	
	OnCodeGenRegisterString((++counter), "-=")
	PooledStringHandleForDecrementAssign = counter
	
	OnCodeGenRegisterString((++counter), "!")
	PooledStringHandleForUnaryNot = counter
	
	OnCodeGenRegisterString((++counter), "++")
	PooledStringHandleForPrePostIncrement = counter
	
	OnCodeGenRegisterString((++counter), "--")
	PooledStringHandleForPrePostDecrement = counter
	
	OnCodeGenRegisterString((++counter), "&")
	PooledStringHandleForBitwiseAnd = counter
	
	OnCodeGenRegisterString((++counter), "&&")
	PooledStringHandleForBooleanAnd = counter
	
	OnCodeGenRegisterString((++counter), "!@@boolean")
	PooledStringHandleForUnaryNotBoolean = counter
	
	OnCodeGenRegisterString((++counter), "cmdlineisvalid")
	PooledStringHandleForCmdLineIsValid = counter
	
	OnCodeGenRegisterString((++counter), "cmdlinegetcount")
	PooledStringHandleForCmdLineGetCount = counter
	
	OnCodeGenRegisterString((++counter), "cmdlineget")
	PooledStringHandleForCmdLineGet = counter
	
	OnCodeGenRegisterString((++counter), "==")
	PooledStringHandleForEquality = counter
	
	OnCodeGenRegisterString((++counter), "!=")
	PooledStringHandleForInequality = counter
	
	OnCodeGenRegisterString((++counter), ">")
	PooledStringHandleForGreaterThan = counter
	
	OnCodeGenRegisterString((++counter), "<")
	PooledStringHandleForLessThan = counter
	
	OnCodeGenRegisterString((++counter), "==@@integer")
	PooledStringHandleForEqualityInteger = counter
	
	OnCodeGenRegisterString((++counter), "==@@integer16")
	PooledStringHandleForEqualityInteger16 = counter

	OnCodeGenRegisterString((++counter), "!=@@integer")
	PooledStringHandleForInequalityInteger = counter

	OnCodeGenRegisterString((++counter), "==@@boolean")
	PooledStringHandleForEqualityBoolean = counter

	OnCodeGenRegisterString((++counter), "!=@@boolean")
	PooledStringHandleForInequalityBoolean = counter
	
	OnCodeGenRegisterString((++counter), "==@@string")
	PooledStringHandleForEqualityString = counter
	
	OnCodeGenRegisterString((++counter), "!=@@string")
	PooledStringHandleForInequalityString = counter
	
	OnCodeGenRegisterString((++counter), "==@@real")
	PooledStringHandleForEqualityReal = counter
	
	OnCodeGenRegisterString((++counter), ">@@integer")
	PooledStringHandleForGreaterThanInteger = counter
	
	OnCodeGenRegisterString((++counter), "<@@integer")
	PooledStringHandleForLessThanInteger = counter
	
	OnCodeGenRegisterString((++counter), ">@@real")
	OnCodeGenRegisterString((++counter), "<@@real")
	
	OnCodeGenRegisterString((++counter), "print")
	PooledStringHandleForPrint = counter
	
	OnCodeGenRegisterString((++counter), "read")
	
	OnCodeGenRegisterString((++counter), "assert")
	PooledStringHandleForAssert = counter
	
	OnCodeGenRegisterString((++counter), "passtest")
	PooledStringHandleForPassTest = counter
	
	OnCodeGenRegisterString((++counter), "sqrt")
	OnCodeGenRegisterString((++counter), "plotpixel")
	OnCodeGenRegisterString((++counter), "breakpoint")
	OnCodeGenRegisterString((++counter), "if")
	OnCodeGenRegisterString((++counter), "elseif")
	OnCodeGenRegisterString((++counter), "else")
	OnCodeGenRegisterString((++counter), "while")
	OnCodeGenRegisterString((++counter), "do")
	OnCodeGenRegisterString((++counter), "return")
	OnCodeGenRegisterString((++counter), "constructor")
	OnCodeGenRegisterString((++counter), "external")
	OnCodeGenRegisterString((++counter), "@@external")
	OnCodeGenRegisterString((++counter), "nogc")
	OnCodeGenRegisterString((++counter), "sizeof")
	OnCodeGenRegisterString((++counter), "marshalstructure")
	
	OnCodeGenRegisterString((++counter), "writebuffer")
	PooledStringHandleForWriteBuffer = counter
	
	OnCodeGenRegisterString((++counter), "writebuffer@@string")
	PooledStringHandleForWriteBufferString = counter
	
	OnCodeGenRegisterString((++counter), "writebuffer@@multiple")
	PooledStringHandleForWriteBufferMultiple = counter
	
	OnCodeGenRegisterString((++counter), "writebuffer@@real")
	PooledStringHandleForWriteBufferReal = counter
	
	OnCodeGenRegisterString((++counter), "unescape")
	PooledStringHandleForUnescape = counter
	
	OnCodeGenRegisterString((++counter), "substring")
	PooledStringHandleForSubstring = counter
	
	OnCodeGenRegisterString((++counter), "substring@@withlength")
	PooledStringHandleForSubstringWithLength = counter
	
	OnCodeGenRegisterString((++counter), "substring@@nolength")
	PooledStringHandleForSubstringNoLength = counter
	
	OnCodeGenRegisterString((++counter), "subchar")
	PooledStringHandleForSubchar = counter
	
	OnCodeGenRegisterString((++counter), ";")
	PooledStringHandleForStringConcat = counter
	
	OnCodeGenRegisterString((++counter), "length")
	PooledStringHandleForLength = counter
	
	OnCodeGenRegisterString((++counter), "narrowstring")
	PooledStringHandleForNarrowString = counter
	
	OnCodeGenRegisterString((++counter), "widenfromptr")
	PooledStringHandleForWidenFromPtr = counter
	
	OnCodeGenRegisterString((++counter), "widenfrombuffer")
	
	OnCodeGenRegisterString((++counter), "string")
	PooledStringHandleForString = counter

	OnCodeGenRegisterString((++counter), "integer")
	PooledStringHandleForInteger = counter

	OnCodeGenRegisterString((++counter), "integer16")
	PooledStringHandleForInteger16 = counter
	
	OnCodeGenRegisterString((++counter), "real")
	PooledStringHandleForReal = counter
	
	OnCodeGenRegisterString((++counter), "cast@@integer_to_string")
	PooledStringHandleForCastIntegerToString = counter
	
	OnCodeGenRegisterString((++counter), "cast@@string_to_integer")
	PooledStringHandleForCastStringToInteger = counter
	
	OnCodeGenRegisterString((++counter), "cast@@real_to_integer")
	PooledStringHandleForCastRealToInteger = counter
	
	OnCodeGenRegisterString((++counter), "cast@@integer_to_real")
	OnCodeGenRegisterString((++counter), "cast@@boolean_to_string")
	
	OnCodeGenRegisterString((++counter), "cast@@real_to_string")
	PooledStringHandleForCastRealToString = counter
	
	OnCodeGenRegisterString((++counter), "cast@@buffer_to_string")
	
	OnCodeGenRegisterString((++counter), "cast@@boolean_to_integer")
	PooledStringHandleForCastBooleanToInteger = counter
	
	OnCodeGenRegisterString((++counter), "cast@@integer_to_integer16")
	PooledStringHandleForCastIntegerToInteger16 = counter
	
	OnCodeGenRegisterString((++counter), "cast@@integer16_to_integer")
	PooledStringHandleForCastInteger16ToInteger = counter
	
	OnCodeGenRegisterString((++counter), "cast@@string_to_real")
	PooledStringHandleForCastStringToReal = counter
	
	OnCodeGenRegisterString((++counter), "boolean")
	PooledStringHandleForBoolean = counter
	
	OnCodeGenRegisterString((++counter), "buffer")
	PooledStringHandleForBuffer = counter
	
	OnCodeGenRegisterString((++counter), "nothing")
	PooledStringHandleForNothing = counter
	
	OnCodeGenRegisterString((++counter), "buffer@@copy")
	
	OnCodeGenRegisterString((++counter), "cast")
	PooledStringHandleForCast = counter
	
	OnCodeGenRegisterString((++counter), ".")
	PooledStringHandleForMemberAccess = counter
	
	OnCodeGenRegisterString((++counter), "identifier")
	PooledStringHandleForIdentifier = counter
	
	OnCodeGenRegisterString((++counter), "function")
	
	OnCodeGenRegisterString((++counter), "@@anonymousret")
	PooledStringHandleForAnonymousRet = counter

	OnCodeGenRegisterString((++counter), "=")
	PooledStringHandleForAssignment = counter
	
	CurrentStringHandle = counter + 1
	FirstNonBuiltInStringHandle = CurrentStringHandle
}


ReadFile : string filename, integer ref len -> string contents = ""
{
	integer INVALID_HANDLE_VALUE = 0xffffffff
	integer FILE_SHARE_READ = 0x01
	integer OPEN_EXISTING = 3
	integer GENERIC_READ = 0x80000000

	integer filehandle = CreateFile(filename, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0)
	if(filehandle != INVALID_HANDLE_VALUE)
	{
		integer PAGE_READONLY = 0x02
		
		len = GetFileSize(filehandle, 0)

		if(len > 0)
		{
			integer mappinghandle = CreateFileMapping(filehandle, 0, PAGE_READONLY, 0, 0, 0)
			if(mappinghandle != 0)
			{
				integer FILE_MAP_READ = 0x04
				integer ptr = MapViewOfFile(mappinghandle, FILE_MAP_READ, 0, 0, len)

				if(ptr != 0)
				{
					contents = widenfromptr(ptr, len)
				}
				CloseHandle(mappinghandle)
			}
			else
			{
				print("Failed to map file!")
			}
		}
		else
		{
			contents = ""
		}
		CloseHandle(filehandle)
	}
	else
	{
		print("Couldn't open that file!")
	}
}


Parse : string code, integer len -> boolean success = false
{
	Lex(code, len)

	// Discard the dummy token
	PopToken()

	IREnterProgram()

	string token = PeekToken(0)
	while(token != "")
	{
		if(ParseSumType())
		{
		}
		elseif(ParseWeakAlias())
		{
		}
		elseif(ParseStrongAlias())
		{
		}
		elseif(ParseStructure())
		{
		}
		elseif(ParseGlobalBlock())
		{
		}
		elseif(!ParseFunction())
		{
			print("Error: code could not be parsed: " ; token ; " " ; PeekToken(1) ; " " ; PeekToken(2))
			return()
		}

		token = PeekToken(0)
	}

	IRExitProgram()
	success = true
}


// Evil, evil, evil hack
EpochLib_SubstrCharDirect : integer pointer, integer pos -> integer ch = 0 [external("EpochLibrary.dll", "EpochLib_SubstrCharDirect"), nogc]
EpochLib_StrPointer : string s -> integer pointer = 0 [external("EpochLibrary.dll", "EpochLib_StrPointer"), nogc]
EpochLib_SubstrDirect : integer pointer, integer pos, integer length -> string s = "" [external("EpochLibrary.dll", "EpochLib_SubstrDirect"), nogc]

Lex : string code, integer len [nogc]
{
	integer index = 0
	integer lasttokenstart = 0

	integer state = CHARACTER_CLASS_WHITE
	integer prevstate = CHARACTER_CLASS_WHITE
	
	integer codeptr = EpochLib_StrPointer(code)
	
	while(index < len)
	{
		integer c = EpochLib_SubstrCharDirect(codeptr, index)

		if(state == CHARACTER_CLASS_WHITE)
		{
			if((c == CharacterSlash) && (EpochLib_SubstrCharDirect(codeptr, index + 1) == CharacterSlash))
			{
				state = CHARACTER_CLASS_COMMENT
			}
			elseif(!IsWhitespace(c))
			{
				state = Classify(c, state)
				lasttokenstart = index
			}
		}
		elseif(state == CHARACTER_CLASS_IDENTIFIER)
		{
			boolean notidentifier = false
			if(IsWhitespace(c))
			{
				notidentifier = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_IDENTIFIER)
			{
				notidentifier = true
				state = Classify(c, state)
			}

			if(notidentifier)
			{
				PushToken(EpochLib_SubstrDirect(codeptr, lasttokenstart, index - lasttokenstart))
			}
		}
		elseif(state == CHARACTER_CLASS_PUNCTUATION)
		{
			if(IsWhitespace(c))
			{
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_PUNCTUATION)
			{
				state = Classify(c, state)
			}

			PushToken(EpochLib_SubstrDirect(codeptr, lasttokenstart, index - lasttokenstart))
			lasttokenstart = index
		}
		elseif(state == CHARACTER_CLASS_PUNCTUATION_COMPOUND)
		{
			boolean notcompound = false
			if(IsWhitespace(c))
			{
				notcompound = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_PUNCTUATION_COMPOUND)
			{
				notcompound = true
				state = Classify(c, state)
			}
			else
			{
				if((index - lasttokenstart) > 1)
				{
					string potentialtoken = EpochLib_SubstrDirect(codeptr, lasttokenstart, index - lasttokenstart)
					if(!IsValidPunctuation(potentialtoken))
					{
						PushToken(substring(potentialtoken, 0, length(potentialtoken) - 1))
						lasttokenstart = index - 1
					}
				}
			}

			if(notcompound)
			{
				if((index - lasttokenstart) > 1)
				{
					string potentialtoken = EpochLib_SubstrDirect(codeptr, lasttokenstart, index - lasttokenstart)
					if(!IsValidPunctuation(potentialtoken))
					{
						PushToken(substring(potentialtoken, 0, length(potentialtoken) - 1))
						lasttokenstart = index - 1						
					}
				}
				
				PushToken(EpochLib_SubstrDirect(codeptr, lasttokenstart, index - lasttokenstart))
			}
		}
		elseif(state == CHARACTER_CLASS_COMMENT)
		{
			if(c == CharacterCarriageReturn)
			{
				state = CHARACTER_CLASS_WHITE
			}
			elseif(c == CharacterLineFeed)
			{
				state = CHARACTER_CLASS_WHITE
			}
		}
		elseif(state == CHARACTER_CLASS_STRING_LITERAL)
		{
			if(c == CharacterQuote)
			{
				state = CHARACTER_CLASS_WHITE
				PushToken(EpochLib_SubstrDirect(codeptr, lasttokenstart, index - lasttokenstart + 1))
			}
		}
		elseif(state == CHARACTER_CLASS_LITERAL)
		{
			boolean notliteral = false
			if(IsWhitespace(c))
			{
				notliteral = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_LITERAL)
			{
				notliteral = true
				state = Classify(c, state)
			}

			if(notliteral)
			{
				PushToken(EpochLib_SubstrDirect(codeptr, lasttokenstart, index - lasttokenstart))
			}
		}
		
		// Handle negated literals (slightly hacky)
		if(state == CHARACTER_CLASS_PUNCTUATION_COMPOUND)
		{
			if(Classify(EpochLib_SubstrCharDirect(codeptr, index + 1), state) == CHARACTER_CLASS_LITERAL)
			{
				state = CHARACTER_CLASS_LITERAL
			}
		}


		if(state != prevstate)
		{
			lasttokenstart = index
		}

		prevstate = state
		++index
	}

	if((lasttokenstart < len) && (state != CHARACTER_CLASS_WHITE))
	{		
		PushToken(EpochLib_SubstrDirect(codeptr, lasttokenstart, len - lasttokenstart))
	}
}


IsValidPunctuation : string token -> boolean valid = false [nogc]
{
	if(token == "==")
	{
		valid = true
	}
	elseif(token == "!=")
	{
		valid = true
	}
	elseif(token == "++")
	{
		valid = true
	}
	elseif(token == "--")
	{
		valid = true
	}
	elseif(token == "->")
	{
		valid = true
	}
	elseif(token == "&&")
	{
		valid = true
	}
	elseif(token == "+=")
	{
		valid = true
	}
	elseif(token == "-=")
	{
		valid = true
	}	
}


IsWhitespace : integer c -> boolean white = false [nogc]
{
	if(c == CharacterSpace)
	{
		white = true
	}
	elseif(c == CharacterCarriageReturn)
	{
		white = true
	}
	elseif(c == CharacterLineFeed)
	{
		white = true
	}
	elseif(c == CharacterTab)
	{
		white = true
	}
}

Classify : integer c, integer currentclass -> integer class = CHARACTER_CLASS_IDENTIFIER [nogc]
{
	if(c == CharacterA)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == CharacterB)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == CharacterC)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == CharacterD)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == CharacterE)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == CharacterF)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}
	elseif(c == CharacterZero)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterOne)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterTwo)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterThree)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterFour)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterFive)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterSix)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterSeven)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterEight)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterNine)
	{
		if(currentclass == CHARACTER_CLASS_IDENTIFIER)
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
		else
		{
			class = CHARACTER_CLASS_LITERAL
		}
	}
	elseif(c == CharacterX)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_IDENTIFIER
		}
	}

	elseif(c == CharacterOpenBrace)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterCloseBrace)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterColon)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterOpenParen)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterCloseParen)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterEquals)
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == CharacterAmpersand)
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == CharacterComma)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterQuote)
	{
		class = CHARACTER_CLASS_STRING_LITERAL
	}
	elseif(c == CharacterPlus)
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == CharacterMinus)
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == CharacterLessThan)
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == CharacterGreaterThan)
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == CharacterDot)
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		elseif(currentclass == CHARACTER_CLASS_PUNCTUATION_COMPOUND)
		{
			class = CHARACTER_CLASS_PUNCTUATION_COMPOUND		// hack!
		}
		else
		{
			class = CHARACTER_CLASS_PUNCTUATION
		}
	}
	elseif(c == CharacterSemicolon)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterExclamation)
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == CharacterOpenBracket)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == CharacterCloseBracket)
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
}


// TODO - replace with better option
charat : string in, integer index -> string c = substring(in, index, 1) [nogc]


PushToken : string token [nogc]
{
	quick_append(TokenStreamTail.tail, token)
}


quick_append : simplelist<string> ref tailnode, string token [nogc]
{
	simplelist<string> newlist = token, nothing
	tailnode.next = newlist
	TokenStreamTail.tail = newlist
}

quick_append : nothing, string token [nogc]
{
	assertmsg(false, "quick_append failure")
}


DumpStream : simplelist<string> ref tokens
{
	print(tokens.value)
	DumpStream(tokens.next)
}

DumpStream : nothing


PopToken : [nogc]
{
	PopTokenFromStream(TokenStream, TokenStream.next)
}

PopTokens : integer count [nogc]
{
	while(count > 0)
	{
		--count
		PopToken()
	}
}

PopTokenFromStream : simplelist<string> ref tokens, simplelist<string> ref tail [nogc]
{
	tokens = tail
}

PopTokenFromStream : simplelist<string> ref tokens, nothing [nogc]
{
	tokens.value = ""
}


PeekToken : integer displacement -> string token = PeekTokenInStream(TokenStream, displacement) [nogc]

PeekTokenInStream : simplelist<string> ref tokens, integer displacement -> string token = tokens.value [nogc]
{
	if(displacement > 0)
	{
		token = PeekTokenInStream(tokens.next, displacement - 1)
	}
}

PeekTokenInStream : nothing, integer displacement -> "" [nogc]



PeekWithExpectation : integer displacement, string expected -> boolean found = false [nogc]
{
	string token = PeekToken(displacement)
	if(token == expected)
	{
		found = true
	}
}


ParseGlobalBlock : -> boolean matched = false
{
	if(PeekToken(0) != "global")
	{
		return()
	}
	
	if(PeekToken(1) != "{")
	{
		return()
	}
	
	PopTokens(2)
	
	integer blockname = PoolString("@@globalblock")
	OnCodeGenRegisterScope(blockname, 0)
	OnCodeGenRegisterGlobalBlock(blockname)
	CacheGlobalCodeBlock(Scopes)
	
	while(PeekToken(0) != "}")
	{
		if(!ParseInitialization(false))
		{
			print("Failure to parse global entry")
			return()
		}
	}
	
	PopToken()
	OnCodeGenExitContext()
	matched = true
}


ParseWeakAlias : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "alias"))
	{
		return()
	}

	if(!PeekWithExpectation(2, "="))
	{
		return()
	}
	
	PopToken()
	string aliasname = PeekToken(0)
	string basename = PeekToken(2)
	PopTokens(3)
	
	OnCodeGenRegisterWeakAlias((++GlobalWeakAliasCounter), PoolString(aliasname), PoolString(basename))
	
	matched = true
}


ParseStrongAlias : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "type"))
	{
		return()
	}

	if(!PeekWithExpectation(2, ":"))
	{
		return()
	}
	
	PopToken()
	string aliasname = PeekToken(0)
	string basename = PeekToken(2)
	PopTokens(3)
	
	OnCodeGenRegisterAlias((++GlobalAliasCounter), PoolString(aliasname), PoolString(basename))
	
	matched = true
}


ParseSumType : -> boolean matched = false
{
	boolean templated = false

	if(!PeekWithExpectation(0, "type"))
	{
		return()
	}
	
	string sumtypename = PeekToken(1)

	if(PeekToken(2) == "<")
	{
		PopTokens(3)
		if(!ParseTemplateParameters())
		{
			return()
		}

		templated = true
		
		if(!PeekWithExpectation(1, ":"))
		{
			return()
		}
	}
	elseif(!PeekWithExpectation(2, ":"))
	{
		return()
	}
	else
	{
		PopToken()
	}
	
	integer typename = PoolString(sumtypename)
	integer typeid = (++GlobalSumTypeCounter)
	PopTokens(2)
	
	ParseSumTypeBases(typename, typeid)
	
	string finalbasename = PeekToken(0)	
	FindSumTypeAndAddBase(SumTypes, typename, typeid, PoolString(finalbasename), false)		// TODO - allow template args on trailing type
	PopToken()
	
	if(templated)
	{
		SetUpSumTypeTemplate(SumTypes, typeid)
	}
	
	matched = true
}


ParseSumTypeBases : integer typename, integer typeid
{
	boolean hasmorebases = true

	while(hasmorebases)
	{
		string basename = PeekToken(0)

		if(PeekToken(1) == "<")
		{
			integer baselookahead = ParseTemplateArgs(2)
			PopTokens(baselookahead + 2)

			FindSumTypeAndAddBase(SumTypes, typename, typeid, PoolString(basename), true)
		}
		else
		{
			FindSumTypeAndAddBase(SumTypes, typename, typeid, PoolString(basename), false)
			PopTokens(2)
		}

		hasmorebases = (PeekToken(1) == "|")
	}
}


ParseStructure : -> boolean matched = false
{
	boolean templated = false

	if(!PeekWithExpectation(0, "structure"))
	{
		return()
	}
		
	string structurename = PeekToken(1)

	if(PeekToken(2) == "<")
	{
		PopTokens(3)
		if(!ParseTemplateParameters())
		{
			return()
		}
		
		templated = true
				
		if(!PeekWithExpectation(1, ":"))
		{
			return()
		}
	}
	elseif(!PeekWithExpectation(2, ":"))
	{
		return()
	}

	PopTokens(2)
	if(!templated)
	{
		PopToken()
	}
	
	integer structuretype = (++GlobalStructureCounter)
	integer structurenamehandle = PoolString(structurename)

	boolean moremembers = true
	while(moremembers)
	{
		if(PeekToken(0) == "(")
		{
			PopToken()
			
			string memberfuncname = PeekToken(0)
			PopToken()
			
			if(!PeekWithExpectation(0, ":"))
			{
				return()
			}
			
			PopToken()
			
			integer memberfuncnamehandle = PoolString(memberfuncname)
			
			simplelist<integer> paramtypenames = 0, nothing
						
			boolean moreparams = true
			while(moreparams)
			{
				string paramtypename = PeekToken(0)
				PopToken()
				
				simpleprepend<integer>(paramtypenames, PoolString(paramtypename))
				
				if(PeekToken(0) != ",")
				{
					moreparams = false
				}
				else
				{
					PopToken()
				}
			}
			
			integer returntypehandle = 0
			
			if(PeekToken(0) == "->")
			{
				PopToken()
				returntypehandle = PoolString(PeekToken(0))
				PopToken()
			}
			
			OnCodeGenRegisterStructureMemFuncSig(structurenamehandle, structuretype, memberfuncnamehandle, returntypehandle)
			OnCodeGenRegisterStructureMemFuncSigParamList(structurenamehandle, structuretype, memberfuncnamehandle, paramtypenames)
			
			if(!PeekWithExpectation(0, ")"))
			{
				return()
			}
			
			PopToken()
		}
		else
		{
			boolean membertemplated = false
			boolean isref = false
			string membertypename = PeekToken(0)
			PopToken()
			string membername = PeekToken(0)
			PopToken()
			
			if(membername == "<")
			{
				integer memberlookahead = ParseTemplateArgs(0)
				if(memberlookahead > 0)
				{
					membertemplated = true
					PopTokens(memberlookahead + 1)
					membername = PeekToken(0)
					PopToken()
				}
				else
				{
					print("Error in template arguments for structure member")
					return()
				}
			}
			
			if(membername == "ref")
			{
				isref = true
				membername = PeekToken(0)
				PopToken()
			}
			
			OnCodeGenRegisterStructureMemVar(structurenamehandle, structuretype, PoolString(membername), PoolString(membertypename), isref, membertemplated)
		}
		
		if(PeekToken(0) != ",")
		{
			moremembers = false
		}
		else
		{
			PopToken()
		}
	}
	
	if(templated)
	{
		SetStructureToTemplate(structurenamehandle)
	}
	
	matched = true
}


ParseFunction : -> boolean matched = false
{
	string functionname = PeekToken(0)
	boolean templated = false
	
	if(PeekToken(1) == "<")
	{
		PopTokens(2)
		if(!ParseTemplateParameters())
		{
			return()
		}
		
		templated = true
	}

	if(!PeekWithExpectation(1, ":"))
	{
		return()
	}

	PopTokens(2)
	
	integer rawnamehandle = PoolString(functionname)
	integer namehandle = RegisterOverloadForFunction(functionname, rawnamehandle)
	
	OnCodeGenRegisterFunction(namehandle, rawnamehandle, functionname, templated)
	if(PeekToken(0) != "[")
	{
		ParseFunctionParams(rawnamehandle, namehandle)
		ParseFunctionReturn(namehandle)
	}
	ParseFunctionTags(namehandle, rawnamehandle)

	if(!PeekWithExpectation(0, "{"))
	{
		matched = true
		IREnterFunction(namehandle)
		Functions.value.AttachedScope.Wrapped = Scopes.value
		OnCodeGenEnterFunctionBody(namehandle)
		IRExitFunction()
		return()
	}

	PopTokens(1)
	IREnterFunction(namehandle)
	Functions.value.AttachedScope.Wrapped = Scopes.value
	OnCodeGenEnterFunctionBody(namehandle)

	ParseCodeBlock()
	
	IRExitFunction()
	matched = true
}


ParseTemplateParameters : -> boolean matched = false
{
	boolean hasparams = true
	
	while(hasparams)
	{
		string paramtype = PeekToken(0)
		string paramname = PeekToken(1)
		
		IRRegisterTemplateParameter(PoolString(paramtype), PoolString(paramname))
		
		PopTokens(2)
		
		if(PeekToken(0) == ">")
		{
			hasparams = false
		}
		elseif(PeekToken(0) == ",")
		{
			PopToken()
		}
		else
		{
			print("Syntax error in template parameters")
			return()
		}
	}
	
	matched = true
}


ParseFunctionParams : integer rawname, integer mangledname
{
	string typetoken = PeekToken(0)
	if(typetoken == "")
	{
		return()
	}
	
	while((typetoken != "{") && (typetoken != "->"))
	{
		if(typetoken == "nothing")
		{
			integer pooledhandle = PooledStringHandleForNothing
			integer nothinghandle = PoolString("nothing@@" ; cast(string, GlobalNothingCounter))
			++GlobalNothingCounter
			
			PopToken()
			IRRegisterFunctionParam(nothinghandle, pooledhandle, false, false)
		}
		elseif(typetoken == "(")
		{
			PopToken()
			string higherordername = PeekToken(0)
			
			if(PeekWithExpectation(1, ":"))
			{
				PopTokens(2)
				
				simplelist<integer> paramtypenames = 0, nothing
				
				boolean moreparams = true
				if(PeekToken(0) == ")")
				{
					moreparams = false
				}
				
				while(moreparams)
				{
					string paramtypename = PeekToken(0)
					PopToken()
					
					simpleprepend<integer>(paramtypenames, PoolString(paramtypename))
					
					if(PeekToken(0) != ",")
					{
						moreparams = false
					}
					else
					{
						PopToken()
					}
				}
				
				integer returntypename = 0
				
				if(PeekToken(0) == "->")
				{
					PopToken()
					returntypename = PoolString(PeekToken(0))
					PopToken()
				}
				
				integer sigtype = FindOrCreateFunctionSignatureType(paramtypenames, returntypename)				
				
				if(!PeekWithExpectation(0, ")"))
				{	
					print("Error in higher order function parameter syntax")
					return()
				}
				
				UnresolvedParameter p = PoolString(higherordername), 0, sigtype, false, nothing, nothing
				AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)

				PopToken()
			}
		}
		elseif(HandleLiteralFunctionParam(typetoken))
		{
			PopToken()
			EnsurePatternMatcherExists(PendingPatternMatchers, rawname, mangledname)
			EnsurePatternMatcherExists(PendingPatternMatchers, rawname, rawname)			// kind of a dumb hack
		}
		else
		{
			integer lookahead = 0
			boolean templated = false
			
			if(PeekToken(1) == "<")
			{
				lookahead = ParseTemplateArgs(2)
				if(lookahead > 0)
				{
					templated = true
				}
			}
			
			string nametoken = PeekToken(1 + lookahead)
			PopTokens(2 + lookahead)
			
			boolean isreference = false
			if(nametoken == "ref")
			{
				isreference = true
				nametoken = PeekToken(0)
				PopToken()
			}
			
			// TODO - error checking
			
			IRRegisterFunctionParam(PoolString(nametoken), PoolString(typetoken), isreference, templated)
		}
		
		typetoken = PeekToken(0)
		if(typetoken != ",")
		{
			return()
		}
		PopToken()
		typetoken = PeekToken(0)
	}
}


ParseFunctionReturn : integer namehandle
{
	if(!PeekWithExpectation(0, "->"))
	{
		return()
	}
	
	PopToken()
		
	OnCodeGenEnterFunctionReturn(namehandle, true)
	if(!ParseInitialization(true))
	{
		ParseExpression()
	}
	OnCodeGenExitContext()
}


ParseFunctionTags : integer functionname, integer rawfuncname
{
	if(!PeekWithExpectation(0, "["))
	{
		return()
	}
	
	PopToken()
	
	while(PeekToken(0) != "]")
	{
		ParseSingleFunctionTag(functionname, rawfuncname)
	}
	
	PopToken()
}

ParseSingleFunctionTag : integer functionname, integer rawfuncname
{
	string tagname = PeekToken(0)
	
	if(PeekToken(1) == "(")
	{
		PopTokens(2)
		OnCodeGenRegisterFunctionTag(functionname, tagname, rawfuncname)
		
		string token = PeekToken(0)
		while(token != ")")
		{
			if(token == "")
			{
				print("Incomplete function tag")
				return()
			}
			
			string parameter = PeekToken(0)
			if(subchar(parameter, 0) == CharacterQuote)
			{
				parameter = substring(parameter, 1, length(parameter) - 2)
			}
			
			PopToken()
			
			OnCodeGenRegisterFunctionTagParam(functionname, tagname, parameter)

			token = PeekToken(0)
			if(token == ",")
			{
				PopToken()
				token = PeekToken(0)
			}			
		}
		
		PopToken()
	}
	else
	{
		PopToken()
		OnCodeGenRegisterFunctionTag(functionname, tagname, rawfuncname)
	}
	
	if(tagname == "external")
	{
		FindFunctionAndSetInvokeTag(Functions, functionname, PoolString("@@external"))
	}

	if(PeekToken(0) == ",")
	{
		PopToken()
	}
}


ParseStatement : boolean substatement -> boolean matched = false
{
	string statementname = PeekToken(0)
	boolean templated = false
	integer lookahead = 0
	
	if(PeekToken(1) == "<")
	{
		lookahead = ParseTemplateArgs(2)
		if(lookahead > 0)
		{
			templated = true
		}
	}
	
	if(!PeekWithExpectation(1 + lookahead, "("))
	{
		return()
	}

	if(substatement)
	{
		OnCodeGenEnterSubStatement()
	}
	
	IREnterStatement(statementname, !substatement, templated)
	
	PopTokens(2 + lookahead)

	string token = PeekToken(0)
	while(token != ")")
	{
		if(token == "")
		{
			print("Error: missing a )")
			return()
		}

		if(!ParseExpression())
		{
			print("Error: mangled expression")
			return()
		}
		
		token = PeekToken(0)
		if(token == ",")
		{
			PopToken()
			token = PeekToken(0)
			OnCodeGenShiftParameter()
		}
	}
	
	PopToken()
	IRExitStatement()
	
	if(substatement)
	{
		IRExitStatement()
	}
	
	matched = true
}

ScanTemplateArgs : integer initialconsume -> integer consumed = initialconsume
{
	boolean hasargs = true
	while(hasargs)
	{
		++consumed
		
		if(PeekToken(consumed) == ">")
		{
			hasargs = false
		}
		elseif(PeekToken(consumed) == ",")
		{
			++consumed
		}
		else
		{
			consumed = 0
			return()
		}
	}
}

ParseTemplateArgs : integer intialconsume -> integer consumed = intialconsume
{
	TemplateArgumentList newarglist = scratchtemplatearglist
	prepend<TemplateArgumentList>(ScratchTemplateArgumentStack, newarglist)

	boolean hasargs = true
	while(hasargs)
	{
		string argvalue = PeekToken(consumed)
		++consumed
		
		integer replacehandle = PoolString(argvalue)
		TemplateArgument newarg = replacehandle, argvalue
		AppendTemplateArgument(ScratchTemplateArgumentStack.value.Args, newarg)
		
		if(PeekToken(consumed) == ">")
		{
			hasargs = false
		}
		elseif(PeekToken(consumed) == ",")
		{
			++consumed
		}
		else
		{
			PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
			consumed = 0
			return()
		}
	}
}

ParseInitialization : boolean inreturn -> boolean matched = false
{
	boolean templated = false
	string typename = PeekToken(0)
	string varname = PeekToken(1)
	
	integer skipahead = 0
	if(varname == ".")
	{
		return()
	}
	elseif(varname == "<")
	{
		skipahead = ScanTemplateArgs(2)
		varname = PeekToken(1 + skipahead)
		
		templated = true
	}

	if(PeekToken(2 + skipahead) != "=")
	{
		return()
	}
	
	if(templated)
	{
		ParseTemplateArgs(2)
	}

	PopTokens(3 + skipahead)
	
	if(inreturn)
	{
		OnCodeGenEnterSubStatement()
	}

	IREnterStatement(typename, true, templated)
	IRAddLiteralIdentifier(varname)
	
	OnCodeGenShiftParameter()
	
	ParseExpression()
	while(PeekToken(0) == ",")
	{
		PopToken()
		OnCodeGenShiftParameter()
		ParseExpression()
	}
	
	IRExitStatement()

	matched = true
	
	if(inreturn)
	{
		IRExitStatement()
		Functions.value.AnonymousReturn = false
	}
}


ParseExpression : -> boolean matched = false
{
	boolean matchedstatement = false
	
	if(!ParseExpressionTerm(true, matchedstatement))
	{
		return()
	}
	
	if(matchedstatement && (PeekToken(0) == ")"))
	{
	}
	else
	{
		while(ParseExpressionOperator())
		{
			if(!ParseExpressionTerm(false, matchedstatement))
			{
				return()
			}
		}
	}

	matched = true
}

ParseExpressionTerm : boolean startsexpr, boolean ref matchedstatement -> boolean matched = false
{
	string term = PeekToken(0)
		
	if(term == ")")
	{
		return()
	}
	elseif(term == ",")
	{
		return()
	}
	elseif(term == "")
	{
		return()
	}
	elseif(term == "(")
	{
		OnCodeGenRegisterParenthetical()
		
		PopToken()
		if(ParseExpression())
		{
			PopToken()
			matched = true
		}
		else
		{
			print("Error in parenthetical expression")
		}
		
		OnCodeGenExitContext()
		
		
		return()
	}

	// Unary operator detection
	if(term == "!")
	{
		PopToken()
		IRAddOperator(term)
		matched = ParseExpressionTerm(startsexpr, matchedstatement)
		return()
	}

	if(term == "false")
	{
		IRAddLiteralBoolean(false)
	}
	elseif(term == "true")
	{
		IRAddLiteralBoolean(true)
	}
	elseif(term == "0")
	{
		IRAddLiteralInteger(0)
	}
	elseif(term == "0.0")
	{
		IRAddLiteralReal(0.0)
	}
	elseif(ParsePreopStatement(true))
	{
		matched = true
		return()
	}
	elseif(ParseStatement(true))
	{
		matched = true
		matchedstatement = true
		return()
	}
	else
	{
		if(subchar(term, 0) == CharacterQuote)
		{
			string stringliteral = substring(term, 1, length(term) - 2)
			IRAddLiteralString(stringliteral)			
		}
		else
		{
			if(stringcontains(term, "."))
			{
				real realvalue = cast(real, term)
				IRAddLiteralReal(realvalue)
			}
			else
			{
				integer literalvalue = cast(integer, term)
				if(substring(term, 0, 2) == "0x")
				{
					IRAddLiteralInteger(literalvalue)
				}
				else
				{
					if(literalvalue != 0)
					{
						IRAddLiteralInteger(literalvalue)
					}
					else
					{
						IRAddLiteralIdentifier(term)
					}
				}
			}
		}
	}

	PopToken()
	matched = true
}

ParseExpressionOperator : -> boolean matched = false
{
	string op = PeekToken(0)	
	if(op == ")")
	{
		return()
	}
	elseif(op == ",")
	{
		return()
	}
	elseif(op == "")
	{
		return()
	}
	elseif(length(op) > 2)
	{
		return()
	}
	

	boolean knownoperator = false
	if(op == ".")
	{
		knownoperator = true
	}
	elseif(op == "+")
	{
		knownoperator = true
	}
	elseif(op == "-")
	{
		knownoperator = true
	}
	elseif(op == "*")
	{
		knownoperator = true
	}
	elseif(op == "/")
	{
		knownoperator = true
	}
	elseif(op == "==")
	{
		knownoperator = true
	}
	elseif(op == "!=")
	{
		knownoperator = true
	}
	elseif(op == ";")
	{
		knownoperator = true
	}
	elseif(op == ">")
	{
		knownoperator = true
	}
	elseif(op == "<")
	{
		knownoperator = true
	}
	elseif(op == "&")
	{
		knownoperator = true
	}
	elseif(op == "&&")
	{
		knownoperator = true
	}
	
	if(knownoperator)
	{
		IRAddOperator(op)
		PopToken()
		matched = true
	}
}

ParseAssignment : -> boolean matched = false
{
	integer lhslength = 1
	while(PeekToken(lhslength) == ".")
	{
		lhslength += 2
	}
	
	string assignmenttoken = PeekToken(lhslength)
	boolean recognized = false
	if(assignmenttoken == "=")
	{
		recognized = true
	}
	elseif(assignmenttoken == "+=")
	{
		recognized = true
	}
	elseif(assignmenttoken == "-=")
	{
		recognized = true
	}
	
	if(!recognized)
	{
		return()
	}
	
	if(lhslength == 1)
	{
		OnCodeGenEnterAssignment(PoolString(assignmenttoken), PoolString(PeekToken(0)), 0, 0)
	}
	else
	{
		OnCodeGenEnterAssignmentCompound(PoolString(assignmenttoken), PoolString(PeekToken(0)), 0, 0)
		integer tokenindex = 2
		while(tokenindex < lhslength)
		{
			FindCurrentFunctionAndAppendCompoundMember(PoolString(PeekToken(tokenindex)))
			tokenindex += 2
		}
		OnCodeGenAssignmentCompoundEnd()
	}
	
	PopTokens(lhslength + 1)
	
	boolean haschain = true
	while(haschain)
	{
		lhslength = 1
		while(PeekToken(lhslength) == ".")
		{
			lhslength += 2
		}
			
		if(PeekToken(lhslength) == "=")
		{
			if(assignmenttoken != "=")
			{
				print("Cannot chain assignments with side effects")
				return()
			}
			
			if(lhslength == 1)
			{
				OnCodeGenChainAssignment(PoolString("="), PoolString(PeekToken(0)), 0, 0)
			}
			else
			{
				OnCodeGenChainAssignmentCompound(PoolString("="), PoolString(PeekToken(0)), 0, 0)
				integer tokenindex = 2
				while(tokenindex < lhslength)
				{
					FindCurrentFunctionAndChainCompoundMember(PoolString(PeekToken(tokenindex)))
					tokenindex += 2
				}
			}			
			
			PopTokens(lhslength + 1)
		}
		else
		{
			haschain = false
		}
	}
	
	if(ParseExpression())
	{
		matched = true
		OnCodeGenExitContext()
	}
	else
	{
		print("Right hand side of assignment is not a valid expression")
	}
}


ParseEntity : -> boolean matched = false
{
	string entityname = PeekToken(0)
	
	if(entityname == "if")
	{
		if(PeekToken(1) == "(")
		{
			PopTokens(2)
			
			OnCodeGenEnterChain()
			OnCodeGenEnterEntity(0x11, 0)
			
			ParseExpression()
			PopToken()
			
			matched = ParseEntityCode()
			
			while(PeekToken(0) == "elseif")
			{
				PopTokens(2)
				OnCodeGenEnterEntity(0x12, 0)
				ParseExpression()
				PopToken()
				matched = ParseEntityCode()
			}
			
			if(PeekToken(0) == "else")
			{
				PopToken()
				OnCodeGenEnterEntity(0x13, 0)
				matched = ParseEntityCode()
			}
			
			OnCodeGenExitContext()
		}
	}
	elseif(entityname == "while")
	{
		if(PeekToken(1) == "(")
		{
			PopTokens(2)
			
			OnCodeGenEnterChain()
			OnCodeGenEnterEntity(0x14, 0)
			
			ParseExpression()
			PopToken()

			matched = ParseEntityCode()
			
			OnCodeGenExitContext()
		}
	}
}

ParseCodeBlock :
{
	string token = PeekToken(0)
	while(token != "}")
	{
		if(token == "")
		{
			print("Error: missing a }")
			return()
		}

		if(ParseEntity())
		{
		}
		elseif(ParsePreopStatement(false))
		{
		}
		elseif(ParsePostopStatement())
		{
		}
		elseif(ParseStatement(false))
		{
		}
		elseif(ParseInitialization(false))
		{
		}
		elseif(ParseAssignment())
		{
		}
		else
		{
			print("Parse failure: " ; PeekToken(0) ; " " ; PeekToken(1) ; " " ; PeekToken(2))
			return()
		}
		
		token = PeekToken(0)
	}

	PopToken()
}


ParseEntityCode : -> boolean matched = false
{
	if(PeekToken(0) == "{")
	{
		OnCodeGenEnterEntityCode()
		PopToken()
		ParseCodeBlock()
		OnCodeGenExitContext()
		OnCodeGenExitContext()
		matched = true
	}
	else
	{
		print("Expected code block")
	}
}


ParsePreopStatement : boolean substatement -> boolean matched = false
{
	boolean recognized = false
	string potential = PeekToken(0)
	
	if(potential == "++")
	{
		recognized = true
	}
	elseif(potential == "--")
	{
		recognized = true
	}
	
	if(recognized)
	{
		PopToken()
		
		string operand = PeekToken(0)
		PopToken()
		
		OnCodeGenPreparePreOpStatement(PoolString(potential), PoolString(operand))
		
		while(PeekToken(0) == ".")
		{
			PopToken()
			operand = PeekToken(0)
			PopToken()
			
			OnCodeGenPreparePreOpCompoundOperand(PoolString(operand))
		}
		
		OnCodeGenCompletePreOpStatement(substatement)
		
		matched = true
	}
}

ParsePostopStatement : -> boolean matched = false
{
	boolean recognized = false
	
	string operand = PeekToken(0)
	integer operandlength = 1
	while(PeekToken(operandlength) == ".")
	{
		operandlength += 2
	}
	
	string potential = PeekToken(operandlength)
	if(potential == "++")
	{
		recognized = true
	}
	elseif(potential == "--")
	{
		recognized = true
	}
	
	if(recognized)
	{
		OnCodeGenRegisterPostOpStatement(PoolString(potential), PoolString(operand))

		if(operandlength > 1)
		{
			integer tokenindex = 2
			while(tokenindex < operandlength)
			{
				operand = PeekToken(tokenindex)
				OnCodeGenAddPreOpCompoundOperand(PoolString(operand))
				tokenindex += 2
			}
		}

		PopTokens(operandlength + 1)
				
		matched = true
	}
}


HandleLiteralFunctionParam : string token -> boolean isliteral = false
{
	if(token == "0")
	{
		RegisterLiteralFunctionParam(0)
		isliteral = true
	}
	elseif(token == "0.0")
	{
		RegisterLiteralFunctionParam(0.0)
		isliteral = true
	}
	elseif(stringcontains(token, "."))
	{
		real realval = cast(real, token)
		RegisterLiteralFunctionParam(realval)
		isliteral = true
	}
	else
	{
		integer intval = cast(integer, token)
		if(intval != 0)
		{
			RegisterLiteralFunctionParam(intval)
			isliteral = true
			return()
		}
				
		// TODO - support pattern match literals of other types
	}
}


RegisterLiteralFunctionParam : integer literalvalue
{
	ExpressionAtom atom = literalvalue
	list<ExpressionAtom> atoms = atom, nothing
	Expression expr = atoms, 0x01000001		// integer type signature

	UnresolvedParameter p = 0, GetNameOfType(expr.Type), expr.Type, false, expr, nothing
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

RegisterLiteralFunctionParam : real literalvalue
{
	ExpressionAtom atom = literalvalue
	list<ExpressionAtom> atoms = atom, nothing
	Expression expr = atoms, 0x01000004		// real type signature
	
	UnresolvedParameter p = 0, GetNameOfType(expr.Type), expr.Type, false, expr, nothing
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}


//
// List traversal/inspection functions
//

map<type T> : list<T> ref thelist, (func : T)
{
	// TODO - figure out why this expression doesn't coalesce correctly
	//func(thelist.value)
	map<T>(thelist.next, func)
}

map<type T> : nothing, (func : T)
{
}


listcontains : simplelist<integer> ref thelist, integer value -> boolean ret = false [nogc]
{
	if(thelist.value == value)
	{
		ret = true
	}
	else
	{
		ret = listcontains(thelist.next, value)
	}
}

listcontains : nothing, integer value -> boolean contains = false [nogc]



TypeListContains : simplelist<integer> ref thelist, integer value -> integer ret = 0 [nogc]
{
	integer listval = thelist.value
	if((listval & 0x7f000000) == 0x05000000)
	{
		listval = FindTypeAliasBase(TypeAliases, listval)
	}
	
	if(listval == value)
	{
		ret = listval
		return()
	}
	elseif(MakeNonReferenceType(listval) == value)
	{
		ret = listval
		return()
	}
	elseif(listval == MakeNonReferenceType(value))
	{
		ret = listval
		return()
	}
	
	if((value & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(value) == MakeNonReferenceType(listval))
		{
			ret = value
			return()
		}
		
		if(SumTypeHasBase(SumTypes, MakeNonReferenceType(value), MakeNonReferenceType(listval)))
		{
			ret = value
			return()
		}
	}
	
	if((listval & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(value) == MakeNonReferenceType(listval))
		{
			ret = value
			return()
		}		
		
		if(SumTypeHasBase(SumTypes, listval, MakeNonReferenceType(value)))
		{
			ret = value
			return()
		}
	}
	
	ret = TypeListContains(thelist.next, value)
}

TypeListContains : nothing, integer value -> 0



//
// Callback used to emit a byte to a bytecode stream
//

OnBytecodeEmitByte : integer b [nogc]
{
	writebuffer(Hack, HackSize, b)
	++HackSize
}


OnBytecodeEmitInteger : integer value [nogc]
{
	writebuffer(Hack, HackSize, value & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x100) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x10000) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x1000000) & 0xff)
	++HackSize
}

OnBytecodeEmitInteger16 : integer16 value [nogc]
{
	integer v = cast(integer, value)
	writebuffer(Hack, HackSize, v & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (v / 0x100) & 0xff)
	++HackSize
}

OnBytecodeEmitReal : real value [nogc]
{
	writebuffer(Hack, HackSize, value)
	HackSize = HackSize + 4
}

OnBytecodeEmitString : string value [nogc]
{
	integer len = (length(value) + 1) * 2
	writebuffer(Hack, HackSize, value, len)
	HackSize += len
}

OnBytecodeEmitBoolean : boolean value [nogc]
{
	OnBytecodeEmitByte(cast(integer, value))
}


OnBytecodePoolString : integer handle, string data [nogc]
{
	OnBytecodeEmitByte(0x10)			// PoolString instruction
	OnBytecodeEmitInteger(handle)
	OnBytecodeEmitString(data)
}

OnBytecodeLexicalScope : integer name, integer parent, integer count [nogc]
{
	OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(parent)
	OnBytecodeEmitInteger(count)
}

OnBytecodeLexicalScopeEntry : integer varname, integer vartype, integer origin [nogc]
{
	OnBytecodeEmitInteger(varname)
	OnBytecodeEmitInteger(vartype)
	OnBytecodeEmitInteger(origin)
	OnBytecodeEmitBoolean(false)
}

OnBytecodeInvokeOffset : integer name [nogc]
{
	OnBytecodeEmitByte(0x27)			// InvokeOffset instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(0)
}

OnBytecodeHalt : [nogc]
{
	OnBytecodeEmitByte(0x00)			// Halt instruction
}

OnBytecodeEnterFunction : integer name [nogc]
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x01)			// EntityTags::Function
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitFunction : [nogc]
{
	OnBytecodeEmitByte(0x09)			// Return instruction
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeInvoke : integer target [nogc]
{
	OnBytecodeEmitByte(0x07)			// Invoke instruction
	OnBytecodeEmitInteger(target)
}

OnBytecodeEnterEntity : integer tag, integer name [nogc]
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(tag)
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitEntity : [nogc]
{
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeBeginChain : [nogc]
{
	OnBytecodeEmitByte(0x0d)			// BeginChain instruction
}

OnBytecodeEndChain : [nogc]
{
	OnBytecodeEmitByte(0x0e)			// EndChain instruction
}

OnBytecodeDefineStructure : integer typeid, integer nummembers [nogc]
{
	OnBytecodeEmitByte(0x14)			// DefineStructure instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(nummembers)
}

OnBytecodeStructureMember : integer name, integer typeid [nogc]
{
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeReadReference : [nogc]
{
	OnBytecodeEmitByte(0x17)			// ReadRef instruction
}

OnBytecodeReadReferenceAnnotated : [nogc]
{
	OnBytecodeEmitByte(0x24)			// ReadRefAnnotated instruction
}

OnBytecodeAllocStructure : integer typeid [nogc]
{
	OnBytecodeEmitByte(0x13)			// AllocStructure instruction
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeBindReference : integer frameskip, integer index [nogc]
{
	if(index < 0)
	{
		print("Binding reference to a missing variable!")
		assert(false)
	}

	OnBytecodeEmitByte(0x03)			// BindRef instruction
	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(index)
}

OnBytecodeAssign : [nogc]
{
	OnBytecodeEmitByte(0x06)			// Assign instruction
}

OnBytecodePushVarValueNoCopy : integer name [nogc]
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(name)
}

OnBytecodePushVarValue : integer name, integer typeid [nogc]
{
	OnBytecodePushVarValueNoCopy(name)
	
	integer family = typeid & 0xff000000

	if(typeid == 0x02000001)			// Buffer type signature
	{
		OnBytecodeCopyBuffer()
	}
	elseif(family == 0x03000000)			// Structure family signature
	{
		//OnBytecodeCopyStructure()		// TODO - un-break value semantics!
	}
	elseif(family == 0x08000000)			// Template instance family signature
	{
		//OnBytecodeCopyStructure()
	}
}

OnBytecodeCopyBuffer : [nogc]
{
	OnBytecodeEmitByte(0x19)			// CopyBuffer instruction
}

OnBytecodeCopyStructure : [nogc]
{
	OnBytecodeEmitByte(0x1b)			// CopyStructure instruction
}

OnBytecodeCopyToStructure : integer structurename, integer membername [nogc]
{
	OnBytecodeEmitByte(0x16)			// CopyToStructure instruction
	OnBytecodeEmitInteger(structurename)
	OnBytecodeEmitInteger(membername)
}

OnBytecodeSetReturnRegister : integer varindex [nogc]
{
	OnBytecodeEmitByte(0x0a)			// SetRetVal instruction
	OnBytecodeEmitInteger(varindex)
}

OnBytecodePushVarNoCopy : integer varname [nogc]
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeInvokeIndirect : integer varname [nogc]
{
	OnBytecodeEmitByte(0x08)			// InvokeIndirect instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeEnterPatternResolver : integer name [nogc]
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x02)			// EntityTags::PatternMatchingResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitPatternResolver : [nogc]
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeConstructSumType : [nogc]
{
	OnBytecodeEmitByte(0x21)			// ConstructSumType instruction
}

OnBytecodeEnterTypeResolver : integer name [nogc]
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x05)			// EntityTags::TypeResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitTypeResolver : [nogc]
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodePopStack : integer bytes [nogc]
{
	OnBytecodeEmitByte(0x04)			// Pop instruction
	OnBytecodeEmitInteger(bytes)
}

OnBytecodeBindRefByHandle : integer id [nogc]
{
	OnBytecodeEmitByte(0x1d)
	OnBytecodeEmitInteger(id)
}

OnBytecodeBindStructReference : integer membertype, integer memberoffset [nogc]
{
	OnBytecodeEmitByte(0x18)			// BindMemberRef instruction
	OnBytecodeEmitInteger(MakeNonReferenceType(membertype))
	OnBytecodeEmitInteger(memberoffset)
}

OnBytecodePushType : integer typeid [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeAssignSumType : [nogc]
{
	OnBytecodeEmitByte(0x23)			// AssignSumType instruction
}

OnBytecodePushLocal : boolean isparam, integer frameskip, integer offset, integer size [nogc]
{
	if(isparam)
	{
		OnBytecodeEmitByte(0x26)		// ReadParam instruction
	}
	else
	{
		OnBytecodeEmitByte(0x25)		// ReadStack instruction
	}

	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(offset)
	OnBytecodeEmitInteger(size)
}

OnBytecodePushBoolean : boolean literal [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000003)		// Boolean type signature
	OnBytecodeEmitBoolean(literal)
}

OnBytecodePushLiteralString : integer literalhandle [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x02000000)		// String type signature
	OnBytecodeEmitInteger(literalhandle)
}

OnBytecodePushLiteralInteger : integer literal [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(literal)
}

OnBytecodePushLiteralInteger16 : integer16 literal [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000002)		// Integer16 type signature
	OnBytecodeEmitInteger16(literal)
}

OnBytecodePushTypeAnnotation : integer annotation [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(annotation)
}

OnBytecodePushLiteralFunction : integer name [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x09000000)		// Function family signature (N.B. not the actual function type!)
	OnBytecodeEmitInteger(name)
}

OnBytecodePushLiteralReal : real value [nogc]
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000004)		// Real type signature
	OnBytecodeEmitReal(value)
}

OnBytecodeEmitFunctionSignature : integer typeid, integer rettype, integer paramcount [nogc]
{
	OnBytecodeEmitByte(0x28)			// FuncSig instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(rettype)
	OnBytecodeEmitInteger(paramcount)
}

OnBytecodeEmitFunctionSigParam : integer paramtype [nogc]
{
	OnBytecodeEmitInteger(paramtype)
	OnBytecodeEmitBoolean(false)
}


GetTypeSize : integer typeid -> integer size = 0 [nogc]
{
	if(typeid == 0x01000001)			// Integer
	{
		size = 4
	}
	elseif(typeid == 0x01000002)			// Integer16
	{
		size = 2
	}
	elseif(typeid == 0x01000003)			// Boolean
	{
		size = 1
	}
	elseif(typeid == 0x01000004)			// Real
	{
		size = 4
	}
	elseif(typeid == 0x02000000)			// StringHandle
	{
		size = 4
	}
	elseif(IsStructureType(typeid))			// StructureHandle
	{
		size = 4
	}
	elseif((typeid & 0xff000000) == 0x07000000)	// SumType
	{
		size = 4 + GetLargestSumTypeBaseSize(typeid)
	}
	elseif(typeid == 0x00000004)			// Nothing
	{
		size = 0
	}
	else
	{
		print("Undefined type for size retrieval - " ; cast(string, typeid))
		assert(false)
	}
}


//
// Data structures for holding the internal representation of a compiled program
//

structure StringTableEntry :
	integer Handle,
	string Data

structure TypeAlias :
	integer TypeID,
	integer AliasNameHandle,
	integer BaseNameHandle

structure StructureMemberVariable :
	integer Name,
	integer Type,
	integer TypeNameHandle,
	OptionalTemplateArgs TemplateArgs

structure StructureMemberFunctionRef :
	integer Name,
	FunctionSignature ref Signature


type StructureMember : StructureMemberVariable | StructureMemberFunctionRef

structure StructureDefinition :
	integer Name,
	integer Type,
	integer ConstructorName,
	integer AnonConstructorName,
	integer CopyConstructorName,
	list<StructureMember> ref Members,
	integer MemberCount,
	string ReadableName,
	boolean IsTemplate


structure IdentifierAtom :
	integer Handle,
	integer Type,
	boolean IsReference,
	boolean IsFunction

structure StringHandleAtom :
	integer Handle

structure OperatorInvokeAtom :
	integer OperatorName

structure TypeAnnotationAtom :
	integer Type

structure RefBinding :
	integer Identifier,
	integer StructureName,
	boolean IsReference,
	boolean InputIsReference
	
structure CompoundAtom :
	list<RefBinding> ref Bindings,
	integer Type

structure AtomSentinel :
	integer dummy


type ExpressionAtom : 	integer | integer16 | boolean | real | StringHandleAtom |
			IdentifierAtom | OperatorInvokeAtom | TypeAnnotationAtom | RefBinding |
			CompoundAtom |
			Statement |
			ParentheticalExpression |
			AtomSentinel


structure Expression :
	list<ExpressionAtom> ref Atoms,
	integer Type

type OptionalExpression : Expression | nothing

structure ExpressionList :
	list<Expression> ref Expressions

type OptionalExpressionList : ExpressionList | nothing


type OptionalTemplateArgs : TemplateArgumentList | nothing

type ExpressionOrAssignment : Expression | Assignment | AssignmentCompound

structure Statement :
	integer Name,
	OptionalExpressionList Parameters,
	integer Type,
	OptionalTemplateArgs TemplateArgs,
	boolean TopLevel,
	boolean InferenceDone

structure Assignment :
	integer Operator,
	integer LHSName,
	integer LHSType,
	integer Annotation,
	ExpressionOrAssignment RHS

structure AssignmentCompound :
	integer Operator,
	simplelist<integer> LHS,			// TODO - JIT bug - making this a reference type causes bogosity
	integer LHSType,
	integer Annotation,
	ExpressionOrAssignment RHS

structure PreOpStatement :
	integer Operator,
	simplelist<integer> ref Operand,
	integer Type

structure PostOpStatement :
	integer Operator,
	simplelist<integer> ref Operand,
	integer Type

type ExpressionOrPrePostOp : Expression | PreOpStatement | PostOpStatement


structure ParentheticalExpression :
	ExpressionOrPrePostOp Inner


type CodeBlockEntry : Statement | PreOpStatement | PostOpStatement |
		      Assignment | AssignmentCompound | EntityChain

structure CodeBlock :
	list<CodeBlockEntry> ref Entries

type OptionalCodeBlock : CodeBlock | nothing

structure Entity :
	integer Tag,
	integer PostfixTag,
	OptionalExpression Param,
	OptionalCodeBlock Code


structure EntityList :
	list<Entity> ref ActualList

type OptionalEntityList : EntityList | nothing


structure EntityChain :
	OptionalEntityList Entries

		
structure UnresolvedParameter :
	integer NameHandle,
	integer TypeNameHandle,
	integer ResolvedType,
	boolean HasRefTag,
	OptionalExpression PatternMatchValue,
	OptionalTemplateArgs TemplateArgs
		
structure FunctionParams :
	list<UnresolvedParameter> ref Params
	
type OptionalParameters : FunctionParams | nothing

structure Overload :
	integer NormalName,
	integer MangledName,
	ContextNode<FunctionDefinition> Implementation

structure FunctionDefinition :
	integer RawName,
	integer Name,
	OptionalExpression Return,
	OptionalCodeBlock Code,
	OptionalParameters Params,
	list<Overload> Overloads,
	ContextWrapper<Scope> AttachedScope,
	string RawNameString,
	integer InvokeTag,
	boolean InferenceDone,
	boolean IsTemplate,
	boolean AnonymousReturn
	
	

structure Variable :
	integer Name,
	integer VarType,
	integer Origin,
	integer Offset

structure Scope :
	integer Name,
	integer ParentName,
	list<Variable> ref Variables,
	integer ParamOffset,
	integer LocalOffset


structure Parameter :
	integer Name,
	integer Type
	

structure ContextStackEntry :
	integer EntryType,
	integer EntryName

structure SumTypeBase :
	integer Name,
	OptionalTemplateArgs TemplateArgs

structure SumType :
	integer Name,
	integer Type,
	list<SumTypeBase> ref Bases,
	boolean IsTemplate


structure FunctionSignature :
	integer Name,
	list<Parameter> ref Parameters,
	integer ReturnTypeName

structure PendingTypeMatcher :
	integer OverloadName,
	integer MatcherName,
	ContextNode<FunctionDefinition> OverloadImplementation
	
structure PendingPatternMatcher :
	integer RawName,
	integer OverloadName,
	integer MatcherName

structure TypeMatcher :
	integer Name,
	list<FunctionSignature> ref Overloads


structure FunctionTag :
	integer FunctionName,
	string TagName,
	list<string> ref Parameters


structure TemplateParameter :
	integer ParamName,
	integer ParamType

structure TemplateArgument :
	integer ReplaceWith,
	string ReplaceWithString

structure TemplateArgumentList :
	list<TemplateArgument> ref Args

structure TemplateFunction :
	integer FunctionDefName,
	list<TemplateParameter> ref Parameters

structure TemplateStructure :
	integer StructureDefName,
	list<TemplateParameter> ref Parameters

structure TemplateSumType :
	integer SumTypeName,
	list<TemplateParameter> ref Parameters

structure TemplateInstance :
	integer DefName,
	integer InstanceName,
	list<TemplateArgument> ref Arguments
	
	
structure ParameterTypeList :
	simplelist<integer> ref Types
	
	
type ContextNode<type T> : T | nothing

structure ContextWrapper<type T> :
	ContextNode<T> ref Wrapped


//
// Callback invoked when the code generation process can begin
//

OnCodeGenProcessProgram :
{
	GenerateTypeMatcherMappings(Functions)
	GeneratePendingTypeMatchers(PendingTypeMatchers)

	CodeGenEmitStrings(GlobalStrings)
	CodeGenEmitSumTypes(SumTypes)
	CodeGenRearrangeStructures(Structures)
	CodeGenEmitStructures(Structures)
	CodeGenEmitFunctionSignatures(FunctionSignatures)
	
	if(GlobalCodeBlockName != 0)
	{
		CodeGenEmitSpecificScope(GlobalScope.Wrapped)
	}
	
	CodeGenEmitScopes(Scopes)
	CodeGenEmitFunctionTags(FunctionTags)
	CodeGenEmitGlobalBlockPrologue(GlobalCodeBlock)
	CodeGenEmitFunctions(Functions)
	CodeGenEmitGlobalBlockEpilogue(GlobalCodeBlock)
	CodeGenEmitTypeMatchers(TypeMatchers)
	CodeGenEmitPatternMatchers(PendingPatternMatchers)
	CodeGenEmitConstructors(Structures)
}

OnCodeGenRegisterString : integer handle, string data [nogc]
{
	StringTableEntry entry = handle, data
	prepend<StringTableEntry>(GlobalStrings, entry)
	
	PlaceDataInTrie(GlobalStringTrie, data, handle)

	if(handle > CurrentStringHandle)
	{
		CurrentStringHandle = handle
	}
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer typenamehandle, boolean isref, boolean templated
{
	integer refnum = 0
	if(isref)
	{
		refnum = 0x80000000
	}

	StructureMemberVariable member = membername, refnum, typenamehandle, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		member.TemplateArgs = ScratchTemplateArgumentStack.value
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}
	
	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettypename
{
	list<Parameter> p = dummyparam, nothing
	FunctionSignature signature = name, p, rettypename
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype
{
	Parameter param = 1, paramtype
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, simplelist<integer> ref typenames
{
	OnCodeGenRegisterStructureMemFuncSigParamList(structurename, structuretype, membername, typenames.next)
	
	if(typenames.value != 0)
	{
		OnCodeGenRegisterStructureMemFuncSigParam(structurename, structuretype, membername, typenames.value)
	}
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, nothing



FindStructureAndAddMember : list<StructureDefinition> ref structures, integer structurename, integer structuretype, StructureMember ref member
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMember(structures.value.Members, structures.value.Members.next, member)
		structures.value.MemberCount = structures.value.MemberCount + 1
	}
	else
	{
		FindStructureAndAddMember(structures.next, structurename, structuretype, member)
	}
}

FindStructureAndAddMember : nothing, integer structurename, integer structuretype, StructureMember ref member
{
	list<StructureMember> members = member, nothing
	StructureDefinition def = structurename, structuretype, 0, 0, 0, members, 1, GetPooledString(GlobalStrings, structurename), false

	prepend<StructureDefinition>(Structures, def)
	InsertIntoBinaryTree<StructureDefinition>(StructuresWhichExist, structurename, def)
}

AppendStructureMember : list<StructureMember> ref members, list<StructureMember> ref tail, StructureMember ref member
{
	AppendStructureMember(tail, tail.next, member)
}

AppendStructureMember : list<StructureMember> ref members, nothing, StructureMember ref member
{
	list<StructureMember> newtail = member, nothing
	members.next = newtail
}


FindStructureAndAddMemberParam : list<StructureDefinition> ref structures, integer structurename, integer structuretype, integer membername, Parameter ref param
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMemberParam(structures.value.Members, membername, param)
	}
	else
	{
		FindStructureAndAddMemberParam(structures.next, structurename, structuretype, membername, param)
	}
}

AppendStructureMemberParam : list<StructureMember> ref members, integer membername, Parameter ref param
{
	boolean match = CheckMemberForAddingParam(members.value, membername, param)
	if(!match)
	{
		AppendStructureMemberParam(members.next, membername, param)
	}
}

CheckMemberForAddingParam : StructureMemberVariable ref member, integer membername, Parameter ref param -> false

CheckMemberForAddingParam : StructureMemberFunctionRef ref member, integer membername, Parameter ref param -> boolean ret = false
{
	if(member.Name == membername)
	{
		AppendParameter(member.Signature.Parameters, param)
		ret = true
	}
}



OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname
{
	FindStructureAndSetConstructors(structurename, constructorname, anonname, copyname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, constructorname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, anonname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, copyname)
}

FindStructureAndSetConstructors : integer structurename, integer constructorname, integer anonname, integer copyname
{
	ContextWrapper<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, structurename, wrap)
	assert(found)

	SetConstructors(wrap.Wrapped, constructorname, anonname, copyname)
}

SetConstructors : StructureDefinition ref struct, integer constructorname, integer anonname, integer copyname
{
	struct.ConstructorName = constructorname
	struct.AnonConstructorName = anonname
	struct.CopyConstructorName = copyname
}


FindSumTypeAndAddBase : list<SumType> ref sumtypes, integer sumtypename, integer sumtypeid, integer basetypeid, boolean templated
{
	if(sumtypes.value.Type == sumtypeid)
	{
		SumTypeBase base = basetypeid, nothing
		
		if(templated)
		{
			PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
			TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
			base.TemplateArgs = arglist
			
			PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
		}
		
		prepend<SumTypeBase>(sumtypes.value.Bases, base)
	}
	else
	{
		FindSumTypeAndAddBase(sumtypes.next, sumtypename, sumtypeid, basetypeid, templated)
	}
}

FindSumTypeAndAddBase : nothing, integer sumtypename, integer sumtypeid, integer basetypeid, boolean templated
{
	SumTypeBase base = basetypeid, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
		base.TemplateArgs = arglist
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}	
	
	list<SumTypeBase> bases = base, nothing
	SumType st = sumtypename, sumtypeid, bases, false
	prepend<SumType>(SumTypes, st)
}


SetUpSumTypeTemplate : list<SumType> ref sumtypes, integer sumtypeid
{
	if(sumtypes.value.Type == sumtypeid)
	{
		sumtypes.value.IsTemplate = true
		CreateSumTypeTemplateAndAttachParams(sumtypes.value.Name, TemplateParameterQueue)
		
		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
	else
	{
		SetUpSumTypeTemplate(sumtypes.next, sumtypeid)
	}
}

SetUpSumTypeTemplate : nothing, integer sumtypeid
{
	print("Sum type not found!")
	assert(false)
}


OnCodeGenRegisterScope : integer scopename, integer parentname
{
	list<Variable> v = dummyvar, nothing
	Scope scope = scopename, parentname, v, 0, 0
	prepend<Scope>(Scopes, scope)
}

StoreVariableInSingleScope : Scope ref scope, integer varname, integer vartype, boolean isref, integer origin
{
	integer size = 4		// TODO - actual variable sizes

	if((vartype & 0xff000000) == 0x07000000)		// Sum type family signature
	{
		size = 8
	}
	elseif(vartype == 0x01000003)
	{
		size = 1
	}

	integer offset = -1
	if(origin == 1)			// VARIABLE_ORIGIN_PARAMETER
	{
		if(isref)
		{
			size = 8
		}

		offset = scope.ParamOffset
		scope.ParamOffset = scope.ParamOffset + size
	}
	else
	{
		offset = scope.LocalOffset
		scope.LocalOffset = scope.LocalOffset + size
	}

	Variable var = varname, vartype, origin, offset
	append(scope.Variables, var)
}

OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
}


RegisterOverloadForFunction : string rawnamestr, integer rawname -> integer mangledname = rawname
{
	integer existingcount = 0
	
	ContextWrapper<FunctionDefinition> funcwrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, rawname, funcwrap)
	if(found)
	{
		existingcount = CountOverloadsForContext(funcwrap.Wrapped, rawname)
	}
	else
	{
		existingcount = CountOverloads(Overloads, rawname)
	}
	
	if(existingcount > 0)
	{
		mangledname = PoolString(rawnamestr ; "@overload@" ; cast(string, existingcount))
	}
	
	Overload overload = rawname, mangledname, nothing
	prepend<Overload>(Overloads, overload)
	
	if(found)
	{
		AddOverloadToFunc(funcwrap.Wrapped, overload)
	}
}


FindFunctionAndAddOverload : Overload ref overload
{
	ContextWrapper<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, overload.NormalName, wrap)
	if(found)
	{
		AddOverloadToFunc(wrap.Wrapped, overload)
	}
}

AddOverloadToFunc : FunctionDefinition ref func, Overload ref overload
{
	prepend<Overload>(func.Overloads, overload)
}


CountOverloadsForContext : FunctionDefinition ref func, integer rawname -> integer count = 0
{
	count = CountOverloads(func.Overloads, rawname)
}


CountOverloads : list<Overload> ref overloads, integer rawname -> integer count = 0
{
	if(rawname == overloads.value.NormalName)
	{
		++count
	}
	
	count += CountOverloads(overloads.next, rawname)
}

CountOverloads : nothing, integer rawname -> 0


AttachContextToOverload : list<Overload> ref overloads, integer mangledname, FunctionDefinition ref func
{
	if(overloads.value.MangledName == mangledname)
	{
		overloads.value.Implementation = func
	}
	else
	{
		AttachContextToOverload(overloads.next, mangledname, func)
	}
}


OnCodeGenRegisterFunction : integer funcname, integer rawfuncname, string rawfuncnamestr, boolean istemplate
{
	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = rawfuncname, funcname, nothing, nothing, nothing, dummyoverloadlist, scopewrap, rawfuncnamestr, 0, false, istemplate, false
	prepend<FunctionDefinition>(Functions, func)
	InsertIntoBinaryTree<FunctionDefinition>(FunctionsWhichExist, funcname, func)
	
	// TODO - this is a weird bug. For some reason we don't init the field correctly in the above constructor
	if(istemplate)
	{
		func.IsTemplate = true
	}
	
	if(funcname != rawfuncname)
	{
		AttachContextToOverload(Overloads, funcname, func)
		
		ContextWrapper<FunctionDefinition> wrap = nothing
		if(SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, rawfuncname, wrap))
		{
			AttachContextToFunction(wrap.Wrapped, funcname, func)
		}
	}
	
	Overload selfoverload = rawfuncname, funcname, func
	prepend<Overload>(func.Overloads, selfoverload)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack
	
	if(istemplate)
	{
		CreateFunctionTemplateAndAttachParams(funcname, TemplateParameterQueue)
		
		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
}


AttachContextToFunction : FunctionDefinition ref funcraw, integer mangledfuncname, FunctionDefinition ref func
{
	AttachContextToOverload(funcraw.Overloads, mangledfuncname, func)
}


IRRegisterFunctionParam : integer paramname, integer paramtypename, boolean isref, boolean templated
{
	UnresolvedParameter p = paramname, paramtypename, 0, isref, nothing, nothing
	
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		p.TemplateArgs = ScratchTemplateArgumentStack.value
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}
	
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, FunctionParams ref params, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(params.Params, params.Params.next, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	FunctionParams fp = newlist
	OptionalParameters params = fp
	func.Params = params
}


AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, list<UnresolvedParameter> ref tail, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(tail, tail.next, p)
}

AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	thelist.next = newlist
}


OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d

	Functions.value.AnonymousReturn = anonymous
	InFuncRetHack = true
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	PopContext(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
		InFuncRetHack = false
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		assertmsg(CodeBlockDepth(CurrentCodeBlockStack) == 1, "Code block depth is invalid")
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		AppendEntityToChain(ChainStack, entity)
		PopEntityStack(EntityStack, EntityStack.next)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		CodeBlockEntry cbe = ChainStack.value
		AppendEntryToCurrentCodeBlock(cbe)
		PopChain(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		ExpressionOrPrePostOp epp = ScratchExpressions.value
		ParentheticalExpression parenthetical = epp
		ExpressionAtom atom = parenthetical
		PopExpression(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}

PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	print("No contexts available")
	assert(false)
}

PopExpression : list<Expression> ref thelist, list<Expression> ref next
{
	thelist = next
}

PopExpression : list<Expression> ref thelist, nothing



PopCodeBlock : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref next
{
	stack = next
}

PopCodeBlock : list<OptionalCodeBlock> ref stack, nothing
{
	list<OptionalCodeBlock> newlist = nothing, nothing
	stack = newlist
}


PopEntityStack : list<Entity> ref stack, list<Entity> ref next
{
	stack = next
}

PopEntityStack : list<Entity> ref stack, nothing


PopChain : list<EntityChain> ref stack, list<EntityChain> ref next
{
	stack = next
}

PopChain : list<EntityChain> ref stack, nothing



PopCurrentStatementAndAppendToScratchExpression : list<Expression> ref expressions, list<Expression> ref tail
{
	ExpressionAtom atom = SubStatements.value

	expressions = tail

	PlaceAtomInScratchExpression(atom)
	PopSubStatement(SubStatements, SubStatements.next)
}

SetReturnExpression : FunctionDefinition ref funcdef, Expression ref expr
{
	funcdef.Return = expr

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

SetGlobalCodeBlock : CodeBlock ref block
{
	GlobalCodeBlock = block
}

SetGlobalCodeBlock : nothing


PopSubStatement : list<Statement> ref statements, list<Statement> ref tail
{
	statements = tail
}

OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	list<FunctionSignature> dsl = dummysignature, nothing
	TypeMatcher matcher = matchername, dsl
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


PlaceAtomInScratchExpression : ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(ScratchExpressions.value.Atoms.value))
	{
		list<ExpressionAtom> atoms = atom, nothing
		Expression newexpr = atoms, 0
		ScratchExpressions.value = newexpr
	}
	else
	{
		AppendAtomToExpression(ScratchExpressions.value.Atoms, ScratchExpressions.value.Atoms.next, atom)
	}
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0xff000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(TypeAliases, literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifierReference : integer idhandle
{
	IdentifierAtom id = idhandle, 0, true, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterTypeAnnotation : integer annotationtype
{
	TypeAnnotationAtom taa = annotationtype
	ExpressionAtom atom = taa
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}


ExpressionAtomIsSentinel : AtomSentinel 	   ref sentinel    -> true [nogc]
ExpressionAtomIsSentinel : StringHandleAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : IdentifierAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : integer 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : integer16 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : boolean 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : real 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : Statement		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : RefBinding              ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : CompoundAtom            ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : ParentheticalExpression ref nonsentinel -> false [nogc]



AppendAtomToExpression : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, ExpressionAtom ref atom
{
	AppendAtomToExpression(tail, tail.next, atom)
}

AppendAtomToExpression : list<ExpressionAtom> ref atoms, nothing, ExpressionAtom ref atom
{
	list<ExpressionAtom> newatoms = atom, nothing
	atoms.next = newatoms
}


OnCodeGenEnterStatement : integer statementname, integer statementtype, boolean toplevel, boolean hastemplateargs
{
	Statement statement = statementname, nothing, statementtype, nothing, toplevel, false
	
	if(hastemplateargs)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next) 
		statement.TemplateArgs = ScratchTemplateArgumentStack.value
		
		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}
	
	OnCodeGenEmplaceStatement(statement)
}

OnCodeGenEmplaceStatement : Statement ref statement
{
	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statement.Name
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}

OnCodeGenEnterAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}


OnCodeGenChainAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}


OnCodeGenEnterAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}



OnCodeGenChainAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}

OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}



AppendEntryToCurrentAssignmentChain : Assignment ref a
{
	AppendEntryToCurrentAssignmentChainWorker(CurrentCodeBlockStack, a)
}

AppendEntryToCurrentAssignmentChain : AssignmentCompound ref a
{
	AppendEntryToCurrentAssignmentChainWorker(CurrentCodeBlockStack, a)
}

AppendEntryToCurrentAssignmentChainWorker : list<OptionalCodeBlock> ref blockstack, Assignment ref a
{
	AppendEntryToAssignmentChain(blockstack, blockstack.next, a)
}

AppendEntryToCurrentAssignmentChainWorker : list<OptionalCodeBlock> ref blockstack, AssignmentCompound ref a
{
	AppendEntryToAssignmentChain(blockstack, blockstack.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref tail, Assignment ref a
{
	AppendEntryToAssignmentChain(tail, tail.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, nothing, Assignment ref a
{
	GetTailAssignmentAndChain(stack.value, a)
}


AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref tail, AssignmentCompound ref a
{
	AppendEntryToAssignmentChain(tail, tail.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, nothing, AssignmentCompound ref a
{
	GetTailAssignmentAndChain(stack.value, a)
}


GetTailAssignmentAndChain : CodeBlock ref codeblock, Assignment ref a
{
	FindTailAssignmentAndChain(codeblock.Entries, codeblock.Entries.next, a)
}

GetTailAssignmentAndChain : CodeBlock ref codeblock, AssignmentCompound ref a
{
	FindTailAssignmentAndChain(codeblock.Entries, codeblock.Entries.next, a)
}


FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, Assignment ref a
{
	FindTailAssignmentAndChain(tail, tail.next, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, nothing, Assignment ref a
{
	ChainAssignment(entries.value, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, AssignmentCompound ref a
{
	FindTailAssignmentAndChain(tail, tail.next, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, nothing, AssignmentCompound ref a
{
	ChainAssignment(entries.value, a)
}

ChainAssignment : Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

ChainAssignment : AssignmentCompound ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}


ChainAssignment : Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

ChainAssignment : AssignmentCompound ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}


AddAssignmentToChain : Assignment ref tomodify, Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : Assignment ref tomodify, Expression ref expr, Assignment ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Expression ref expr, Assignment ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : Assignment ref tomodify, Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : Assignment ref tomodify, Expression ref expr, AssignmentCompound ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Expression ref expr, AssignmentCompound ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}


AppendEntryToCurrentCodeBlock : CodeBlockEntry ref cbe
{
	AppendEntryToCurrentCodeBlockWorker(CurrentCodeBlockStack, cbe)
}

AppendEntryToCurrentCodeBlockWorker : list<OptionalCodeBlock> ref blockstack, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(blockstack, blockstack.value, entry)
}

AppendEntryToCurrentCodeBlockWorker : nothing, CodeBlockEntry ref entry
{
	print("No code block is being processed")
	assert(false)
}


FindCurrentFunctionAndAppendCompoundMember : integer membername
{
	FindLastAssignmentAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}

FindCurrentFunctionAndChainCompoundMember : integer membername
{
	FindLastAssignmentAndChainCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}


FindLastAssignmentAndAppendCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(code.Entries, code.Entries.next, membername)
}

FindLastAssignmentAndChainCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndChainCompoundMember(code.Entries, code.Entries.next, membername)
}



AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, CodeBlock ref code, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(code.Entries, entry)
}

AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> stmtlist = entry, nothing
	CodeBlock block = stmtlist
	OptionalCodeBlock blockwrap = block
	stack.value = blockwrap
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(entries, entries.next, entry)
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> newlist = entry, nothing
	entries.next = newlist
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, CodeBlockEntry ref value
{
	AppendEntryToCodeBlock(tail, tail.next, value)
}


FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}


FindLastAssignmentAndChainCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndChainCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndChainCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	ChainCompoundMemberHelper(entries.value, membername)
}


ChainCompoundMemberHelper : Assignment ref a, integer membername
{
	ChainCompoundMember(a, a.RHS, membername)
}

ChainCompoundMemberHelper : AssignmentCompound ref a, integer membername
{
	ChainCompoundMember(a, a.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, Assignment ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : AssignmentCompound ref tomodify, Assignment ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, AssignmentCompound ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : AssignmentCompound ref tomodify, AssignmentCompound ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, Expression ref rhs, integer membername
{
	print("Fatal error - parser tried to associate a member with a non-compound assignment")
	assert(false)
}

ChainCompoundMember : AssignmentCompound ref tomodify, Expression ref rhs, integer membername
{
	AppendCompoundMemberHelper(tomodify, membername)
}


AppendCompoundMemberHelper : AssignmentCompound ref a, integer membername [nogc]
{
	AppendCompoundMember(a.LHS, a.LHS.next, membername)
}

AppendCompoundMemberHelper : PreOpStatement ref s, integer membername [nogc]
{
	AppendCompoundMember(s.Operand, s.Operand.next, membername)
}

AppendCompoundMemberHelper : PostOpStatement ref s, integer membername [nogc]
{
	AppendCompoundMember(s.Operand, s.Operand.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, simplelist<integer> ref tail, integer membername [nogc]
{
	AppendCompoundMember(tail, tail.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, nothing, integer membername [nogc]
{
	simplelist<integer> newtail = membername, nothing
	members.next = newtail
}



FindCurrentStatementAndAppendExpression : Expression ref expression
{
	FindLastStatementInBlockAndAppendExpression(CurrentCodeBlockStack.value, expression)
}

FindCurrentStatementAndAppendExpression : nothing


FindCurrentAssignmentAndSetExpression : Expression ref expression
{
	FindLastAssignmentInBlockAndSetExpression(CurrentCodeBlockStack.value, expression)
}



FindLastStatementInBlockAndAppendExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastStatementAndAppendExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastStatementInBlockAndAppendExpression : nothing, Expression ref expression
{
	print("Not processing an active code block!")
	assert(false)
}


FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastStatementAndAppendExpression(tail, tail.next, expression)
}

FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	AppendExpressionToStatement(codeblockentries.value, expression)
}


AppendExpressionToStatement : Statement ref statement, Expression ref expression
{
	AppendExpressionToStatementParams(statement, statement.Parameters, expression)
}

AppendExpressionToStatementParams : Statement ref statement, ExpressionList ref parameters, Expression ref expression
{
	AppendExpression(parameters.Expressions, parameters.Expressions.next, expression)
}

AppendExpressionToStatementParams : Statement ref statement, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	ExpressionList params = newlist
	statement.Parameters = params
}

AppendExpression : list<Expression> ref expressions, list<Expression> ref tail, Expression ref expression
{
	AppendExpression(tail, tail.next, expression)
}

AppendExpression : list<Expression> ref expressions, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	expressions.next = newlist
}


FindLastAssignmentInBlockAndSetExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastAssignmentAndSetExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastAssignmentAndSetExpression(tail, tail.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	SetAssignmentExpression(codeblockentries.value, expression)
}

SetAssignmentExpression : Assignment ref assignment, Expression ref expression
{
	FollowChainAndSetExpression(assignment, assignment.RHS, expression)
}

SetAssignmentExpression : AssignmentCompound ref assignment, Expression ref expression
{
	FollowChainAndSetExpression(assignment, assignment.RHS, expression)
}


FollowChainAndSetExpression : Assignment ref assignment, Assignment ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : Assignment ref assignment, AssignmentCompound ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : AssignmentCompound ref assignment, Assignment ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : AssignmentCompound ref assignment, AssignmentCompound ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : Assignment ref tomodify, Expression ref rhs, Expression ref newrhs
{
	ExpressionOrAssignment wrap = newrhs
	tomodify.RHS = wrap
}

FollowChainAndSetExpression : AssignmentCompound ref tomodify, Expression ref rhs, Expression ref newrhs
{
	ExpressionOrAssignment wrap = newrhs
	tomodify.RHS = wrap
}



SetFunctionCodeBlock : FunctionDefinition ref funcdef, OptionalCodeBlock ref optblock
{
	SetFunctionCodeBlockWorker(funcdef, optblock)
}

SetFunctionCodeBlock : nothing, OptionalCodeBlock ref optblock
{
	print("No function in flight")
	assert(false)
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, CodeBlock ref block
{
	funcdef.Code = block
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, nothing



CodeGenEmitStrings : list<StringTableEntry> ref table
{
	listnode<StringTableEntry> cur = table
	while(HasSTEntry(cur))
	{
		if(GetSTHandle(cur) != 0)
		{
			OnBytecodePoolString(GetSTHandle(cur), GetSTData(cur))
		}
		
		cur = GetSTNext(cur)
	}
}

HasSTEntry : list<StringTableEntry> ref table -> true
HasSTEntry : nothing -> false

GetSTHandle : list<StringTableEntry> ref table -> integer handle = table.value.Handle
GetSTData : list<StringTableEntry> ref table -> string data = table.value.Data
GetSTNext : list<StringTableEntry> ref table -> listnode<StringTableEntry> ret = table.next

CodeGenEmitStructures : list<StructureDefinition> ref structures
{
	CodeGenEmitStructures(structures.next)

	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		OnBytecodeDefineStructure(structures.value.Type, structures.value.MemberCount)
		CodeGenEmitMembers(structures.value.Members)
	}
}

CodeGenEmitStructures : nothing

CodeGenEmitMembers : list<StructureMember> ref members
{
	CodeGenEmitMember(members.value)
	CodeGenEmitMembers(members.next)
}

CodeGenEmitMembers : nothing

CodeGenEmitMember : StructureMemberVariable ref memvar
{
	OnBytecodeStructureMember(memvar.Name, memvar.Type)
}

CodeGenEmitMember : StructureMemberFunctionRef ref member
{
	OnBytecodeStructureMember(member.Name, GetMemberTypeDecompose(member))
}



CodeGenEmitScopes : list<Scope> ref scopes
{
	CodeGenEmitScopes(scopes.next)

	if((scopes.value.Name != 0) && (scopes.value.Name != GlobalCodeBlockName))
	{
		integer parentname = scopes.value.ParentName
		if((parentname == 0) && (scopes.value.Name != GlobalCodeBlockName))
		{
			parentname = GlobalCodeBlockName
		}
		
		integer varcount = CountScopeVariables(scopes.value)
		OnBytecodeLexicalScope(scopes.value.Name, parentname, varcount)
		CodeGenEmitVariables(scopes.value.Variables, scopes.value.Name)
	}
}

CodeGenEmitScopes : nothing


CodeGenEmitSpecificScope : Scope ref scope
{
	integer varcount = CountScopeVariables(scope)
	OnBytecodeLexicalScope(scope.Name, 0, varcount)
	CodeGenEmitVariables(scope.Variables, 0)
}


CountScopeVariables : Scope ref scope -> integer count = 0 [nogc]
{
	CountScopeVariables(scope.Variables, count)
}

CountScopeVariables : list<Variable> ref variables, integer ref count [nogc]
{
	if(variables.value.Name != 0)
	{
		++count
	}

	CountScopeVariables(variables.next, count)
}

CountScopeVariables : nothing, integer ref count [nogc]


CodeGenEmitVariables : list<Variable> ref vars, integer funcname
{
	if(vars.value.Name != 0)
	{
		integer basetype = vars.value.VarType
		while((basetype & 0x7f000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(TypeAliases, basetype)
		}

		if(vars.value.Origin == 2)
		{
			if(listcontains(CustomConstructors, funcname))
			{
				OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, 0)
			}
			else
			{
				OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, vars.value.Origin)
			}
		}
		else
		{
			OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, vars.value.Origin)
		}
	}

	CodeGenEmitVariables(vars.next, funcname)
}

CodeGenEmitVariables : nothing, integer funcname



CodeGenEmitFunctions : list<FunctionDefinition> ref table
{
	if(!table.value.IsTemplate)
	{
		if(table.value.Name != 0)
		{
			FindScopeAndSetContext(table.value)
			
			EmittingFunctionName = table.value.Name
			OnBytecodeEnterFunction(table.value.Name)
			CodeGenEmitFunctionReturn(table.value.Return)

			if(table.value.InvokeTag != 0)
			{
				OnBytecodeInvoke(table.value.InvokeTag)
			}

			CodeGenEmitCodeBlock(table.value.Code)
			if(listcontains(CustomConstructors, table.value.Name))
			{
				OnBytecodePushVarNoCopy(FindReturnVariableName())
				OnBytecodeBindReference(0, 0)			// TODO - kind of a hack
				OnBytecodeAssign()
			}
			else
			{
				if(table.value.AnonymousReturn)
				{
					CodeGenEmitReturnRegisterAnonymous(table.value.Return)
				}
				else
				{
					CodeGenEmitReturnRegister(table.value.Return)
				}
			}
			OnBytecodeExitFunction()
		}
	}
	
	CodeGenEmitFunctions(table.next)
}

CodeGenEmitFunctions : nothing


FindScopeAndSetContext : FunctionDefinition ref func [nogc]
{
	EmittingScope.Wrapped = func.AttachedScope.Wrapped
}

HasScope : Scope ref scope -> true [nogc]
HasScope : nothing -> false [nogc]


CodeGenEmitFunctionReturn : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitFunctionReturn : nothing


CodeGenEmitReturnRegister : Expression ref expr
{
	integer index = FindReturnVariableIndex()
	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegister : nothing


CodeGenEmitReturnRegisterAnonymous : Expression ref expr
{
	integer index = FindReturnVariableIndex()

	OnBytecodeBindReference(0, index)
	OnBytecodeAssign()

	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegisterAnonymous : nothing



CodeGenEmitCodeBlock : CodeBlock ref block
{
	CodeGenEmitCodeBlockEntries(block.Entries)
}

CodeGenEmitCodeBlock : nothing


CodeGenEmitCodeBlockEntries : list<CodeBlockEntry> ref entries
{
	CodeGenEmitSingleCodeBlockEntry(entries.value)
	CodeGenEmitCodeBlockEntries(entries.next)
}

CodeGenEmitCodeBlockEntries : nothing


CodeGenEmitSingleCodeBlockEntry : Statement ref s
{
	boolean sumtype = SumTypeExists(s.Name)
	boolean constructssumtype = false
	if((s.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtype = true
	}

	boolean constructorcall = StructureConstructorExists(Structures, s.Name)

	CodeGenEmitExpressionList(s.Parameters, constructssumtype, constructorcall)

	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(EmittingScope.Wrapped, s.Name, var)
	if((var.Name != 0) && ((var.VarType & 0xff000000) == 0x09000000))
	{
		OnBytecodeInvokeIndirect(s.Name)
	}
	elseif(sumtype)
	{
		OnBytecodeConstructSumType()
	}
	elseif(FunctionIsAutoGenOrHasIR(s.Name))
	{
		OnBytecodeInvokeOffset(s.Name)
	}
	else
	{
		OnBytecodeInvoke(s.Name)
	}
}

CodeGenEmitAssignmentRHS : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitAssignmentRHS : Assignment ref a
{
	CodeGenEmitAssignmentRHS(a.RHS)
		
	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
	
	CodeGenEmitBindingsForVariable(a.LHSName)
	OnBytecodeReadReference()
}

CodeGenEmitSingleCodeBlockEntry : Assignment ref a
{
	boolean sideeffects = false
	
	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForVariable(a.LHSName)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)
	
	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}

CodeGenEmitSingleCodeBlockEntry : AssignmentCompound ref a
{
	boolean sideeffects = false
	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForOperand(a.LHS)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)
	
	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHS.value, frames)
	OnBytecodeBindReference(frames, index)

	integer typeid = MakeNonReferenceType(FindVariableType(a.LHS.value))

	integer structurename = GetNameOfStructureByType(typeid)
	BindAssignmentMembers(a.LHS.next, structurename)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()	
	}
	else
	{
		OnBytecodeAssign()
	}
}


CodeGenEmitBindingsForOperand : simplelist<integer> ref operand
{
	integer frames = 0
	integer index = FindVariable(operand.value, frames)
	OnBytecodeBindReference(frames, index)

	integer structurename = GetNameOfStructureByType(FindVariableType(operand.value))
	BindAssignmentMembers(operand.next, structurename)
}

CodeGenEmitBindingsForVariable : integer operand
{
	integer frames = 0
	integer index = FindVariable(operand, frames)
	OnBytecodeBindReference(frames, index)	
}


CodeGenEmitSingleCodeBlockEntry : PreOpStatement ref preop
{
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(preop.Operator)
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeAssign()
}

CodeGenEmitSingleCodeBlockEntry : PostOpStatement ref postop
{
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(postop.Operator)
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeAssign()
}



CodeGenEmitSingleCodeBlockEntry : EntityChain ref chain
{
	OnBytecodeBeginChain()
	CodeGenEmitEntityChain(chain.Entries)
	OnBytecodeEndChain()
}


CodeGenEmitEntityChain : EntityList ref entities
{
	CodeGenEmitEntityList(entities.ActualList)
}

CodeGenEmitEntityList : list<Entity> ref thelist
{
	if(thelist.value.Tag != 0)
	{
		CodeGenEmitExpression(thelist.value.Param, false, false)
		OnBytecodeEnterEntity(thelist.value.Tag, 0)
		CodeGenEmitCodeBlock(thelist.value.Code)
		OnBytecodeExitEntity()
	}

	CodeGenEmitEntityList(thelist.next)
}

CodeGenEmitEntityList : nothing


BindAssignmentMembers : simplelist<integer> ref lhsmembers, integer structurename
{
	integer membertype = 0
	integer memberoffset = 0
	GetStructureMemberTypeAndOffset(structurename, lhsmembers.value, membertype, memberoffset)

	OnBytecodeBindStructReference(membertype, memberoffset)

	// Recurse
	assertmsg(membertype != 0, "Member has no type!")
	BindAssignmentMembers(lhsmembers.next, GetNameOfType(membertype))
}

BindAssignmentMembers : nothing, integer structurename


ComputeCompoundAssignmentLHSType : AssignmentCompound ref assignment, Scope ref scope -> integer typeid = 0
{
	integer rootname = assignment.LHS.value
	
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(scope, rootname, var)
	
	if(var.Name == 0)
	{
		print("Assignment has bogus LHS")
		assert(false)
	}
	
	assertmsg(var.VarType != 0, "Variable has no type!")
	
	integer vartypename = GetNameOfType(var.VarType)
	typeid = ComputeCompoundAssignmentLHSTypeMembers(assignment.LHS.next, vartypename)
}

ComputeCompoundAssignmentLHSTypeMembers : simplelist<integer> ref lhsmembers, integer structurename -> integer typeid = 0
{
	integer membertype = GetStructureMemberType(structurename, lhsmembers.value)
	assertmsg(membertype != 0, "Member in compound assignment has no type!")
	typeid = ComputeCompoundAssignmentLHSTypeMembers(lhsmembers.next, GetNameOfType(membertype))
}

ComputeCompoundAssignmentLHSTypeMembers : nothing, integer structurename -> integer typeid = GetTypeByName(structurename)




CodeGenEmitExpressionList : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpressionList : ExpressionList ref expressions, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionList(expressions.Expressions, constructssumtype, constructorcall)
}

CodeGenEmitExpressionList : list<Expression> ref expressions, boolean constructssumtype, boolean constructorcall
{
	boolean constructssumtypetemp = constructssumtype
	if((expressions.value.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtypetemp = true
	}

	CodeGenEmitExpressionAtoms(expressions.value.Atoms, constructssumtypetemp, constructorcall)
	CodeGenEmitExpressionList(expressions.next, constructssumtype, constructorcall)
}

CodeGenEmitExpression : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpression : Expression ref expr, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionAtoms(expr.Atoms, constructssumtype, constructorcall)
}

CodeGenEmitExpressionAtoms : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean constructorcall
{
	boolean needsref = false
	CodeGenEmitExpressionAtomsWorker(atoms, constructssumtype, needsref, constructorcall)
	if(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

CodeGenEmitExpressionAtomsWorker : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean ref needsref, boolean constructorcall
{
	boolean thisneedsref = CodeGenCheckAtomForReadRef(atoms.value)
	if(thisneedsref)
	{
		needsref = true
	}
	elseif(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
		needsref = false
	}

	CodeGenEmitSingleAtom(atoms.value, constructorcall)
	CodeGenEmitExpressionAtomsWorker(atoms.next, constructssumtype, needsref, constructorcall)
}

CodeGenEmitExpressionAtomsWorker : nothing, boolean constructssumtype, boolean ref needsref, boolean constructorcall


CodeGenCheckAtomForReadRef : RefBinding ref atom -> !atom.IsReference [nogc]
CodeGenCheckAtomForReadRef : CompoundAtom ref atom -> false [nogc]

CodeGenCheckAtomForReadRef : integer ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : integer16 ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : boolean ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : real ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : IdentifierAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : StringHandleAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : OperatorInvokeAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : TypeAnnotationAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : Statement ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : ParentheticalExpression ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : AtomSentinel ref atom -> false [nogc]




CodeGenEmitSingleAtom : integer ref literalinteger, boolean constructor
{
	OnBytecodePushLiteralInteger(literalinteger)
}

CodeGenEmitSingleAtom : integer16 ref literalinteger16, boolean constructor
{
	OnBytecodePushLiteralInteger16(literalinteger16)
}

CodeGenEmitSingleAtom : boolean ref literalboolean, boolean constructor
{
	OnBytecodePushBoolean(literalboolean)
}

CodeGenEmitSingleAtom : real ref literalreal, boolean constructor
{
	OnBytecodePushLiteralReal(literalreal)
}

CodeGenEmitSingleAtom : StringHandleAtom ref atom, boolean constructor
{
	OnBytecodePushLiteralString(atom.Handle)
}

CodeGenEmitSingleAtom : OperatorInvokeAtom ref atom, boolean constructor
{
	OnBytecodeInvoke(atom.OperatorName)
}

CodeGenEmitSingleAtom : IdentifierAtom ref idatom, boolean constructor
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		OnBytecodePushLiteralInteger(0)
	}
	else
	{
		if(idatom.IsFunction)
		{
			OnBytecodePushLiteralFunction(idatom.Handle)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			OnBytecodePushLiteralString(idatom.Handle)
		}	
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if((!constructor) && (!idatom.IsReference))
				{
					OnBytecodePushLiteralString(idatom.Handle)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				OnBytecodePushLiteralFunction(idatom.Handle)
			}
			else
			{		
				if(idatom.IsReference)
				{	
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)

					if(frames == 0)
					{
						OnBytecodePushVarValue(idatom.Handle, idatom.Type)
					}
					elseif(IsReferenceType(idatom.Type))
					{
						OnBytecodeBindReference(frames, index)
					}
					else
					{
						Variable var = 0, 0, 0, 0
						FindVariableDataInSingleScope(EmittingScope.Wrapped, idatom.Handle, var)
						
						if(var.Name == 0)
						{
							print("Code generation error - missing local variable " ; GetPooledString(GlobalStrings, idatom.Handle) ; " in scope " ; GetPooledString(GlobalStrings, EmittingFunctionName))
							assert(false)
						}
						OnBytecodePushLocal(false, frames, var.Offset, 0)
					}
				}
			}
		}
	}
}

CodeGenEmitSingleAtom : TypeAnnotationAtom ref atom, boolean constructor
{
	OnBytecodePushTypeAnnotation(MakeNonReferenceType(atom.Type))
}

CodeGenEmitSingleAtom : Statement ref atom, boolean constructor
{
	CodeGenEmitSingleCodeBlockEntry(atom)
}

CodeGenEmitSingleAtom : RefBinding ref atom, boolean constructor
{
	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(atom.StructureName, atom.Identifier, memtype, memoffset)
	
	OnBytecodeBindStructReference(memtype, memoffset)
}

CodeGenEmitSingleAtom : ParentheticalExpression ref expr, boolean constructor
{
	CodeGenDecomposeParenthetical(expr.Inner)
}

CodeGenDecomposeParenthetical : Expression ref expr
{
	CodeGenEmitExpression(expr, false, false)
}

CodeGenDecomposeParenthetical : PreOpStatement ref statement
{
	CodeGenEmitSingleCodeBlockEntry(statement)
	CodeGenEmitBindingsForOperand(statement.Operand)
	OnBytecodeReadReference()
}

CodeGenDecomposeParenthetical : PostOpStatement ref statement
{
	CodeGenEmitBindingsForOperand(statement.Operand)
	OnBytecodeReadReference()
	CodeGenEmitSingleCodeBlockEntry(statement)
}

CodeGenEmitSingleAtom : CompoundAtom ref atom, boolean constructor
{
	integer frames = 0
	integer index = FindVariable(atom.Bindings.value.Identifier, frames)
	OnBytecodeBindReference(frames, index)
	
	EmitCompoundBindings(atom.Bindings, atom.Bindings.next)
	
	if(!IsReferenceType(atom.Type))
	{
		if((atom.Type & 0x7f000000) == 0x07000000)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

EmitCompoundBindings : list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(EmittingScope.Wrapped, bindings.value.Identifier, var)
	
	assertmsg(var.VarType != 0, "Compound bindings reference bogus variable")
	integer lhstypename = GetNameOfType(var.VarType)
		
	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(lhstypename, tail.value.Identifier, memtype, memoffset)
	
	OnBytecodeBindStructReference(memtype, memoffset)

	EmitCompoundSubsequentBindings(tail.next)
}

EmitCompoundSubsequentBindings : nothing

EmitCompoundSubsequentBindings : list<RefBinding> ref bindings
{
	CodeGenEmitSingleAtom(bindings.value, false)
	EmitCompoundSubsequentBindings(bindings.next)
}


CodeGenEmitSingleAtom : AtomSentinel ref sentinel, boolean constructor


GetNameOfStructureByType : integer typeid -> integer name = 0
{
	name = GetNameOfStructureByType(Structures, typeid)
}

GetNameOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.Name
	}
	else
	{
		name = GetNameOfStructureByType(structures.next, typeid)
	}
}

GetNameOfStructureByType : nothing, integer typeid -> integer name = 0



GetSizeOfStructureByType : integer typeid -> integer size = 0
{
	size = GetSizeOfStructureByType(Structures, typeid)
}

GetSizeOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer size = 0
{
	if(structures.value.Type == typeid)
	{
		size = GetTotalMemberSize(structures.value.Members)
	}
	else
	{
		size = GetSizeOfStructureByType(structures.next, typeid)
	}
}

GetSizeOfStructureByType : nothing, integer typeid -> integer name = 0


GetTotalMemberSize : list<StructureMember> ref members -> integer size = 0
{
	integer recursedsize = GetTotalMemberSize(members.next)
	size = GetMemberSize(members.value) + recursedsize
}

GetTotalMemberSize : nothing -> integer size = 0



GetStructureMemberTypeAndOffset : integer structurename, integer membername, integer ref memtype, integer ref memoffset
{
	ContextWrapper<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, structurename, wrap)
	assert(found)

	memtype = 0
	memoffset = 0
	GetMemberTypeAndOffset(wrap.Wrapped, membername, memtype, memoffset)
}

GetStructureMemberType : integer structurename, integer membername -> integer rtype = 0
{
	ContextWrapper<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, structurename, wrap)
	if(found)
	{
		rtype = GetMemberType(wrap.Wrapped, membername)
	}
	else
	{
		print("Bogus structure")
		assert(false)
	}
}


GetMemberType : StructureDefinition ref struct, integer membername -> integer ty = GetMemberType(struct.Members, membername)


GetMemberType : list<StructureMember> ref members, integer membername -> integer rtype = 0
{
	if(GetMemberName(members.value) == membername)
	{
		rtype = GetMemberTypeDecompose(members.value)
		assertmsg(rtype != 0, "Member has no type; cannot return from GetMemberType")
	}
	else
	{
		rtype = GetMemberType(members.next, membername)
	}
}

GetMemberType : nothing, integer membername -> integer rtype = 0
{
	print("Bogus structure member!")
	assert(false)
}


GetMemberTypeAndOffset : StructureDefinition ref struct, integer membername, integer ref memtype, integer ref memoffset
{
	GetMemberTypeAndOffset(struct.Members, membername, memtype, memoffset)
}


GetMemberTypeAndOffset : list<StructureMember> ref members, integer membername, integer ref memtype, integer ref memoffset
{
	integer thisname = GetMemberName(members.value)
	if(thisname == membername)
	{
		memtype = GetMemberTypeDecompose(members.value)
	}
	else
	{
		if(thisname != 0)
		{
			memoffset += GetMemberSize(members.value)
		}
		GetMemberTypeAndOffset(members.next, membername, memtype, memoffset)
	}
}

GetMemberTypeAndOffset : nothing, integer membername, integer ref memtype, integer ref memoffset
{
	print("Bogus structure member!")
	assert(false)
}


GetMemberTypeDecompose : StructureMemberVariable ref memvar -> integer rtype = memvar.Type [nogc]

GetMemberTypeDecompose : StructureMemberFunctionRef ref member -> integer rtype = FindOrCreateFunctionSignatureType(member.Signature) [nogc]


GetMemberName : StructureMemberVariable ref memvar -> integer name = memvar.Name [nogc]

GetMemberName : StructureMemberFunctionRef ref member -> integer name = member.Name [nogc]


GetMemberOffset : list<StructureMember> ref members, integer membername -> integer offset = 0 [nogc]
{
	integer counter = 0
	GetMemberOffset(members, membername, counter)
	offset = counter
}

GetMemberOffset : list<StructureMember> ref members, integer membername, integer ref counter [nogc]
{
	if(GetMemberName(members.value) != membername)
	{
		if(GetMemberName(members.value) != 0)
		{
			counter += GetMemberSize(members.value)
		}
		GetMemberOffset(members.next, membername, counter)
	}
}

GetMemberOffset : nothing, integer membername, integer ref counter [nogc]

GetMemberSize : StructureMemberVariable ref memvar -> integer r = GetTypeSize(memvar.Type) [nogc]

GetMemberSize : StructureMemberFunctionRef ref member -> 4 [nogc]



GetStructureMemberOffset : list<StructureDefinition> ref structures, integer structurename, integer membername -> integer offset = 0 [nogc]
{
	if(structures.value.Name == structurename)
	{
		offset = GetMemberOffset(structures.value.Members, membername)
	}
	else
	{
		offset = GetStructureMemberOffset(structures.next, structurename, membername)
	}
}

GetStructureMemberOffset : nothing, integer structurename, integer membername -> 0 [nogc]



CodeGenEmitSumTypes : list<SumType> ref sumtypes
{
	if((sumtypes.value.Type != 0) && (!sumtypes.value.IsTemplate))
	{
		OnBytecodeEmitByte(0x1f)			// SumTypeDef instruction
		OnBytecodeEmitInteger(sumtypes.value.Type)
		OnBytecodeEmitInteger(CountSumTypeBases(sumtypes.value.Bases))
		CodeGenEmitSumTypeBase(sumtypes.value.Bases)
	}

	CodeGenEmitSumTypes(sumtypes.next)
}

CodeGenEmitSumTypes : nothing

CountSumTypeBases : list<SumTypeBase> ref bases -> integer count = 0 [nogc]
{
	count = CountSumTypeBases(bases.next)

	if(bases.value.Name != 0)
	{
		++count
	}
}

CountSumTypeBases : nothing -> integer count = 0 [nogc]

CodeGenEmitSumTypeBase : list<SumTypeBase> ref bases [nogc]
{
	CodeGenEmitSumTypeBase(bases.next)

	if(bases.value.Name != 0)
	{
		OnBytecodeEmitInteger(bases.value.Name)
	}
}

CodeGenEmitSumTypeBase : nothing [nogc]


SumTypeExists : integer typename -> boolean exists = SumTypeExists(SumTypes, typename) [nogc]

SumTypeExists : list<SumType> ref sumtypes, integer typename -> boolean exists = false [nogc]
{
	if(sumtypes.value.Name == typename)
	{
		exists = true
	}
	else
	{
		exists = SumTypeExists(sumtypes.next, typename)
	}
}

SumTypeExists : nothing, integer typename -> boolean exists = false [nogc]


FindSumTypeName : integer typeid -> integer name = FindSumTypeName(SumTypes, typeid) [nogc]

FindSumTypeName : list<SumType> ref sumtypes, integer typeid -> integer name = 0 [nogc]
{
	if(sumtypes.value.Type == typeid)
	{
		name = sumtypes.value.Name
	}
	else
	{
		name = FindSumTypeName(sumtypes.next, typeid)
	}
}

FindSumTypeName : nothing, integer typeid -> 0 [nogc]


SumTypeHasBase : list<SumType> ref sumtypes, integer sumtypeid, integer basetypeid -> boolean hasbase = false [nogc]
{
	if(basetypeid == 0)
	{
		return()
	}
	
	if(sumtypeid == 0)
	{
		return()
	}

	if(sumtypes.value.Type == sumtypeid)
	{
		hasbase = CheckBaseTypes(sumtypes.value.Bases, basetypeid)
	}
	else
	{
		hasbase = SumTypeHasBase(sumtypes.next, sumtypeid, basetypeid)
	}
}

SumTypeHasBase : nothing, integer sumtypeid, integer basetypeid -> false [nogc]


CheckBaseTypes : list<SumTypeBase> ref bases, integer basetypeid -> boolean hasbase = false [nogc]
{
	if(bases.value.Name == basetypeid)
	{
		hasbase = true
	}
	else
	{
		hasbase = CheckBaseTypes(bases.next, basetypeid)
	}
}

CheckBaseTypes : nothing, integer basetypeid -> false [nogc]




FunctionIsAutoGenOrHasIR : integer funcname -> boolean ret = false
{
	if(IsRecognizedBuiltIn(funcname))
	{
		return()
	}

	if(SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, funcname))
	{
		ret = true
	}
	elseif(FunctionIsAutoGen(AutoGeneratedFunctionNames, funcname))
	{
		ret = true
	}
	elseif(TypeMatcherExists(TypeMatchers, funcname))
	{
		ret = true
	}
	elseif(PatternMatcherExists(PendingPatternMatchers, funcname))
	{
		ret = true
	}
}

FunctionIsAutoGen : simplelist<integer> ref genlist, integer target -> boolean ret = false [nogc]
{
	if(genlist.value == target)
	{
		ret = true
	}
	else
	{
		ret = FunctionIsAutoGen(genlist.next, target)
	}
}

FunctionIsAutoGen : nothing, integer target -> boolean ret = false [nogc]



TypeMatcherExists : list<TypeMatcher> ref matchers, integer matchername -> boolean ret = false [nogc]
{
	if(matchers.value.Name == matchername)
	{
		ret = true
	}
	else
	{
		ret = TypeMatcherExists(matchers.next, matchername)
	}
}

TypeMatcherExists : nothing, integer matchername -> boolean ret = false [nogc]



FindVariable : integer name, integer ref frames -> integer index = 0
{
	FindVariableInSingleScope(EmittingScope.Wrapped, name, index)

	if(index < 0)
	{
		index = 0
		FindVariableInSingleScope(GlobalScope.Wrapped, name, index)
		frames = -1
	}
}


FindVariableInSingleScope : Scope ref scope, integer varname, integer ref index
{
	FindVariableInSingleScope(scope.Variables, varname, index)
}

FindVariableInSingleScope : list<Variable> ref vars, integer varname, integer ref index
{
	if(vars.value.Name != varname)
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindVariableInSingleScope(vars.next, varname, index)
	}
}

FindVariableInSingleScope : nothing, integer varname, integer ref index
{
	index = -1
}


FindReturnVariableIndex : -> integer index = 0
{
	FindReturnVariableInSingleScope(EmittingScope.Wrapped, index)
}

FindReturnVariableName: -> integer name = 0
{
	FindReturnVariableNameInSingleScope(EmittingScope.Wrapped, name)
}

FindReturnVariableInSingleScope : Scope ref scope, integer ref index
{
	FindReturnVariableInSingleScope(scope.Variables, index)
}

FindReturnVariableInSingleScope : list<Variable> ref vars, integer ref index
{
	if(vars.value.Origin != 2)		// VARIABLE_ORIGIN_RETURN
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindReturnVariableInSingleScope(vars.next, index)
	}
}

FindReturnVariableInSingleScope : nothing, integer ref index
{
	index = -1
}

FindReturnVariableNameInSingleScope : Scope ref scope, integer ref name
{
	FindReturnVariableNameInSingleScope(scope.Variables, name)
}

FindReturnVariableNameInSingleScope : list<Variable> ref vars, integer ref name
{
	if(vars.value.Origin == 2)		// VARIABLE_ORIGIN_RETURN
	{
		name = vars.value.Name
	}
	else
	{
		FindReturnVariableNameInSingleScope(vars.next, name)
	}
}

FindReturnVariableNameInSingleScope : nothing, integer ref name
{
	name = 0
}



FindVariableType : integer varname -> integer rettype = 0
{
	Variable var = 0, 0, 0, 0
	if(!FindVariableDataInSingleScope(EmittingScope.Wrapped, varname, var))
	{
		return()
	}
	rettype = var.VarType
}

FindVariableDataInSingleScope : Scope ref scope, integer varname, Variable ref outvar -> boolean found = false [nogc]
{
	found = FindVariableDataInSingleScope(scope.Variables, varname, outvar)
	if(!found)
	{		
		if(scope.Name != GlobalCodeBlockName)
		{
			found = FindVariableDataInSingleScope(GlobalScope.Wrapped, varname, outvar)
		}
	}
}

FindVariableDataInSingleScope : list<Variable> ref vars, integer varname, Variable ref outvar -> boolean found = false [nogc]
{
	listnode<Variable> node = vars
	while(HasVariableNode(node))
	{
		if(NodeHasName(node, varname))
		{
			StashVariableNode(node, outvar)
			found = true
			return()
		}
		
		node = NextVariableNode(node)
	}
}

FindVariableDataInSingleScope : nothing, integer varname, Variable ref outvar -> boolean found = false [nogc]


HasVariableNode : list<Variable> ref nodes -> true [nogc]
HasVariableNode : nothing -> false [nogc]

NodeHasName : list<Variable> ref nodes, integer varname -> boolean match = (nodes.value.Name == varname) [nogc]

StashVariableNode : list<Variable> ref nodes, Variable ref outvar [nogc]
{
	outvar = nodes.value
}

NextVariableNode : list<Variable> ref nodes -> listnode<Variable> ret = nodes.next [nogc]


CodeGenEmitTypeMatchers : list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{	
		OnBytecodeLexicalScope(matchers.value.Name, 0, 0)
		OnBytecodeEnterTypeResolver(matchers.value.Name)
		CodeGenEmitTypeMatcherOverloads(matchers.value.Overloads)
		OnBytecodeExitTypeResolver()
	}

	CodeGenEmitTypeMatchers(matchers.next)
}

CodeGenEmitTypeMatchers : nothing


OnCodeGenRegisterTypeMatchParam : integer matchername, integer overloadname, integer varname, integer vartype
{
	Parameter p = varname, vartype
	FindTypeMatcherAndAppendOverloadParameter(TypeMatchers, matchername, overloadname, p)
}

FindTypeMatcherAndAppendOverloadParameter : list<TypeMatcher> ref matchers, integer matchername, integer overloadname, Parameter ref p
{
	if(matchers.value.Name == matchername)
	{
		FindTMOverloadAndAppendParameter(matchers.value.Overloads, matchers.value.Overloads, overloadname, p)
	}
	else
	{
		FindTypeMatcherAndAppendOverloadParameter(matchers.next, matchername, overloadname, p)
	}
}

FindTypeMatcherAndAppendOverloadParameter : nothing, integer matchername, integer overloadname, Parameter ref p
{
	print("No type matcher available")
	assert(false)
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, list<FunctionSignature> ref signatures, integer overloadname, Parameter ref p
{
	if(signatures.value.Name == overloadname)
	{
		AppendParameter(signatures.value.Parameters, p)
	}
	else
	{
		FindTMOverloadAndAppendParameter(originallist, signatures.next, overloadname, p)
	}
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, nothing, integer overloadname, Parameter ref p
{
	list<Parameter> paramlist = p, nothing
	FunctionSignature sig = overloadname, paramlist, 0
	prepend<FunctionSignature>(originallist, sig)
}

AppendParameter : list<Parameter> ref params, Parameter ref p
{
	AppendParameterRecurse(params, params.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, list<Parameter> ref tail, Parameter ref p
{
	AppendParameterRecurse(tail, tail.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, nothing, Parameter ref p
{
	list<Parameter> newlist = p, nothing
	params.next = newlist
}


CodeGenEmitTypeMatcherOverloads : list<FunctionSignature> ref signatures
{
	CodeGenEmitTypeMatcherOverloads(signatures.next)

	if(signatures.value.Name != 0)
	{
		OnBytecodeEmitByte(0x20)				// TypeMatch instruction
		OnBytecodeEmitInteger(signatures.value.Name)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(CountParameters(signatures.value.Parameters))
		
		CodeGenEmitTypeMatcherParams(signatures.value.Parameters)
	}
}

CodeGenEmitTypeMatcherOverloads : nothing


CountParameters : list<Parameter> ref params -> integer count = 0 [nogc]
{
	count = CountParameters(params.next)

	if(params.value.Type != 0)
	{
		++count
	}
}

CountParameters : nothing -> integer count = 0 [nogc]


CodeGenEmitTypeMatcherParams : list<Parameter> ref params
{
	CodeGenEmitTypeMatcherParams(params.next)

	if(params.value.Name != 0)
	{
		integer refflag = 0
		if(IsReferenceType(params.value.Type))
		{
			refflag = 1
		}

		OnBytecodeEmitByte(refflag)
		OnBytecodeEmitInteger(MakeNonReferenceType(params.value.Type))
	}
}

CodeGenEmitTypeMatcherParams : nothing


FindFunctionAndSetInvokeTag : list<FunctionDefinition> ref functions, integer funcname, integer invoketarget [nogc]
{
	if(functions.value.Name == funcname)
	{
		functions.value.InvokeTag = invoketarget
	}
	else
	{
		FindFunctionAndSetInvokeTag(functions.next, funcname, invoketarget)
	}
}

FindFunctionAndSetInvokeTag : nothing, integer funcname, integer invoketarget [nogc]
{
	print("Cannot tag non-existent function")
	assert(false)
}

OnCodeGenRegisterFunctionTag : integer funcname, string tagname, integer rawfuncname
{
	list<string> dtp = "", nothing
	FunctionTag tag = funcname, tagname, dtp
	prepend<FunctionTag>(FunctionTags, tag)

	if(tagname == "constructor")
	{
		simpleprepend<integer>(CustomConstructors, funcname)
		
		integer baseconstructorname = PoolString(GetPooledString(GlobalStrings, rawfuncname) ; "@@constructor")
		
		Overload overload = baseconstructorname, funcname, nothing
		prepend<Overload>(Overloads, overload)
		prepend<Overload>(AutoGenOverloads, overload)
		
		FindFunctionAndAddOverload(overload)
		
		PrependFunctionParameter(Functions, funcname, PoolString("@id"), 0x81000000)		// reference to identifier type signature
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParam(FunctionTags.value.Parameters, FunctionTags.value.Parameters.next, param)
}

AppendFunctionTagParam : list<string> ref params, list<string> ref tail, string param
{
	AppendFunctionTagParam(tail, tail.next, param)
}

AppendFunctionTagParam : list<string> ref params, nothing, string param
{
	list<string> newlist = param, nothing
	params.next = newlist
}


CodeGenEmitFunctionTags : list<FunctionTag> ref tags
{
	if(tags.value.FunctionName != 0)
	{
		if(tags.value.TagName != "")
		{
			OnBytecodeEmitByte(0x1a)
			OnBytecodeEmitInteger(tags.value.FunctionName)
			OnBytecodeEmitInteger(CountTagParams(tags.value.Parameters))
			OnBytecodeEmitString(tags.value.TagName)

			CodeGenEmitFunctionTagParams(tags.value.Parameters)
		}
	}
	CodeGenEmitFunctionTags(tags.next)
}

CodeGenEmitFunctionTags : nothing



CodeGenEmitFunctionTagParams : list<string> ref params [nogc]
{
	if(params.value != "")
	{
		OnBytecodeEmitString(params.value)
	}

	CodeGenEmitFunctionTagParams(params.next)
}

CodeGenEmitFunctionTagParams : nothing [nogc]


CountTagParams : list<string> ref params -> integer count = 0 [nogc]
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0 [nogc]


CodeGenEmitConstructors : list<StructureDefinition> ref structures
{
	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		EmitCtorTag(structures.value.ConstructorName)
		EmitCtorTag(structures.value.AnonConstructorName)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCtorTag(structures.value.CopyConstructorName)
		}

		EmitConstructor(structures.value)
		EmitAnonConstructor(structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCopyConstructor(structures.value)
		}
	}

	CodeGenEmitConstructors(structures.next)
}

CodeGenEmitConstructors : nothing

EmitCtorTag : integer funcname
{
	OnBytecodeEmitByte(0x1a)
	OnBytecodeEmitInteger(funcname)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitString("@@autogen@constructor")
}


EmitConstructor : StructureDefinition ref def
{
	integer idhandle = PooledStringHandleForIdentifier

	OnBytecodeLexicalScope(def.ConstructorName, 0, def.MemberCount + 1)
	OnBytecodeLexicalScopeEntry(idhandle, 0x81000000, 1)
	EmitScopeEntriesForMembers(def.Members)

	OnBytecodeEnterFunction(def.ConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, idhandle)

	OnBytecodeExitFunction()
}

EmitAnonConstructor : StructureDefinition ref def
{
	integer membercount = def.MemberCount
	OnBytecodeLexicalScope(def.AnonConstructorName, 0, membercount + 1)
	EmitScopeEntriesForMembers(def.Members)
	OnBytecodeLexicalScopeEntry(def.AnonConstructorName, def.Type, 2)

	OnBytecodeEnterFunction(def.AnonConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, membercount)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, def.AnonConstructorName)

	OnBytecodeSetReturnRegister(membercount)
	OnBytecodeExitFunction()
}

EmitCopyConstructor : StructureDefinition ref def
{
	OnBytecodeLexicalScope(def.CopyConstructorName, 0, 2)
	OnBytecodeLexicalScopeEntry(PooledStringHandleForIdentifier, 0x81000000, 1)
	OnBytecodeLexicalScopeEntry(def.Name, def.Type, 1)

	OnBytecodeEnterFunction(def.CopyConstructorName)
	OnBytecodePushVarNoCopy(def.Name)
	OnBytecodeCopyStructure()
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()
	OnBytecodeExitFunction()
}


EmitScopeEntriesForMembers : list<StructureMember> ref members
{
	EmitScopeEntryForMember(members.value)
	EmitScopeEntriesForMembers(members.next)
}

EmitScopeEntriesForMembers : nothing


EmitScopeEntryForMember : StructureMemberVariable ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, memvar.Type, 1)
	}
}

EmitScopeEntryForMember : StructureMemberFunctionRef ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, GetMemberTypeDecompose(memvar), 1)
	}
}



EmitMemberDataCopies : list<StructureMember> ref members, integer idhandle
{
	EmitMemberDataCopy(members.value, idhandle)
	EmitMemberDataCopies(members.next, idhandle)
}

EmitMemberDataCopies : nothing, integer idhandle

EmitMemberDataCopy : StructureMemberVariable ref memvar, integer idhandle
{
	if(memvar.Name != 0)
	{
		OnBytecodePushVarValue(memvar.Name, memvar.Type)
		OnBytecodeCopyToStructure(idhandle, memvar.Name)
	}
}

EmitMemberDataCopy : StructureMemberFunctionRef ref member, integer idhandle
{
	if(member.Name != 0)
	{
		OnBytecodePushVarValue(member.Name, 0x09000000)
		OnBytecodeCopyToStructure(idhandle, member.Name)
	}
}


GetNameOfType : integer typeid -> integer name = 0
{
	typeid = MakeNonReferenceType(typeid)
	if(typeid == 0x01000001)
	{
		name = PooledStringHandleForInteger
	}
	elseif(typeid == 0x01000002)
	{
		name = PooledStringHandleForInteger16
	}
	elseif(typeid == 0x01000003)
	{
		name = PooledStringHandleForBoolean
	}
	elseif(typeid == 0x01000004)
	{
		name = PooledStringHandleForReal
	}
	elseif(typeid == 0x02000000)
	{
		name = PooledStringHandleForString
	}
	elseif(typeid == 0x02000001)
	{
		name = PooledStringHandleForBuffer
	}
	elseif(typeid == 0x00000004)
	{
		name = PooledStringHandleForNothing
	}
	elseif(typeid == 0x01000000)
	{
		name = PooledStringHandleForIdentifier
	}
	elseif(IsStructureType(typeid))
	{
		name = GetNameOfStructureByType(typeid)
	}
	elseif((typeid & 0xff000000) == 0x07000000)
	{
		name = FindSumTypeName(typeid)
	}
	elseif((typeid & 0x7f000000) == 0x09000000)
	{
		name = PoolString("{function} " ; cast(string, typeid))
	}
	else
	{
		print("Unknown type " ; cast(string, typeid))
		assert(false)
	}
}

GetTypeByName : integer name -> integer typeid = 0 [nogc]
{
	if(name == 0)
	{
		return()
	}

	integer unaliasedname = UnaliasType(TypeWeakAliases, name)
	while(unaliasedname != name)
	{
		name = unaliasedname
		unaliasedname = UnaliasType(TypeWeakAliases, name)
	}
	name = unaliasedname

	if(name == PooledStringHandleForIdentifier)
	{
		typeid = 0x01000000
	}
	elseif(name == PooledStringHandleForInteger)
	{
		typeid = 0x01000001
	}
	elseif(name == PooledStringHandleForInteger16)
	{
		typeid = 0x01000002
	}
	elseif(name == PooledStringHandleForBoolean)
	{
		typeid = 0x01000003
	}
	elseif(name == PooledStringHandleForReal)
	{
		typeid = 0x01000004
	}
	elseif(name == PooledStringHandleForString)
	{
		typeid = 0x02000000
	}
	elseif(name == PooledStringHandleForNothing)
	{
		typeid = 0x00000004
	}
	elseif(name == PooledStringHandleForBuffer)
	{
		typeid = 0x02000001
	}
	else
	{
		integer structuretype = GetStructureTypeByName(name)
		if(structuretype != 0)
		{
			typeid = structuretype
			return()
		}
		
		integer sumtype = FindSumTypeByName(SumTypes, name)
		if(sumtype != 0)
		{			
			typeid = sumtype
			return()
		}
		
		integer strongaliastype = FindTypeAliasByName(TypeAliases, name)
		if(strongaliastype != 0)
		{
			typeid = strongaliastype
			return()
		}
	}
}


FindSumTypeByName : list<SumType> ref sumtypes, integer name -> integer typeid = 0 [nogc]
{
	if((sumtypes.value.Type != 0) && (sumtypes.value.Name == name))
	{
		typeid = sumtypes.value.Type
		return()
	}
	
	typeid = FindSumTypeByName(sumtypes.next, name)
}

FindSumTypeByName : nothing, integer name -> 0 [nogc]


UnaliasType : list<TypeAlias> ref aliases, integer namehandle -> integer unaliasedname = 0 [nogc]
{
	if(aliases.value.AliasNameHandle == namehandle)
	{
		unaliasedname = aliases.value.BaseNameHandle
	}
	else
	{
		unaliasedname = UnaliasType(aliases.next, namehandle)
	}
}

UnaliasType : nothing, integer namehandle -> integer unaliasedname = namehandle [nogc]



GetStructureTypeByName : integer name -> integer typeid = 0 [nogc]
{
	ContextWrapper<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, name, wrap)

	if(found)
	{
		typeid = UnwrapStructureType(wrap.Wrapped)
	}
}

UnwrapStructureType : StructureDefinition ref struct -> integer ty = struct.Type



// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	simplelist<integer> processed = 0, nothing
	boolean changed = CodeGenRearrangeStructuresRecurse(thelist, processed)

	if(changed)
	{
		CodeGenRearrangeStructures(thelist)
	}
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref thelist, simplelist<integer> ref processed -> boolean changed = false
{
	if((thelist.value.Name != 0) && (!thelist.value.IsTemplate))
	{
		simplelist<integer> dependencies = 0, nothing
		ParseStructDependencies(thelist.value.Members, dependencies)

		if(MissingDependency(dependencies, processed))
		{
			SwapDown(thelist, thelist.next)
			changed = true
		}

		simpleprepend<integer>(processed, thelist.value.Type)
	}

	if(!changed)
	{
		CodeGenRearrangeStructuresRecurse(thelist.next, processed)
	}
}

CodeGenRearrangeStructuresRecurse : nothing, simplelist<integer> ref processed -> false


SwapDown : list<StructureDefinition> ref thelist, list<StructureDefinition> ref tail
{
	StructureDefinition temp = tail.value
	tail.value = thelist.value
	thelist.value = temp
}

SwapDown : list<StructureDefinition> ref thelist, nothing



ParseStructDependencies : list<StructureMember> ref members, simplelist<integer> ref out
{
	integer dependency = GetMemberDependency(members.value)
	if(dependency != 0)
	{
		simpleprepend<integer>(out, dependency)
	}

	ParseStructDependencies(members.next, out)
}

ParseStructDependencies : nothing, simplelist<integer> ref out


GetMemberDependency : StructureMemberVariable ref var -> integer dep = 0
{
	if(var.Name != 0)
	{
		if(IsStructureType(var.Type))
		{
			dep = var.Type
		}
	}
}

GetMemberDependency : StructureMemberFunctionRef ref member -> 0


MissingDependency : simplelist<integer> ref dependencies, simplelist<integer> ref processed -> boolean missing = true
{
	// TODO - clean up this horrible code
	if(dependencies.value != 0)
	{
		if(listcontains(processed, dependencies.value))
		{
			missing = false
		}
		else
		{
			missing = MissingDependency(dependencies.next, processed)
		}
	}
	else
	{
		missing = MissingDependency(dependencies.next, processed)
	}
}

MissingDependency : nothing, simplelist<integer> ref processed -> boolean missing = false			// TODO - is this really correct?!


OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityStack.value.Param = ScratchExpressions.value

	OptionalCodeBlock block = nothing
	prepend<OptionalCodeBlock>(CurrentCodeBlockStack, block)
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


AppendEntityToChain : list<EntityChain> ref chainstack, Entity ref e
{
	AppendEntityToChainUnwrap(chainstack.value.Entries, e)
}

AppendEntityToChainUnwrap : EntityList ref entitylist, Entity ref e
{
	AppendEntityToChainWorker(entitylist.ActualList, entitylist.ActualList.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, list<Entity> ref tail, Entity ref e
{
	AppendEntityToChainWorker(tail, tail.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, nothing, Entity ref e
{
	list<Entity> newtail = e, nothing
	chain.next = newtail
}


FindTypeAliasBase : list<TypeAlias> ref aliases, integer aliastype -> integer basetype = 0 [nogc]
{
	if(aliases.value.TypeID == aliastype)
	{
		basetype = GetTypeByName(aliases.value.BaseNameHandle)
	}
	else
	{
		basetype = FindTypeAliasBase(aliases.next, aliastype)
	}
}

FindTypeAliasBase : nothing, integer aliastype -> integer basetype = 0 [nogc]


FindTypeAliasByName : list<TypeAlias> ref aliases, integer aliasname -> integer aliastype = 0 [nogc]
{
	if(aliases.value.AliasNameHandle == aliasname)
	{
		aliastype = aliases.value.TypeID
	}
	else
	{
		aliastype = FindTypeAliasByName(aliases.next, aliasname)
	}
}

FindTypeAliasByName : nothing, integer aliasname -> 0 [nogc]


OnCodeGenRegisterAlias : integer aliastype, integer aliasname, integer base
{
	TypeAlias newalias = aliastype, aliasname, base
	prepend<TypeAlias>(TypeAliases, newalias)
}

OnCodeGenRegisterWeakAlias : integer aliastype, integer aliasname, integer basename
{
	TypeAlias newalias = aliastype, aliasname, basename
	prepend<TypeAlias>(TypeWeakAliases, newalias)
}


OnCodeGenRegisterFunctionSig : integer sigtype, integer rettypename
{
	list<Parameter> d = dummyparam, nothing
	FunctionSignature sig = sigtype, d, rettypename
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype
{
	Parameter param = 1, paramtype
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigParamList : simplelist<integer> ref paramtypenames
{
	OnCodeGenRegisterFunctionSigParamList(paramtypenames.next)
	
	if(paramtypenames.value != 0)
	{
		integer paramtype = GetTypeByName(paramtypenames.value)
		if(paramtype == 0)
		{
			paramtype = paramtypenames.value
		}
		
		OnCodeGenRegisterFunctionSigParam(paramtype)		// TODO - defer higher order function parameter type resolution until type inference
	}
}

OnCodeGenRegisterFunctionSigParamList : nothing


CodeGenEmitFunctionSignatures : list<FunctionSignature> ref thelist
{
	if(thelist.value.Name != 0)
	{
		integer rettype = GetTypeByName(thelist.value.ReturnTypeName)
		if(rettype == 0)
		{
			rettype = 0x00000002		// void
		}
		
		OnBytecodeEmitFunctionSignature(thelist.value.Name, rettype, CountParameters(thelist.value.Parameters))
		CodeGenEmitFunctionSigParams(thelist.value.Parameters)
	}
	CodeGenEmitFunctionSignatures(thelist.next)
}

CodeGenEmitFunctionSignatures : nothing


CodeGenEmitFunctionSigParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		OnBytecodeEmitFunctionSigParam(params.value.Type)
	}
	CodeGenEmitFunctionSigParams(params.next)
}

CodeGenEmitFunctionSigParams : nothing


OnCodeGenRegisterParenthetical : 
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, d)
}


OnCodeGenPreparePreOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist, 0

	PreOpOnDeck = preop
}

OnCodeGenPreparePreOpCompoundOperand : integer operand
{
	AppendCompoundMemberHelper(PreOpOnDeck, operand)
}

OnCodeGenCompletePreOpStatement : boolean substatement
{
	if(substatement)
	{
		ExpressionOrPrePostOp wrap = PreOpOnDeck
		ParentheticalExpression parenthetical = wrap
		ExpressionAtom atom = parenthetical
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		CodeBlockEntry cbe = PreOpOnDeck
		AppendEntryToCurrentCodeBlock(cbe)
	}
}

OnCodeGenAddPreOpCompoundOperand : integer operand
{
	FindLastPreOpAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, operand)
}

FindLastPreOpAndAppendCompoundMemberHelper : CodeBlock ref codeblock, integer operand
{
	FindLastPreOpAndAppendCompoundMember(codeblock.Entries, codeblock.Entries.next, operand)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastPreOpAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist, 0
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}


GetLargestSumTypeBaseSize : integer typeid -> integer size = FindSumTypeAndGetBaseMaxSize(SumTypes, typeid) [nogc]

FindSumTypeAndGetBaseMaxSize : list<SumType> ref sumtypes, integer typeid -> integer size = 0 [nogc]
{
	if(sumtypes.value.Type == typeid)
	{
		GetBaseMaxSize(sumtypes.value.Bases, size)
	}
	else
	{
		size = FindSumTypeAndGetBaseMaxSize(sumtypes.next, typeid)
	}
}

FindSumTypeAndGetBaseMaxSize : nothing, integer typeid -> 0 [nogc]


GetBaseMaxSize : list<SumTypeBase> ref basetypes, integer ref outsize [nogc]
{
	integer typename = basetypes.value.Name
	if(typename != 0)
	{
		integer thissize = GetTypeSize(typename)
		if(thissize > outsize)
		{
			outsize = thissize
		}
	}

	GetBaseMaxSize(basetypes.next, outsize)
}

GetBaseMaxSize : nothing, integer ref outsize [nogc]


OnCodeGenShiftParameter :
{
	if(InFuncRetHack)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}
	elseif(PeekContext(ContextStack, 1) != STACK_TYPE_SUBSTATEMENT)
	{
		FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
	}
	else
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

PeekContext : list<ContextStackEntry> ref stack, integer depth -> integer peek = STACK_TYPE_GLOBAL
{
	if(depth == 0)
	{
		peek = stack.value.EntryType
	}
	else
	{
		peek = PeekContext(stack.next, depth - 1)
	}
}


CodeGenEmitGlobalBlockPrologue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		EmittingScope.Wrapped = GlobalScope.Wrapped
	
		OnBytecodeEnterEntity(4, GlobalCodeBlockName)
		CodeGenEmitCodeBlock(block)
		OnBytecodeInvokeOffset(FindHandleInTrie(GlobalStringTrie, "entrypoint"))
		OnBytecodeHalt()
	}
}

CodeGenEmitGlobalBlockEpilogue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeExitEntity()
	}
}


IsStructureType : integer typeid -> boolean ret = false [nogc]
{
	if((typeid & 0x7f000000) == 0x03000000)
	{
		ret = true
	}
	elseif((typeid & 0x7f000000) == 0x08000000)
	{
		ret = true
	}
}

IsReferenceType : integer typeid -> boolean ret = false [nogc]
{
	if((typeid & 0x80000000) != 0)
	{
		ret = true
	}
}

MakeReferenceType : integer typeid -> integer reftypeid = typeid [nogc]
{
	if(!IsReferenceType(typeid))
	{
		reftypeid = typeid + 0x80000000
	}
}

MakeNonReferenceType : integer typeid -> (typeid & 0x7fffffff) [nogc]


append_recurse : list<Variable> ref thelist, nothing, Variable ref value [nogc]
{
	list<Variable> newlist = value, nothing
	thelist.next = newlist
}

append_recurse : list<Variable> ref thelist, list<Variable> ref tail, Variable ref value [nogc]
{
	append_recurse(tail, tail.next, value)
}


append : list<Variable> ref thelist, Variable ref value [nogc]
{
	append_recurse(thelist, thelist.next, value)
}



CodeBlockDepth : list<OptionalCodeBlock> ref stack -> integer count = 0 [nogc]
{
	count = CodeBlockDepth(stack.next) + 1
}

CodeBlockDepth : nothing -> 0 [nogc]



IRProcess : -> boolean success = true
{
	prepend<StructureDefinition>(Structures, dummystruct)		// TODO - why does this need to be here?
	
	if(!IRTypeInference())
	{
		success = false
		return()
	}
}


GeneratePendingTypeMatchers : list<PendingTypeMatcher> ref pendingmatchers -> boolean success = true
{
	if(!GeneratePendingTypeMatcher(pendingmatchers.value))
	{
		success = false
	}
	
	if(!GeneratePendingTypeMatchers(pendingmatchers.next))
	{
		success = false
	}
}

GeneratePendingTypeMatchers : nothing -> true

GeneratePendingTypeMatcher : PendingTypeMatcher ref matcher -> boolean success = true
{
	if(matcher.OverloadName == 0)
	{
		return()
	}

	if(!TypeMatcherExists(TypeMatchers, matcher.MatcherName))
	{
		OnCodeGenEnterTypeMatcher(matcher.MatcherName)
		OnCodeGenExitContext()
	}
	
	EnsureTypeMatcherIsConfigured(matcher.OverloadName, matcher.MatcherName)
}

EnsureTypeMatcherIsConfigured : integer overloadname, integer matchername
{
	ContextWrapper<FunctionDefinition> wrap = nothing
	SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, overloadname, wrap)

	WalkParametersForTypeMatcherContext(wrap.Wrapped, matchername)
}

WalkParametersForTypeMatcherContext : FunctionDefinition ref func, integer matchername
{
	WalkParametersForTypeMatcher(func.Params, matchername, func.Name)
}


WalkParametersForTypeMatcher : FunctionParams ref params, integer matchername, integer overloadname
{
	WalkParametersForTypeMatcherUnwrapped(params.Params, matchername, overloadname)
}


WalkParametersForTypeMatcherUnwrapped : list<UnresolvedParameter> ref params, integer matchername, integer overloadname
{
	if(params.value.NameHandle != 0)
	{
		OnCodeGenRegisterTypeMatchParam(matchername, overloadname, params.value.NameHandle, params.value.ResolvedType)
	}
	
	WalkParametersForTypeMatcherUnwrapped(params.next, matchername, overloadname)
}

WalkParametersForTypeMatcherUnwrapped : nothing, integer matchername, integer overloadname



DumpTypeList : simplelist<integer> ref types
{
	if(types.value != 0)
	{
		string refflag = ""
		if(IsReferenceType(types.value))
		{
			refflag = " ref"
		}
		
		print(" Potential type: " ; GetPooledString(GlobalStrings, GetNameOfType(types.value)) ; refflag)
	}
	
	DumpTypeList(types.next)
}

DumpTypeList : nothing


structure InferenceContext :
	integer ScopeName,
	integer StatementName,
	simplelist<integer> ref ExpectedTypes,
	boolean FunctionReturn,
	integer NumParameters,
	boolean TopLevelStatement,
	boolean Parenthetical,
	ContextWrapper<Scope> ScopeRef,
	ContextWrapper<FunctionDefinition> FuncRef

structure TypePossibilityList :
	simplelist<integer> ref Types,
	boolean Consumed

structure InferencePossibility :
	integer FunctionName,
	list<TypePossibilityList> ref ParameterTypes,
	TypePossibilityList ref ReturnType

structure ExpressionInferenceStackEntry :
	list<InferencePossibility> ref PossibilityList


IRTypeInference : -> boolean success = true
{
	if(!TypeInference(SumTypes, DummyContextForFunctions))
	{
		success = false
	}
	
	if(!TypeInference(Structures, DummyContextForFunctions))
	{
		success = false
	}

	if(GlobalCodeBlockName != 0)
	{
		ContextWrapper<FunctionDefinition> funcwrap = nothing
		InferenceContext globalcontext = GlobalCodeBlockName, 0, globalemptyintlist, false, 0, false, false, GlobalScope, funcwrap
		if(!TypeInference(GlobalCodeBlock, globalcontext))
		{
			success = false
		}
	}

	if(!TypeInference(Functions, DummyContextForFunctions))
	{
		success = false
	}
}

TypeInference : nothing, InferenceContext ref context -> true


TypeInference : list<SumType> ref sumtypes, InferenceContext ref context -> boolean success = true
{
	if(sumtypes.value.Type != 0)
	{
		if(!sumtypes.value.IsTemplate)
		{
			if(!ResolveSumTypeBases(sumtypes.value.Bases))
			{
				success = false
			}
		}
	}
	
	if(!TypeInference(sumtypes.next, context))
	{
		success = false
	}
}

ResolveSumTypeBases : list<SumTypeBase> ref bases -> boolean success = true
{
	if(bases.value.Name != 0)
	{
		integer resolvedtype = ResolveSingleBase(bases.value, bases.value.TemplateArgs)
			
		if(resolvedtype == 0)
		{
			print("Sum type has unknown base type")
			success = false
		}
		
		bases.value.Name = resolvedtype
	}
	
	if(!ResolveSumTypeBases(bases.next))
	{
		success = false
	}
}

ResolveSumTypeBases : nothing -> true

ResolveSingleBase : SumTypeBase ref base, nothing -> integer ret = GetTypeByName(base.Name)
ResolveSingleBase : SumTypeBase ref base, TemplateArgumentList ref args -> integer ret = GetTypeByName(InstantiateStructureTemplate(base.Name, args))


TypeInference : list<StructureDefinition> ref structures, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(structures.value, context))
	{
		success = false
	}
	
	if(!TypeInference(structures.next, context))
	{
		success = false
	}
}

TypeInference : StructureDefinition ref structuredef, InferenceContext ref context -> boolean success = true
{
	if(structuredef.Name == 0)
	{
		return()
	}
	
	if(structuredef.IsTemplate)
	{
		return()
	}

	if(!TypeInference(structuredef.Members, context))
	{
		success = false
	}
	
	integer ctorname = PoolStringFast(structuredef.ReadableName ; "@@constructor")
	integer anonname = PoolStringFast(structuredef.ReadableName ; "@@anonconstructor")
	integer copyname = PoolStringFast(structuredef.ReadableName ; "@@copyconstructor")
	OnCodeGenRegisterConstructors(structuredef.Name, ctorname, anonname, copyname)
	
	Overload selfoverload = structuredef.Name, ctorname, nothing
	prepend<Overload>(AutoGenOverloads, selfoverload)
	
	Overload anonoverload = ctorname, anonname, nothing
	prepend<Overload>(AutoGenOverloads, anonoverload)
	
	Overload copyoverload = ctorname, copyname, nothing
	prepend<Overload>(AutoGenOverloads, copyoverload)
}


TypeInference : list<StructureMember> ref members, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(members.value, context))
	{
		success = false
	}
	
	if(!TypeInference(members.next, context))
	{
		success = false
	}
}

TypeInference : StructureMemberVariable ref memvar, InferenceContext ref context -> boolean success = true
{
	if(memvar.Name == 0)
	{
		return()
	}

	integer pretype = memvar.Type
	memvar.Type = GetTypeByName(InstantiateStructureTemplate(memvar.TypeNameHandle, memvar.TemplateArgs))
	if(memvar.Type == 0)
	{
		memvar.Type = GetTypeByName(memvar.TypeNameHandle)
	}
	
	if(memvar.Type == 0)
	{
		print("Type not recognized: " ; GetPooledString(GlobalStrings, memvar.TypeNameHandle))
		success = false
	}
	else
	{
		memvar.Type = memvar.Type + pretype			// Hack to accept reference marker
	}
}

TypeInference : StructureMemberFunctionRef ref memfunc, InferenceContext ref context -> boolean success = true
{
	ResolveSignatureTypes(memfunc.Signature)
}


TypeInference : list<FunctionDefinition> ref functions, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(functions.value, context))
	{
		success = false
	}

	if(!TypeInference(functions.next, context))
	{
		success = false
	}
}


SetScopeForContext : list<Scope> ref scopes, InferenceContext ref context
{
	if(scopes.value.Name == context.ScopeName)
	{
		context.ScopeRef.Wrapped = scopes.value
	}
	else
	{
		SetScopeForContext(scopes.next, context)
	}
}


TypeInference : FunctionDefinition ref func, InferenceContext ref context -> boolean success = true
{
	if(func.IsTemplate)
	{
		return()
	}

	if(func.InferenceDone)
	{
		return()
	}
	
	func.InferenceDone = true

	ContextWrapper<Scope> scopewrap = func.AttachedScope.Wrapped
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext innercontext = func.Name, 0, globalemptyintlist, false, 0, false, false, scopewrap, funcwrap
	
	
	if(!TypeInference(func.Params, innercontext))
	{
		print("Parameters to function failed type inference")
		success = false
	}
	

	simplelist<integer> tempret = 0, nothing
	InferenceContext retcontext = func.Name, 0, tempret, true, 0, false, false, innercontext.ScopeRef, funcwrap

	if(!TypeInference(func.Return, retcontext))
	{
		print("Function return expression failed type inference")
		success = false
	}
	
	integer rettype = GetOptionalExpressionType(func.Return)
	if((rettype != 0) && (rettype != 0x00000002))	// void magic
	{
		if(func.AnonymousReturn)
		{
			StoreVariableInSingleScope(innercontext.ScopeRef.Wrapped, PooledStringHandleForAnonymousRet, rettype, false, 2)
		}
	}
	
	if(!TypeInference(func.Code, innercontext))
	{
		print(GetPooledString(GlobalStrings, func.Name) ; "() - Function code body failed type inference")
		success = false
	}
}

TypeInference : FunctionParams ref params, InferenceContext ref context -> boolean success = TypeInference(params.Params, context)

TypeInference : list<UnresolvedParameter> ref params, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(params.value, context))
	{
		success = false
	}
	
	if(!TypeInference(params.next, context))
	{
		success = false
	}
}

TypeInference : UnresolvedParameter ref param, InferenceContext ref context -> boolean success = true
{
	if((param.ResolvedType & 0x7f000000) == 0x09000000)
	{
		StoreVariableInSingleScope(context.ScopeRef.Wrapped, param.NameHandle, param.ResolvedType, false, 1)
		return()
	}
	
	integer patternmatchtype = GetOptionalExpressionType(param.PatternMatchValue)
	if(patternmatchtype != 0)
	{
		param.ResolvedType = patternmatchtype
		return()
	}
	
	param.TypeNameHandle = MangleTemplateNameByHandle(param.TypeNameHandle, param.TemplateArgs)

	param.ResolvedType = GetTypeByName(param.TypeNameHandle)
	if(param.ResolvedType == 0)
	{
		print("Unknown parameter type: " ; GetPooledString(GlobalStrings, param.TypeNameHandle))
		success = false
	}
	else
	{
		if(param.HasRefTag)
		{
			param.ResolvedType = param.ResolvedType + 0x80000000
		}

		StoreVariableInSingleScope(context.ScopeRef.Wrapped, param.NameHandle, param.ResolvedType, false, 1)
	}
}

TypeInference : CodeBlock ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.Entries, context))
	{
		success = false
	}
}

TypeInference : list<CodeBlockEntry> ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.value, context))
	{
		success = false
	}

	if(!TypeInference(code.next, context))
	{
		success = false
	}
}


TypeInference : PreOpStatement ref statement, InferenceContext ref context -> boolean success = true
{	
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Operand.value, var)
	
	if(var.Name == 0)
	{
		print("Cannot operate on variable, it doesn't exist!")
		assert(false)
	}
	
	integer operandtype = MakeNonReferenceType(var.VarType)

	if(countnonzero(statement.Operand) > 1)
	{
		assertmsg(operandtype != 0, "Pre-operation statement has no type")
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}
	
	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype		// TODO - maybe don't assume that the operator returns the same type as it takes?
}


TypeInference : PostOpStatement ref statement, InferenceContext ref context -> boolean success = true
{	
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Operand.value, var)
	
	if(var.Name == 0)
	{
		print("Cannot operate on variable, it doesn't exist!")
		assert(false)
	}
	
	integer operandtype = MakeNonReferenceType(var.VarType)
	
	if(countnonzero(statement.Operand) > 1)
	{
		assertmsg(operandtype != 0, "Post-operation statement has no type")
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}
	
	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype
}


TypeInference : Statement ref statement, InferenceContext ref context -> boolean success = true
{
	if(statement.InferenceDone)
	{
		return()
	}
	
	statement.InferenceDone = true

	integer originalname = statement.Name
	statement.Name = InstantiateFunctionTemplate(statement.Name, statement.TemplateArgs)

	integer paramcount = CountExpressions(statement.Parameters)

	integer vartype = GetTypeByName(statement.Name)
	if(vartype != 0)
	{
		integer origin = 0
		if(context.FunctionReturn)
		{
			origin = 2
			SetFunctionReturnType(context.FuncRef.Wrapped, context.ScopeName, vartype)
		}
		
		while((vartype & 0x7f000000) == 0x05000000)
		{
			vartype = FindTypeAliasBase(TypeAliases, vartype)
		}
		
		if(IsStructureType(vartype))
		{
			statement.Name = GetConstructorName(Structures, vartype)
		}
		else
		{
			assertmsg(vartype != 0, "Assumption failure in statement type inference")
			statement.Name = GetNameOfType(vartype)
		}
		
		if(statement.TopLevel)
		{
			ConstructVariableFromStatement(statement, context.ScopeRef.Wrapped, vartype, origin)
		}
	}

	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Name, var)

	if((var.Name != 0) && ((var.VarType & 0x7f000000) == 0x09000000))
	{
		// TODO - type checking on higher order functions
		
		statement.Type = GetSignatureReturnType(FunctionSignatures, var.VarType)
	}
	else
	{
		InferenceContext newcontext = context.ScopeName, statement.Name, context.ExpectedTypes, false, paramcount, statement.TopLevel, false, context.ScopeRef, context.FuncRef

		if(!TypeInference(statement.Parameters, newcontext))
		{
			success = false
			print("Type inference failed for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
		}

		
		ContextWrapper<FunctionDefinition> contextfunc = nothing
		ContextWrapper<PendingTypeMatcher> contextmatch = nothing
		boolean isuserfunc = false

		
		if(statement.Name == PooledStringHandleForCast)
		{
			statement.Name = GetCastOverload(statement.Parameters)
			
			if(statement.Name == 0)
			{
				success = false
				print("Invalid cast()")
			}
		}
		else
		{
			if(IsRecognizedBuiltIn(statement.Name))
			{
				isuserfunc = false
			}
			else
			{
				isuserfunc = FetchFunctionForContext(contextfunc, statement.Name)
			}
		
			simplelist<integer> paramtypes = 0, nothing
			AccumulateParameterTypes(paramtypes, statement.Parameters)

			integer overloadname = 0
			
			if(isuserfunc)
			{
				overloadname = FindOverloadWithParameterTypesFast(contextfunc.Wrapped, statement.Name, paramtypes)
			}
			else
			{
				overloadname = FindOverloadWithParameterTypes(AutoGenOverloads, statement.Name, paramtypes)
			}
			
			if(overloadname != 0)
			{
				statement.Name = overloadname

				if(IsRecognizedBuiltIn(statement.Name))
				{
					isuserfunc = false
				}
				else
				{
					isuserfunc = FetchFunctionForContext(contextfunc, statement.Name)
				}
			}
			else
			{
				success = false
				print("No matching overload for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
			}
		}
				
		if(context.FunctionReturn)
		{
			statement.Type = vartype
		}
		else
		{
			if(isuserfunc)
			{
				statement.Type = InferFunctionReturnType(contextfunc.Wrapped)
			}
			else
			{
				statement.Type = GetPendingTypeMatcherReturnType(statement.Name, contextmatch)
			}
		}
		
		if(isuserfunc)
		{
			WalkFunctionParamsAndSetReferencesShim(contextfunc.Wrapped, statement.Parameters)
		}
		else
		{
			MakeParametersReferencesForTypeMatcher(statement.Name, statement.Parameters)
		}

		if(vartype != 0)
		{
			if(isuserfunc)
			{
				AnnotateTypeMatchedParamsForWrapper(contextfunc.Wrapped, statement.Parameters)
			}
			else
			{
				FindConstructorAndAnnotateTypeMatchedParams(Structures, statement.Name, statement.Parameters)
			}
		}
		elseif(ContextHasTypeMatcher(contextmatch.Wrapped))
		{
			AnnotateAllParameters(statement.Parameters, originalname, 0, paramcount, statement.TopLevel)
		}
	}
}


ContextHasTypeMatcher : PendingTypeMatcher ref matcher -> true [nogc]
ContextHasTypeMatcher : nothing -> false [nogc]


FindOverloadWithParameterTypesFast : FunctionDefinition ref func, integer rawname, simplelist<integer> ref paramtypes -> integer overloadname = rawname
{
	overloadname = FindOverloadWithParameterTypes(func.Overloads, rawname, paramtypes)
}


AnnotateTypeMatchedParamsForWrapper : FunctionDefinition ref func, OptionalExpressionList ref exprs
{
	AnnotateTypeMatchedParamsForWrapperUnwrap(func, exprs)
}

AnnotateTypeMatchedParamsForWrapperUnwrap : FunctionDefinition ref func, ExpressionList ref exprs
{
	AnnotateTypeMatchedParams(func.Params, exprs.Expressions)
}

AnnotateTypeMatchedParamsForWrapperUnwrap : FunctionDefinition ref func, nothing


CountExpressions : nothing -> 0 [nogc]

CountExpressions : ExpressionList ref exprs -> integer count = CountExpressions(exprs.Expressions) [nogc]

CountExpressions : list<Expression> ref exprs -> integer count = 1 [nogc]
{
	count += CountExpressions(exprs.next)
}


DumpAllOverloadParameters : list<Overload> ref overloads, integer rawname
{
	if(overloads.value.NormalName == rawname)
	{
		DumpFunctionParameters(Functions, overloads.value.MangledName)
	}

	DumpAllOverloadParameters(overloads.next, rawname)
}

DumpAllOverloadParameters : nothing, integer rawname


DumpFunctionParameters : list<FunctionDefinition> ref functions, integer funcname
{
	if(functions.value.Name == funcname)
	{
		print(GetPooledString(GlobalStrings, funcname))
		DumpUnresolvedParameters(functions.value.Params)
	}
	else
	{
		DumpFunctionParameters(functions.next, funcname)
	}
}

DumpFunctionParameters : nothing, integer funcname



FetchFunctionForContext : ContextWrapper<FunctionDefinition> ref wrap, integer funcname -> boolean found = false
{
	found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, funcname, wrap)
}


AnnotateAllParameters : ExpressionList ref exprs, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	AnnotateAllParameters(exprs.Expressions, statementname, paramindex, paramcount, toplevel)
}

AnnotateAllParameters : list<Expression> ref params, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	elseif(IsRefBind(params.value.Atoms.value))
	{
		TypeAnnotationAtom atom = 5
		ExpressionAtom wrap = atom
		AppendAtomToExpression(params.value.Atoms, params.value.Atoms.next, wrap)
	}
	
	AnnotateAllParameters(params.next, statementname, paramindex + 1, paramcount, toplevel)
}

AnnotateAllParameters : nothing, integer statementname, integer paramindex, integer paramcount, boolean toplevel


AnyTypeIsReferenceType : simplelist<integer> ref types -> boolean isref = false [nogc]
{
	if(IsReferenceType(types.value))
	{
		isref = true
	}
	else
	{
		isref = AnyTypeIsReferenceType(types.next)
	}
}

AnyTypeIsReferenceType : nothing -> false [nogc]


AnnotateNonReferenceParameters : ExpressionList ref exprs [nogc]
{
	AnnotateNonReferenceParameters(exprs.Expressions)
}

AnnotateNonReferenceParameters : list<Expression> ref params [nogc]
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	AnnotateNonReferenceParameters(params.next)
}

AnnotateNonReferenceParameters : nothing [nogc]



AddTypeAnnotation : nothing [nogc]

AddTypeAnnotation : list<Expression> ref params [nogc]
{
	AddTypeAnnotation(params.value)
}

AddTypeAnnotation : Expression ref expr [nogc]
{
	integer typeid = expr.Type
	TypeAnnotationAtom atom = typeid
	ExpressionAtom wrap = atom
	AppendAtomToExpression(expr.Atoms, expr.Atoms.next, wrap)
}


ExpressionIsAnnotated : list<ExpressionAtom> ref atoms -> boolean ret = false
{
	if(IsTypeAnnotationAtom(atoms.value))
	{
		ret = true
	}
	else
	{
		ret = ExpressionIsAnnotated(atoms.next)
	}
}

ExpressionIsAnnotated : nothing -> false


AccumulateParameterTypes : simplelist<integer> ref types, OptionalExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrap(types, exprs)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, ExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.Expressions, types)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, nothing [nogc]

AccumulateParameterTypesUnwrapped : list<Expression> ref exprs, simplelist<integer> ref types [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.next, types)
	simpleprepend<integer>(types, exprs.value.Type)
}

AccumulateParameterTypesUnwrapped : nothing, simplelist<integer> ref types [nogc]


FindOverloadWithParameterTypes : list<Overload> ref overloads, integer rawname, simplelist<integer> ref types -> integer overloadname = rawname
{
	if(overloads.value.NormalName == rawname)
	{	
		if(!IsFunctionTemplate(overloads.value.Implementation))
		{
			if(FunctionWrapperMatchesParameterTypes(overloads.value.Implementation, overloads.value.MangledName, types))
			{
				integer matchername = CheckForNeededPatternMatcher(PendingPatternMatchers, rawname)
				if(matchername != 0)
				{
					overloadname = matchername
				}
				else
				{
					overloadname = overloads.value.MangledName
				}		
				return()
			}
			elseif(countnonzero(types) == GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName))
			{
				if(CheckForNeededTypeMatcher(types))
				{
					overloadname = FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName, overloads.value.Implementation)
					FindOverloadWithParameterTypes(overloads.next, rawname, types)
					return()
				}
			}
		}
	}

	overloadname = FindOverloadWithParameterTypes(overloads.next, rawname, types)
}

GetFunctionWrapperParameterCount : FunctionDefinition ref func, integer mangledname -> integer count = 0
{
	count = CountUnresolvedParameters(func.Params)
}

GetFunctionWrapperParameterCount : nothing, integer mangledname -> integer count = 0
{
	count = GetFunctionParameterCount(mangledname)
}


PopulateAllOverloadTypeMatchers : list<Overload> ref overloads, integer rawname, integer paramcount
{
	if(overloads.value.NormalName == rawname)
	{
		if(!IsFunctionTemplateFast(rawname))
		{
			if(paramcount == GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName))
			{
				if(!IsFunctionTemplateFast(overloads.value.MangledName))
				{				
					FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName, overloads.value.Implementation)
				}
			}
		}
	}

	PopulateAllOverloadTypeMatchers(overloads.next, rawname, paramcount)
}

PopulateAllOverloadTypeMatchers : nothing, integer rawname, integer paramcount


IsFunctionTemplate : FunctionDefinition ref func -> boolean istemplate = func.IsTemplate
IsFunctionTemplate : nothing -> false


IsFunctionTemplateFast : integer name -> boolean istemplate = false
{
	ContextWrapper<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, name, wrap)
	if(!found)
	{
		assert(false)
	}
	
	istemplate = CheckFuncTemplate(wrap.Wrapped)
}

CheckFuncTemplate : FunctionDefinition ref func -> boolean ret = func.IsTemplate


GenerateTypeMatcherMappings : list<FunctionDefinition> ref functions
{
	if(functions.value.Name != 0)
	{
		if(!functions.value.IsTemplate)
		{
			integer rawname = functions.value.RawName
			integer paramcount = CountUnresolvedParameters(functions.value.Params)
		
			if(AnyPendingTypeMatcherPointsToAnyOverload(functions.value.Overloads, rawname, paramcount))
			{
				PopulateAllOverloadTypeMatchers(functions.value.Overloads, rawname, paramcount)
			}
		}
	}

	GenerateTypeMatcherMappings(functions.next)
}

GenerateTypeMatcherMappings : nothing


AnyPendingTypeMatcherPointsToAnyOverload : list<Overload> ref overloads, integer rawname, integer paramcount -> boolean ret = false
{
	if(overloads.value.NormalName == rawname)
	{
		if(GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName) == paramcount)
		{
			if(AnyPendingTypeMatcherPointsToFunction(overloads.value.MangledName))
			{
				ret = true
				return()
			}
		}
	}
	
	ret = AnyPendingTypeMatcherPointsToAnyOverload(overloads.next, rawname, paramcount)
}

AnyPendingTypeMatcherPointsToAnyOverload : nothing, integer rawname, integer paramcount -> boolean ret = false


AnyPendingTypeMatcherPointsToFunction : integer mangledname -> boolean ret = false
{
	ContextWrapper<PendingTypeMatcher> wrap = nothing
	ret = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExist, mangledname, wrap)
}



GetFunctionParameterCount : integer funcname -> integer count = -1 [nogc]
{
	if(funcname == PooledStringHandleForSubstringWithLength)
	{
		count = 3
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		count = 2
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		count = 2
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		count = 1
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		count = 3
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		count = 4
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		count = 4
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		count = 3
	}
}

CountUnresolvedParameters : FunctionParams ref params -> integer count = CountUnresolvedParametersUnwrapped(params.Params) [nogc]
CountUnresolvedParameters : nothing -> 0 [nogc]

CountUnresolvedParametersUnwrapped : list<UnresolvedParameter> ref params -> integer count = 0 [nogc]
{
	if(params.value.NameHandle != 0)
	{
		++count
	}
	elseif(GetOptionalExpressionType(params.value.PatternMatchValue) != 0)
	{
		++count
	}
	
	count += CountUnresolvedParametersUnwrapped(params.next)
}

CountUnresolvedParametersUnwrapped : nothing -> 0 [nogc]


CheckForNeededTypeMatcher : simplelist<integer> ref types -> boolean needsmatcher = false
{
	if((types.value & 0x7f000000) == 0x07000000)
	{
		needsmatcher = true
	}
	else
	{
		needsmatcher = CheckForNeededTypeMatcher(types.next)
	}
}

CheckForNeededTypeMatcher : nothing -> false


FindOverloadWithParameterTypes : nothing, integer rawname, simplelist<integer> ref types -> integer overloadname = 0
{
	if(rawname == PooledStringHandleForSubstring)
	{
		integer withlen = PooledStringHandleForSubstringWithLength
		integer nolen = PooledStringHandleForSubstringNoLength
		
		if(FunctionMatchesParameterTypes(nothing, withlen, types))
		{
			overloadname = withlen
		}
		elseif(FunctionMatchesParameterTypes(nothing, nolen, types))
		{
			overloadname = nolen
		}
	}
	elseif(rawname == PooledStringHandleForWriteBuffer)
	{
		integer normal = PooledStringHandleForWriteBuffer
		integer withstr = PooledStringHandleForWriteBufferString
		integer multiple = PooledStringHandleForWriteBufferMultiple
		integer withreal = PooledStringHandleForWriteBufferReal
		
		if(FunctionMatchesParameterTypes(nothing, normal, types))
		{
			overloadname = normal
		}
		elseif(FunctionMatchesParameterTypes(nothing, withstr, types))
		{
			overloadname = withstr
		}		
		elseif(FunctionMatchesParameterTypes(nothing, multiple, types))
		{
			overloadname = multiple
		}		
		elseif(FunctionMatchesParameterTypes(nothing, withreal, types))
		{
			overloadname = withreal
		}		
	}
	elseif(IsRecognizedBuiltIn(rawname))
	{
		overloadname = rawname
	}
	else
	{
		boolean matchesctor = false
		if(ConstructorMatchesParameterTypes(Structures, rawname, types, matchesctor))
		{
			overloadname = rawname
		}
		else
		{	// TODO - this is a sloppy hack to work around the fact that operators don't short circuit properly yet
			if(!matchesctor)
			{
				if(!SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, rawname))
				{
					overloadname = rawname
				}
			}
		}
	}
}


FunctionWrapperMatchesParameterTypes : FunctionDefinition ref func, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = CheckParameterTypesForMatch(func.Params, types)
}

FunctionWrapperMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = FunctionMatchesParameterTypes(Functions, funcname, types)
}


FunctionMatchesParameterTypes : list<FunctionDefinition> ref functions, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	ContextWrapper<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, funcname, wrap)
	if(found)
	{
		match = CheckParameterTypesForMatch(wrap.Wrapped, types)
	}
	else
	{
		match = FunctionMatchesParameterTypes(nothing, funcname, types)
	}
}

FunctionMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	if(funcname == PooledStringHandleForSubstringWithLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		simplelist<integer> ptypes = 0x01000004, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		simplelist<integer> ptypes = 0x02000000, nothing
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	else
	{
		boolean ignored = false
		match = ConstructorMatchesParameterTypes(Structures, funcname, types, ignored)
	}
}


ConstructorMatchesParameterTypes : list<StructureDefinition> ref structures, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> boolean match = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}
		
		match = CheckMemberTypes(structures.value.Members, types.next)
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		matchesctor = true
		match = CheckMemberTypes(structures.value.Members, types)
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}
		
		match = CheckCopyType(types.next, structures.value.Type)
	}
	else
	{
		match = ConstructorMatchesParameterTypes(structures.next, ctorname, types, matchesctor)
	}
}

ConstructorMatchesParameterTypes : nothing, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> false


CheckCopyType : simplelist<integer> ref a, integer b -> boolean match = (a.value == b)


CheckParameterTypesForMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	integer count = countnonzero(types)
	if(count == 0)
	{
		match = true
	}
	elseif(count == 1)
	{
		if(types.value == 0x00000002)		// void type signature
		{
			match = true
		}
	}
}

CheckParameterTypesForMatch : FunctionDefinition ref func, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(func.Params, types)
CheckParameterTypesForMatch : FunctionParams ref params, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(params.Params, types)


CheckParameterTypesForMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	if(!ResolvedTypesMatch(params, types))
	{
		match = false
	}
}

CheckParameterTypesForMatch : simplelist<integer> ref atypes, simplelist<integer> ref btypes -> boolean match = TypesMatch(atypes, btypes)


DumpUnresolvedParameters : list<UnresolvedParameter> ref params
{
	print(GetPooledString(GlobalStrings, GetNameOfType(params.value.ResolvedType)))
	DumpUnresolvedParameters(params.next)
}

DumpUnresolvedParameters : nothing


TypesMatch : simplelist<integer> ref a, simplelist<integer> ref b -> boolean match = true
{
	if(a.value != b.value)
	{
		match = false
	}
	else
	{
		match = TypesMatch(a.next, b.next)
	}
}

TypesMatch : nothing, nothing -> true

TypesMatch : nothing, simplelist<integer> ref b -> boolean match = (b.value == 0)
TypesMatch : simplelist<integer> ref a, nothing -> boolean match = (a.value == 0)



ResolvedTypesMatch : nothing, nothing -> true

ResolvedTypesMatch : list<UnresolvedParameter> ref params, nothing -> false
ResolvedTypesMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}

ResolvedTypesMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	integer resolved = params.value.ResolvedType
	while((resolved & 0x7f000000) == 0x05000000)
	{
		resolved = FindTypeAliasBase(TypeAliases, resolved)
	}

	integer expected = types.value
	while((expected & 0x7f000000) == 0x0500000)
	{
		expected = FindTypeAliasBase(TypeAliases, expected)
	}

	if(resolved != expected)
	{
		match = false
		return()
	}


	listnode<UnresolvedParameter> n = params.next
	simplelistnode<integer> nt = types.next
	match = ResolvedTypesMatch(n, nt)			// TODO - this is some kind of compiler bug... or maybe a runtime bug?!
}


GetAssignmentRHSType : Expression ref expr -> integer rettype = expr.Type
GetAssignmentRHSType : Assignment ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)
GetAssignmentRHSType : AssignmentCompound ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)


TypeInference : Assignment ref assignment, InferenceContext ref context -> boolean success = true
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, assignment.LHSName, var)
	
	if(var.Name == 0)
	{
		success = false
		print("Assignment to non-existent variable " ; GetPooledString(GlobalStrings, assignment.LHSName))
		return()
	}

	simplelist<integer> temp = var.VarType, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}
		
	assignment.LHSType = var.VarType
	
	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?
		
		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}
	
	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : AssignmentCompound ref assignment, InferenceContext ref context -> boolean success = true
{
	integer lhstype = ComputeCompoundAssignmentLHSType(assignment, context.ScopeRef.Wrapped)
	
	simplelist<integer> temp = lhstype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}
	
	assignment.LHSType = lhstype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?
		
		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}
	
	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : EntityChain ref chain, InferenceContext ref context -> boolean success = TypeInference(chain.Entries, context)

TypeInference : EntityList ref entities, InferenceContext ref context -> boolean success = TypeInference(entities.ActualList, context)

TypeInference : list<Entity> ref entities, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(entities.value, context))
	{
		success = false
	}
	
	if(!TypeInference(entities.next, context))
	{
		success = false
	}
}

TypeInference : Entity ref entity, InferenceContext ref context -> boolean success = true
{
	simplelist<integer> temp = 0x01000003, nothing			// TODO - don't assume all entities take a boolean!
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef
	
	if(!TypeInference(entity.Param, newcontext))
	{
		success = false
	}
	
	if(!TypeInference(entity.Code, context))
	{
		success = false
	}
}


TypeInference : ExpressionList ref parameters, InferenceContext ref context -> boolean success = true
{
	simplelist<integer> dummytypelist = 0, nothing
	ParameterTypeList dummyparaminfo = dummytypelist
	list<ParameterTypeList> paramtypeinfo = dummyparaminfo, nothing
	
	integer i = 1
	while(i < context.NumParameters)
	{
		simplelist<integer> dummytypelist2 = 0, nothing
		ParameterTypeList dummyparaminfo2 = dummytypelist2
		prepend<ParameterTypeList>(paramtypeinfo, dummyparaminfo2)
	
		++i
	}
	
	boolean hasallparams = GatherAllPossibleParamTypes(context.StatementName, context.NumParameters, context.TopLevelStatement, paramtypeinfo)

	if(!TypeInferenceExpressionList(parameters.Expressions, context, 0, hasallparams, paramtypeinfo))
	{
		success = false
	}
}


GatherAllPossibleParamTypes : integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	ContextWrapper<FunctionDefinition> wrap = nothing
	found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, funcname, wrap)
	if(found)
	{
		InferAllFunctionParameterTypes(wrap.Wrapped, numparams, toplevel, outinfo)
		EnumerateOverloadsAndAddAllParameterTypes(wrap.Wrapped, numparams, toplevel, outinfo)
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(Structures, funcname, numparams, toplevel, outinfo)
	}
}

GatherAllPossibleParamTypesForConstructor : list<StructureDefinition> ref structures, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	if(structures.value.ConstructorName == funcname)
	{
		integer membercount = structures.value.MemberCount
		if(numparams == (membercount + 1))
		{
			simpleprepend<integer>(outinfo.value.Types, 0x01000000)		// Identifier type signature
			ExtractAllMemberTypes(structures.value.Members, outinfo.next)
			found = true
		}
		
		if(numparams == membercount)
		{
			ExtractAllMemberTypes(structures.value.Members, outinfo)
			found = true
		}
		
		if(numparams == 2)
		{
			AddTypeToParamTypeList(outinfo, 0x01000000)			// Identifier type signature
			AddTypeToParamTypeList(outinfo.next, structures.value.Type)
			found = true
		}
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(structures.next, funcname, numparams, toplevel, outinfo)
	}
}

GatherAllPossibleParamTypesForConstructor : nothing, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> false


AddTypeToParamTypeList : list<ParameterTypeList> ref outinfo, integer ty
{
	simpleprepend<integer>(outinfo.value.Types, ty)
}

ExtractAllMemberTypes : list<StructureMember> ref members, list<ParameterTypeList> ref outinfo
{
	simpleprepend<integer>(outinfo.value.Types, GetMemberTypeDecompose(members.value))
	ExtractAllMemberTypes(members.next, outinfo.next)
}

ExtractAllMemberTypes : nothing, nothing


EnumerateOverloadsAndAddAllParameterTypes : FunctionDefinition ref func, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	EnumerateOverloadsAndAddAllParameterTypes(func.Overloads, numparams, toplevel, outinfo)
}

EnumerateOverloadsAndAddAllParameterTypes : list<Overload> ref overloads, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	AddAllParameterTypesForOverloadImplementation(overloads.value.Implementation, overloads.value.MangledName, numparams, toplevel, outinfo)
	EnumerateOverloadsAndAddAllParameterTypes(overloads.next, numparams, toplevel, outinfo)
}

EnumerateOverloadsAndAddAllParameterTypes : nothing, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo


AddAllParameterTypesForOverloadImplementation : FunctionDefinition ref function, integer mangledname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	InferAllFunctionParameterTypes(function, numparams, toplevel, outinfo)
}

AddAllParameterTypesForOverloadImplementation : nothing, integer mangledname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo


InferAllFunctionParameterTypes : FunctionDefinition ref function, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}
	
	UnwrapAllParamsForTypeRetrieval(function.Params, numparams, outinfo)
}


UnwrapAllParamsForTypeRetrieval : FunctionParams ref params, integer paramcount, list<ParameterTypeList> ref outinfo
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveAllParamTypes(params.Params, outinfo)
	}
}

UnwrapAllParamsForTypeRetrieval : nothing, integer paramcount, list<ParameterTypeList> ref outinfo


RetrieveAllParamTypes : list<UnresolvedParameter> ref params, list<ParameterTypeList> ref outinfo [nogc]
{
	simpleprepend<integer>(outinfo.value.Types, params.value.ResolvedType)
	RetrieveAllParamTypes(params.next, outinfo.next)
}

RetrieveAllParamTypes : nothing, nothing [nogc]


GrabTypeListAtIndex : list<ParameterTypeList> ref paraminfo, integer paramindex, simplelist<integer> ref out [nogc]
{
	if(paramindex == 0)
	{
		out = paraminfo.value.Types
		return()
	}
	
	GrabTypeListAtIndex(paraminfo.next, paramindex - 1, out)
}


TypeInferenceExpressionList : list<Expression> ref parameters, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true
{
	simplelist<integer> temp = 0, nothing
	
	if(hasallparams)
	{
		GrabTypeListAtIndex(paraminfo, paramindex, temp)
	}
	else
	{
		GetExpectedParameterTypes(context.StatementName, paramindex, context.NumParameters, context.TopLevelStatement, temp)
	}
	
	InferenceContext newcontext = context.ScopeName, context.StatementName, temp, context.FunctionReturn, context.NumParameters, context.TopLevelStatement, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(parameters.value, newcontext))
	{
		print("Parameter " ; cast(string, paramindex) ; " failed type inference!")	
		success = false
	}
	else
	{
		context.StatementName = newcontext.StatementName
	}

	if(!TypeInferenceExpressionList(parameters.next, context, paramindex + 1, hasallparams, paraminfo))
	{
		success = false
	}
}

TypeInferenceExpressionList : nothing, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true


TypeInference : Expression ref expression, InferenceContext ref context -> boolean success = true
{
	if(expression.Type != 0)
	{
		return()
	}

	if(ExpressionAtomIsSentinel(expression.Atoms.value))
	{
		expression.Type = 0x00000002
		return()
	}
	
	CoalesceMemberAccesses(expression.Atoms, context.ScopeRef.Wrapped)
	ShuntingYard(expression.Atoms)

	InferencePossibility temp = 0, scratchparampossibles, scratchreturns
	list<InferencePossibility> possibilities = temp, nothing
	ExpressionInferenceStackEntry stackentry = possibilities
	list<ExpressionInferenceStackEntry> stack = stackentry, nothing

	integer counter = 0
		
	WalkAtomsForType(expression.Atoms, expression.Atoms.next, stack, counter, context)
		
	integer possibilitycount = CountPossibilities(stack.value.PossibilityList)
	if(possibilitycount == 1)
	{
		if((!context.FunctionReturn) && (context.StatementName != 0))
		{
			simplelist<integer> types = 0, nothing
			integer typecount = EliminateImpossibleType(stack.value.PossibilityList.value.ReturnType.Types, context.ExpectedTypes, types)

			if(typecount == 1)
			{
				assertmsg(types.value != 0, "Inferred a non-type!")
				expression.Type = types.value
			}
			elseif(typecount > 1)
			{
				print("Multiple types possible:")
				DumpTypeList(types)
			}
			else
			{
				// TODO - demotion logic here is MESSY
				if((countnonzero(stack.value.PossibilityList.value.ReturnType.Types) == 1) && (countnonzero(context.ExpectedTypes) == 1) && (stack.value.PossibilityList.value.ReturnType.Types.value == 0x01000001) && (context.ExpectedTypes.value == 0x01000002))
				{
					expression.Type = 0x01000002
				}
				else
				{
					print("All types ruled out")
					DumpTypeList(stack.value.PossibilityList.value.ReturnType.Types)
					print("Expected types are")
					DumpTypeList(context.ExpectedTypes)
				}
			}
		}
		else
		{
			simplelist<integer> possibletypes = 0, nothing
			FilterTypesForDemotion(stack.value.PossibilityList.value.ReturnType.Types, possibletypes)
			
			integer typecount = countnonzero(possibletypes)
			if(typecount == 1)
			{
				expression.Type = possibletypes.value
				assertmsg(expression.Type != 0, "Ruled out all types but a non-type!")
			}
			elseif(context.FunctionReturn)
			{
				print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
				DumpTypeList(possibletypes)
			}
			else
			{
				print("Expression has " ; cast(string, typecount) ; " types possible")
				DumpTypeList(possibletypes)
			}
		}
	}
	else
	{
		// TODO - error context!
		if(possibilitycount > 0)
		{
			print("Multiple overloads possible:")
			DumpOverloadList(stack.value.PossibilityList)
		}
		else
		{
			print("No types possible in this expression:")
			DumpExpressionAtoms(expression.Atoms)
			print("End expression")
		}
	}

	if(expression.Type == 0)
	{
		success = false
	}
	elseif(expression.Type == 0x01000002)
	{
		DemoteAtomType(expression.Atoms)
	}
	elseif((expression.Type & 0x7f000000) == 0x09000000)
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
	elseif(IsStructureType(expression.Type))
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
}


CountPossibilities : list<InferencePossibility> ref thelist -> integer count = 0 [nogc]
{
	count = CountPossibilities(thelist.next)

	if(thelist.value.FunctionName != 0)
	{
		++count
	}
}

CountPossibilities : nothing -> 0 [nogc]


countnonzero : simplelist<integer> ref thelist -> integer count = 0 [nogc]
{
	count = countnonzero(thelist.next)

	if(thelist.value != 0)
	{
		++count
	}
}

countnonzero : nothing -> 0 [nogc]


SetAtomType : IdentifierAtom ref atom, integer typeid [nogc]
{
	atom.Type = typeid
}

SetAtomType : CompoundAtom ref atom, integer typeid [nogc]
{
	atom.Type = typeid
}

SetAtomType : Statement ref atom, integer typeid [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	boolean didrightdemote = WalkAtomsForType(tail, tail.next, stack, counter, context)
	boolean unarycompensate = false
	
	if(IsOperatorInvoke(tail.value))
	{
		if(IsUnaryOperator(tail.value))
		{
			SetOperatorAtomToOverload(tail, stack.value.PossibilityList.value.FunctionName, 0)
			unarycompensate = true
		}
	}

	if(IsOperatorInvoke(atoms.value))
	{
		if(counter > 0)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter + 1)
			--counter
		}
		
		list<InferencePossibility> possibleoperators = scratchpossibility, nothing
		GetAtomTypeOperator(atoms.value, possibleoperators)
		
		ExpressionInferenceStackEntry entry = possibleoperators
		prepend<ExpressionInferenceStackEntry>(stack, entry)
	}
	else
	{
		list<InferencePossibility> out = scratchpossibility, nothing
		EliminateImpossibleParametersForAllOverloads(stack.value.PossibilityList, out, atoms.value, context.ScopeRef.Wrapped, context.FuncRef, context.FunctionReturn, context.Parenthetical)

		if(counter == 1)
		{
			list<InferencePossibility> filtered = scratchpossibility, nothing
			FilterOverloadsForTypeDemotion(out, filtered)
			stack.value.PossibilityList = filtered
		}
		else
		{
			stack.value.PossibilityList = out
		}
		
		if(CountPossibilities(stack.value.PossibilityList) == 1)
		{
			if(listcontains(stack.value.PossibilityList.value.ParameterTypes.value.Types, 0x01000002))
			{
				DemoteAtomType(atoms)
				demotedtoright = true
				
				if((!didrightdemote) && (!IsOperatorInvoke(tail.value)))
				{
					DemoteAtomType(tail)
				}
			}
		}
		elseif(didrightdemote)
		{
			DemoteAtomType(atoms)
		}
		
		++counter
		if(counter > 1)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter)
			++counter
		}
	
		if(AllOptionsConsumed(stack.value.PossibilityList.value.ParameterTypes))
		{
			stack.value.PossibilityList.value.ReturnType.Consumed = true
			CopyReturnTypeToParamTypes(stack, stack.next)
		}
	}
	
	if(unarycompensate)
	{
		++counter
	}	
}


CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail
{
	AddPossibleParamTypeForAllOverloads(tail.value.PossibilityList, stack.value.PossibilityList.value.ReturnType)
	PopExpressionInferenceStack(stack, tail)
}

CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, nothing



AddPossibleParamTypeForAllOverloads : list<InferencePossibility> ref possibilities, TypePossibilityList ref paramtypes
{
	prepend<TypePossibilityList>(possibilities.value.ParameterTypes, paramtypes)

	AddPossibleParamTypeForAllOverloads(possibilities.next, paramtypes)
}

AddPossibleParamTypeForAllOverloads : nothing, TypePossibilityList ref paramtypes


AllOptionsConsumed : list<TypePossibilityList> ref options -> boolean allconsumed = true [nogc]
{
	if(!options.value.Consumed)
	{
		if(countnonzero(options.value.Types) > 0)
		{
			allconsumed = false
		}
		else
		{
			allconsumed = AllOptionsConsumed(options.next)
		}
	}
	else
	{
		allconsumed = AllOptionsConsumed(options.next)
	}
}

AllOptionsConsumed : nothing -> true [nogc]


PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail [nogc]
{
	stack = tail
}

PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, nothing [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, nothing, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	if(IsOperatorInvoke(atoms.value))
	{
		GetAtomTypeOperator(atoms.value, stack.value.PossibilityList)
	}
	else
	{
		TypePossibilityList poss = scratchpossibletypes, false
		InferencePossibility newpossibility = -1, scratchparampossibles, poss
		GetAtomType(atoms.value, newpossibility.ReturnType, context.ScopeRef.Wrapped, context.FuncRef, context.FunctionReturn, context.Parenthetical)
		
		prepend<InferencePossibility>(stack.value.PossibilityList, newpossibility)
	}
}


EliminateImpossibleParametersForAllOverloads : list<InferencePossibility> ref possibilities, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(possibilities.value.FunctionName != 0)
	{
		if(EliminateImpossibleParameters(possibilities.value.ParameterTypes, atom, scope, func, funcret, parenthetical))
		{
			prepend<InferencePossibility>(out, possibilities.value)
		}
	}
	
	EliminateImpossibleParametersForAllOverloads(possibilities.next, out, atom, scope, func, funcret, parenthetical)
}

EliminateImpossibleParametersForAllOverloads : nothing, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical


EliminateImpossibleParameters : list<TypePossibilityList> ref params, ExpressionAtom ref atom, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> boolean valid = true
{
	if(!params.value.Consumed)
	{
		TypePossibilityList poss = scratchpossibletypes, false
		GetAtomType(atom, poss, scope, func, funcret, parenthetical)
		
		simplelist<integer> types = 0, nothing
		integer typecount = EliminateImpossibleType(params.value.Types, poss.Types, types)
				
		if(typecount == 0)
		{
			valid = false
		}
		
		params.value.Types = types
		params.value.Consumed = true
	}
	else
	{
		if(!EliminateImpossibleParameters(params.next, atom, scope, func, funcret, parenthetical))
		{
			valid = false
		}
	}
}


EliminateImpossibleParameters : nothing, ExpressionAtom ref atom, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> true


SetOperatorAtomToOverload : list<ExpressionAtom> ref atoms, integer overloadname, integer count
{
	if(count == 0)
	{
		ChangeOperator(atoms.value, overloadname)
	}
	else
	{
		SetOperatorAtomToOverload(atoms.next, overloadname, count - 1)
	}
}

ChangeOperator : OperatorInvokeAtom ref atom, integer overloadname
{
	atom.OperatorName = overloadname
}



EliminateImpossibleType : simplelist<integer> ref possibles, simplelist<integer> ref filter, simplelist<integer> ref out -> integer count = 0 [nogc]
{
	count = EliminateImpossibleType(possibles.next, filter, out)
	
	if(possibles.value != 0)
	{
		integer expectedtype = TypeListContains(filter, possibles.value)
		if(expectedtype != 0)
		{
			count = count + 1
			simpleprepend<integer>(out, expectedtype)
		}
	}
}

EliminateImpossibleType : nothing, simplelist<integer> ref filter, simplelist<integer> ref out -> 0 [nogc]


GetAtomType : AtomSentinel       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x00000002) }	// void magic
GetAtomType : StringHandleAtom   ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x02000000) }
GetAtomType : TypeAnnotationAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000001) }
GetAtomType : integer16          ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000002) }
GetAtomType : boolean            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000003) }
GetAtomType : real               ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000004) }

GetAtomType : integer            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	AddPossibleParameter(possibilities.Types, 0x01000001)
	AddPossibleParameter(possibilities.Types, 0x01000002)			// Allow demotion later
}

GetAtomType : CompoundAtom       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, atom.Type)  }

GetAtomType : Statement ref statement, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{	
	ContextWrapper<Scope> scopewrap = scope
	InferenceContext newcontext = scope.Name, statement.Name, globalemptyintlist, funcret, 0, false, false, scopewrap, func
	
	if(TypeInference(statement, newcontext))
	{
		AddPossibleParameter(possibilities.Types, statement.Type)
	}
}

GetAtomType : RefBinding ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical

GetAtomType : ParentheticalExpression ref parenthetical, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean isinparenthetical
{
	ContextWrapper<Scope> scopewrap = scope
	InferenceContext newcontext = scope.Name, 0, globalemptyintlist, funcret, 0, false, true, scopewrap, func
		
	if(TypeInference(parenthetical.Inner, newcontext))
	{
		AddPossibleParameter(possibilities.Types, GetParentheticalType(parenthetical.Inner))
	}
	else
	{
		print("Parenthetical expression failed type inference")
	}
}

GetParentheticalType : PreOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : PostOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : Expression ref expr -> integer rettype = expr.Type [nogc]

GetAtomTypeOperator : OperatorInvokeAtom ref atom, list<InferencePossibility> ref possibilities
{
	AddPossibilityPerOperatorOverload(atom.OperatorName, possibilities)
}

GetAtomType : IdentifierAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextWrapper<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(atom.Handle == PooledStringHandleForNothing)
	{
		atom.Type = 0x00000004
		AddPossibleParameter(possibilities.Types, 0x00000004)
		return()
	}

	if((!parenthetical) && (!funcret))
	{
		AddPossibleParameter(possibilities.Types, 0x01000000)
	}
	
	integer nametype = GetTypeByName(atom.Handle)
	if(nametype != 0)
	{
		if(IsStructureType(nametype))
		{
			if(FunctionIsAutoGenOrHasIR(atom.Handle))
			{
				atom.IsFunction = true
			}
		}
		
		return()
	}
	

	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(scope, atom.Handle, var)
	
	if(var.Name != 0)
	{
		AddPossibleParameter(possibilities.Types, var.VarType)
		if((var.VarType & 0x7f000000) == 0x09000000)
		{
			atom.IsFunction = true
		}
	}
	else
	{
		if(SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, atom.Handle))
		{
			atom.IsFunction = true
		
			// TODO - overload resolution on higher order function name
			integer sigtype = FindFunctionAndGetSignatureType(Functions, atom.Handle)
			AddPossibleParameter(possibilities.Types, sigtype)
		}
		else
		{
			integer sigtype = FindBuiltinAndGetSignatureType(atom.Handle)
			if(sigtype != 0)
			{
				AddPossibleParameter(possibilities.Types, sigtype)
			}
			else
			{
				print(GetPooledString(GlobalStrings, atom.Handle) ; " is not a defined identifier!")
			}
		}
	}
}


IsOperatorInvoke : OperatorInvokeAtom 	   ref nonsentinel -> true [nogc]

IsOperatorInvoke : AtomSentinel 	   ref sentinel    -> false [nogc]
IsOperatorInvoke : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : IdentifierAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : integer 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : integer16 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : boolean 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : real 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : Statement		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : RefBinding              ref nonsentinel -> false [nogc]
IsOperatorInvoke : CompoundAtom		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : ParentheticalExpression ref nonsentinel -> false [nogc]


IsRefBind : IdentifierAtom ref atom -> atom.IsReference [nogc]
IsRefBind : RefBinding ref atom -> true [nogc]
IsRefBind : CompoundAtom		   ref nonsentinel -> boolean ret = true [nogc]
{
	if(!IsReferenceType(nonsentinel.Type))
	{
		ret = false
	}
}

IsRefBind : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
IsRefBind : AtomSentinel 	   ref sentinel    -> false [nogc]
IsRefBind : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsRefBind : integer 		   ref nonsentinel -> false [nogc]
IsRefBind : integer16 		   ref nonsentinel -> false [nogc]
IsRefBind : boolean 		   ref nonsentinel -> false [nogc]
IsRefBind : real 		   ref nonsentinel -> false [nogc]
IsRefBind : Statement		   ref nonsentinel -> false [nogc]
IsRefBind : ParentheticalExpression ref nonsentinel -> false [nogc]
IsRefBind : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]


IsTypeAnnotationAtom : TypeAnnotationAtom 	   ref nonsentinel -> true [nogc]

IsTypeAnnotationAtom : AtomSentinel 	   ref sentinel    -> false [nogc]
IsTypeAnnotationAtom : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : IdentifierAtom 	   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : integer 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : integer16 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : boolean 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : real 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : Statement		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : RefBinding              ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : CompoundAtom		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : ParentheticalExpression ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]



IsMemberAccessOperator : OperatorInvokeAtom 	 ref nonsentinel -> boolean ismemberaccess = false [nogc]
{
	if(nonsentinel.OperatorName == PooledStringHandleForMemberAccess)
	{
		ismemberaccess = true
	}
}

IsMemberAccessOperator : AtomSentinel 	   	 ref sentinel    -> false [nogc]
IsMemberAccessOperator : StringHandleAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : IdentifierAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : TypeAnnotationAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : integer 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : integer16 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : boolean 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : real 		   	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : Statement		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : RefBinding              ref nonsentinel -> false [nogc]
IsMemberAccessOperator : CompoundAtom            ref nonsentinel -> false [nogc]
IsMemberAccessOperator : ParentheticalExpression ref nonsentinel -> false [nogc]



MarkAtomAsReference : OperatorInvokeAtom      ref atom -> false [nogc]
MarkAtomAsReference : AtomSentinel 	      ref atom -> false [nogc]
MarkAtomAsReference : StringHandleAtom 	      ref atom -> false [nogc]
MarkAtomAsReference : TypeAnnotationAtom      ref atom -> false [nogc]
MarkAtomAsReference : integer 		      ref atom -> false [nogc]
MarkAtomAsReference : integer16               ref atom -> false [nogc]
MarkAtomAsReference : boolean 		      ref atom -> false [nogc]
MarkAtomAsReference : real 		      ref atom -> false [nogc]
MarkAtomAsReference : Statement		      ref atom -> false [nogc]
MarkAtomAsReference : ParentheticalExpression ref atom -> false [nogc]

MarkAtomAsReference : RefBinding              ref atom -> true [nogc]

MarkAtomAsReference : IdentifierAtom          ref atom -> true [nogc]
{
	atom.IsReference = true
}

MarkAtomAsReference : CompoundAtom            ref atom -> true [nogc]
{
	atom.Type = MakeReferenceType(atom.Type)
}


AddPossibleParameter : simplelist<integer> ref possibilities, integer paramtype [nogc]
{
	simpleprepend<integer>(possibilities, paramtype)
	
	if((paramtype & 0x7f000000) == 0x05000000)
	{
		simpleprepend<integer>(possibilities, FindTypeAliasBase(TypeAliases, paramtype))
	}
}

AddBinaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer param2type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing
	simplelist<integer> p2t = param2type, nothing

	TypePossibilityList param1options = p1t, false
	TypePossibilityList param2options = p2t, false

	list<TypePossibilityList> paramtypes = scratchparams, nothing
	prepend<TypePossibilityList>(paramtypes, param2options)
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}

AddUnaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing

	TypePossibilityList param1options = p1t, false

	list<TypePossibilityList> paramtypes = scratchparams, nothing
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}


ShuntingYard : list<ExpressionAtom> ref atoms
{
	AtomSentinel sentinel = 0

	list<ExpressionAtom> outputqueue = sentinel, nothing
	list<ExpressionAtom> opstack = sentinel, nothing

	ShuntingYardWalk(atoms, outputqueue, opstack)
	ShuntingYardFlush(outputqueue, opstack)

	atoms = outputqueue
}

ShuntingYardWalk : nothing, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack

ShuntingYardWalk : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	ShuntingYardVisit(atoms.value, outputqueue, opstack)
	ShuntingYardWalk(atoms.next, outputqueue, opstack)
}

ShuntingYardVisit : AtomSentinel            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
ShuntingYardVisit : StringHandleAtom        ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : IdentifierAtom          ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : TypeAnnotationAtom      ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer16               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : boolean                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : real                    ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : Statement               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : RefBinding              ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : ParentheticalExpression ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : CompoundAtom            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }

ShuntingYardVisit : OperatorInvokeAtom ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	integer opprec = GetOperatorPrecedence(atom)
	boolean continueops = true

	while(continueops && (!ExpressionAtomIsSentinel(opstack.value)))
	{
		ExpressionAtom opatom2 = opstack.value
		integer op2prec = GetOperatorPrecedence(opatom2)

		// TODO - this whole section is hacky. Replace with break() calls and >= operator.

		if(IsUnaryOperator(atom))
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
			elseif(opprec == op2prec)
			{
				continueops = false
			}
		}
		else
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
		}

		if(continueops)
		{
			PlaceAtomInList(outputqueue, opatom2)
			ShuntingYardPopStack(opstack, opstack.next)
		}
	}

	ExpressionAtom wrap = atom
	prepend<ExpressionAtom>(opstack, wrap)
}

ShuntingYardFlush : list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	while(!ExpressionAtomIsSentinel(opstack.value))
	{
		PlaceAtomInList(outputqueue, opstack.value)
		ShuntingYardPopStack(opstack, opstack.next)
	}
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, list<ExpressionAtom> ref tail [nogc]
{
	opstack = tail
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, nothing [nogc]
{
	AtomSentinel sentinel = 0
	list<ExpressionAtom> newlist = sentinel, nothing
	opstack = newlist
}


IsUnaryOperator : OperatorInvokeAtom ref atom -> boolean isunary = false [nogc]
{
	if(atom.OperatorName == PooledStringHandleForUnaryNot)
	{
		isunary = true
	}
}


GetOperatorPrecedence : OperatorInvokeAtom ref atom -> integer precedence = 0 [nogc]
{
	if(atom.OperatorName == PooledStringHandleForEquality)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForInequality)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForGreaterThan)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForLessThan)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForBooleanAnd)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForBitwiseAnd)
	{
		precedence = 1		// TODO - revisit all operator precedences
	}
	elseif(atom.OperatorName == PooledStringHandleForStringConcat)
	{
		precedence = 3
	}
	elseif(atom.OperatorName == PooledStringHandleForPlus)
	{
		precedence = 5
	}
	elseif(atom.OperatorName == PooledStringHandleForMinus)
	{
		precedence = 5
	}
	elseif(atom.OperatorName == PooledStringHandleForMultiply)
	{
		precedence = 9
	}
	elseif(atom.OperatorName == PooledStringHandleForDivide)
	{
		precedence = 9
	}
	elseif(atom.OperatorName == PooledStringHandleForUnaryNot)
	{
		precedence = 10
	}
	elseif(atom.OperatorName == PooledStringHandleForMemberAccess)
	{
		precedence = 11
	}
	else
	{
		print("Unknown operator " ; GetPooledString(GlobalStrings, atom.OperatorName))
		assert(false)
	}
}


ConstructVariableFromStatement : Statement ref statement, Scope ref scope, integer vartype, integer origin
{
	integer varname = ExtractConstructorIdentifier(statement.Parameters)
		
	if(varname != 0)
	{	
		// TODO - do real shadowing checks here
		Variable var = 0, 0, 0, 0
		FindVariableDataInSingleScope(scope, varname, var)
		if(var.Name != 0)
		{
			return()
		}
		
		StoreVariableInSingleScope(scope, varname, vartype, false, origin)
	}
}

ExtractConstructorIdentifier : ExpressionList ref parameters -> integer varname = ExtractConstructorIdentifier(parameters.Expressions)
ExtractConstructorIdentifier : list<Expression> ref parameters -> integer varname = ExtractIdentifier(parameters.value)
ExtractConstructorIdentifier : nothing -> 0

ExtractIdentifier : Expression ref expression -> integer id = ExtractIdentifier(expression.Atoms.value) [nogc]

ExtractIdentifier : IdentifierAtom ref atom -> atom.Handle [nogc]
{
	atom.Type = 0x81000000		// HACK - reference to identifier
}

ExtractIdentifier : AtomSentinel 	    ref sentinel    -> 0 [nogc]
ExtractIdentifier : StringHandleAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : OperatorInvokeAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : TypeAnnotationAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : integer 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : integer16 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : boolean 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : real 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : Statement		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : RefBinding              ref nonsentinel -> 0 [nogc]
ExtractIdentifier : CompoundAtom            ref nonsentinel -> 0 [nogc]
ExtractIdentifier : ParentheticalExpression ref nonsentinel -> 0 [nogc]


PlaceAtomInList : list<ExpressionAtom> ref atoms, ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(atoms.value))
	{
		atoms.value = atom
	}
	else
	{
		AppendAtomToExpression(atoms, atoms.next, atom)
	}
}



PoolString : string s -> integer handle = FindHandleInTrie(GlobalStringTrie, s) [nogc]
{
	if(handle == 0)
	{
		handle = PoolStringFast(s)
	}
}

PoolStringFast : string s -> integer handle = 0 [nogc]
{
	++CurrentStringHandle
	OnCodeGenRegisterString(CurrentStringHandle, s)
	handle = CurrentStringHandle
}


IREnterProgram :
{
}

IRExitProgram :
{
}


IREnterFunction : integer namehandle
{
	OnCodeGenRegisterScope(namehandle, 0)
}

IRExitFunction :
{
	OnCodeGenExitContext()
}


IREnterStatement : string funcname, boolean istoplevel, boolean hastemplateargs
{
	integer namehandle = PoolString(funcname)
	OnCodeGenEnterStatement(namehandle, 0, istoplevel, hastemplateargs)
}

IRExitStatement :
{
	OnCodeGenExitContext()
}


IRAddOperator : string operatorname
{
	OnCodeGenRegisterOperatorInvoke(PoolString(operatorname))
}

IRAddLiteralString : string literal
{
	OnCodeGenRegisterLiteralString(PoolString(literal))
}

IRAddLiteralBoolean : boolean literal
{
	OnCodeGenRegisterLiteralBoolean(literal)
}

IRAddLiteralReal : real literal
{
	OnCodeGenRegisterLiteralReal(literal)
}

IRAddLiteralInteger : integer literal
{
	OnCodeGenRegisterLiteralInteger(literal, 0x01000001)		// We can demote the integer later
}

IRAddLiteralIdentifier : string token
{
	OnCodeGenRegisterAtomIdentifier(PoolString(token), 0)
}



GetPooledString : list<StringTableEntry> ref strings, integer handle -> string pooled = "" [nogc]
{
	if(strings.value.Handle == handle)
	{
		pooled = strings.value.Data
	}
	else
	{
		pooled = GetPooledString(strings.next, handle)
	}
}

GetPooledString : nothing, integer handle -> "" [nogc]
{
	print("String handle not pooled: " ; cast(string, handle))
	assert(false)
}


DumpAtom : AtomSentinel 	   ref sentinel    { print("Sentinel") }
DumpAtom : StringHandleAtom 	   ref nonsentinel { print("String handle " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : IdentifierAtom 	   ref nonsentinel { print("Identifier " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : OperatorInvokeAtom 	   ref nonsentinel { print("Operator " ; cast(string, nonsentinel.OperatorName)) }
DumpAtom : TypeAnnotationAtom 	   ref nonsentinel { print("Type annotation") }
DumpAtom : integer 		   ref nonsentinel { print("integer " ; cast(string, nonsentinel)) }
DumpAtom : integer16 		   ref nonsentinel { print("integer16") }
DumpAtom : boolean 		   ref nonsentinel { print("boolean") }
DumpAtom : real 		   ref nonsentinel { print("real " ; cast(string, nonsentinel)) }
DumpAtom : RefBinding              ref nonsentinel { print("RefBinding") }
DumpAtom : ParentheticalExpression ref nonsentinel { print("Parenthetical") }
DumpAtom : CompoundAtom            ref nonsentinel { print("Compound") }

DumpAtom : Statement		   ref nonsentinel
{
	print("Statement " ; GetPooledString(GlobalStrings, nonsentinel.Name))
	print("BEGIN PARAMS")
	DumpParameterAtoms(nonsentinel.Parameters)
	print("END PARAMS")
}

DumpExpressionAtoms : list<ExpressionAtom> ref atoms
{
	DumpAtom(atoms.value)
	DumpExpressionAtoms(atoms.next)
}

DumpExpressionAtoms : nothing


DumpExpressionList : list<Expression> ref exprs
{
	print("BEGIN EXPR")
	DumpExpressionAtoms(exprs.value.Atoms)
	print("END EXPR")

	DumpExpressionList(exprs.next)
}

DumpExpressionList : nothing


DumpParameterAtoms : ExpressionList ref exprs
{
	DumpExpressionList(exprs.Expressions)
}

DumpParameterAtoms : nothing



AddPossibilityPerOperatorOverload : integer basenamehandle, list<InferencePossibility> ref possibilities
{
	if(basenamehandle == PooledStringHandleForEquality)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityInteger,   0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityInteger16, 0x01000002, 0x01000002, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityBoolean,   0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityReal,      0x01000004, 0x01000004, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityString,    0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForInequality)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityInteger, 0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityBoolean, 0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityString,  0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForGreaterThan)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForGreaterThanInteger, 0x01000001, 0x01000001, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForLessThan)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForLessThanInteger, 0x01000001, 0x01000001, 0x01000003)
	}	
	elseif(basenamehandle == PooledStringHandleForPlus)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForPlusInteger, 0x01000001, 0x01000001, 0x01000001)
		AddBinaryPossibility(possibilities, PooledStringHandleForPlusReal, 0x01000004, 0x01000004, 0x01000004)
	}
	elseif(basenamehandle == PooledStringHandleForMinus)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForMinusInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForMultiply)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForMultiplyInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForDivide)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForDivideInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForBitwiseAnd)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForBitwiseAnd, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForBooleanAnd)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForBooleanAnd, 0x01000003, 0x01000003, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForStringConcat)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForStringConcat, 0x02000000, 0x02000000, 0x02000000)
	}
	elseif(basenamehandle == PooledStringHandleForUnaryNot)
	{
		AddUnaryPossibility(possibilities, PooledStringHandleForUnaryNotBoolean, 0x01000003, 0x01000003)
	}
	else
	{
		print("Unrecognized operator")
		assert(false)
	}
}


GetExpectedParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(funcname, paramindex, paramcount, toplevel, types)
	EnumerateOverloadsAndAddParameterTypes(AutoGenOverloads, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : list<Overload> ref overloads, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(overloads.value.NormalName == funcname)
	{
		AddParameterTypesForOverloadImplementation(overloads.value.Implementation, overloads.value.MangledName, paramindex, paramcount, toplevel, types)
	}
	
	EnumerateOverloadsAndAddParameterTypes(overloads.next, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types


AddParameterTypesForOverloadImplementation : FunctionDefinition ref func, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!func.InferenceDone)
	{
		TypeInference(func, DummyContextForFunctions)
	}

	UnwrapParamsForTypeRetrieval(func.Params, paramindex, paramcount, types)
}

AddParameterTypesForOverloadImplementation : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(funcname, paramindex, paramcount, toplevel, types)
}


InferFunctionParameterTypes : FunctionDefinition ref function, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}
	
	UnwrapParamsForTypeRetrieval(function.Params, paramindex, paramcount, types)
}

FindFunctionAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!FindConstructorAndAddParameterTypes(Structures, funcname, paramindex, paramcount, toplevel, types))
	{
		FindBuiltinAndAddParameterTypes(funcname, paramindex, paramcount, types)
	}
}

UnwrapParamsForTypeRetrieval : FunctionParams ref params, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveParamType(params.Params, paramindex, types)
	}
}

UnwrapParamsForTypeRetrieval : nothing, integer paramindex, integer paramcount, simplelist<integer> ref types


RetrieveParamType : list<UnresolvedParameter> ref params, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{	
		simpleprepend<integer>(types, params.value.ResolvedType)
		return()
	}
	
	RetrieveParamType(params.next, paramindex - 1, types)
}

RetrieveParamType : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many parameters to call!")
	assert(false)
}


InferFunctionReturnType : PendingTypeMatcher ref pending -> integer rettype = InferFunctionReturnType(pending.OverloadImplementation)

InferFunctionReturnType : FunctionDefinition ref func -> integer rettype = 0
{
	if(!func.InferenceDone)
	{
		TypeInference(func, DummyContextForFunctions)
	}

	rettype = GetOptionalExpressionType(func.Return)
}


GetFunctionReturnType : list<FunctionDefinition> ref functions, integer funcname -> integer rettype = 0
{
	if(functions.value.Name == funcname)
	{
		rettype = InferFunctionReturnType(functions.value)
	}
	else
	{
		rettype = GetFunctionReturnType(functions.next, funcname)
	}
}

GetFunctionReturnType : nothing, integer funcname -> integer rettype = 0
{
	ContextWrapper<PendingTypeMatcher> ignored = nothing
	rettype = GetPendingTypeMatcherReturnType(funcname, ignored)
}


GetOptionalExpressionType : Expression ref expr -> expr.Type [nogc]
GetOptionalExpressionType : nothing -> 0 [nogc]


FindBuiltinAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	integer ctype = GetTypeByName(funcname)
	if((ctype & 0x7f000000) == 0x05000000)
	{
		funcname = GetNameOfType(FindTypeAliasBase(TypeAliases, ctype))
	}

	if((ctype & 0x7f000000) == 0x07000000)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				FindSumTypeAndPrependTypesToList(SumTypes, ctype, types)
			}
		}
		return()
	}

	if(funcname == PooledStringHandleForPassTest)
	{
		// No parameters
	}
	elseif(funcname == PooledStringHandleForAssert)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForPrint)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForInteger16)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForBoolean)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForReal)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForBuffer)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForNarrowString)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubstringWithLength)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastBooleanToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastRealToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastRealToString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastStringToReal)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastIntegerToString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastStringToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastInteger16ToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastIntegerToInteger16)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}	
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		if(paramcount == 4)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 3)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		if(paramcount == 4)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 3)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForLength)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWidenFromPtr)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCmdLineGet)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}		
	}
	elseif(funcname == PooledStringHandleForCmdLineGetCount)
	{
		// no params
	}
	elseif(funcname == PooledStringHandleForCmdLineIsValid)
	{
		// no params
	}
}


PrependSumTypeBases : simplelist<integer> ref input, list<SumTypeBase> ref newentries [nogc]
{
	simpleprepend<integer>(input, newentries.value.Name)
	PrependSumTypeBases(input, newentries.next)
}

PrependSumTypeBases : simplelist<integer> ref input, nothing [nogc]


FindSumTypeAndPrependTypesToList : list<SumType> ref sumtypes, integer sumtypeid, simplelist<integer> ref types [nogc]
{
	if(sumtypes.value.Type == sumtypeid)
	{
		PrependSumTypeBases(types, sumtypes.value.Bases)
	}
	else
	{
		FindSumTypeAndPrependTypesToList(sumtypes.next, sumtypeid, types)
	}
}


FindConstructorAndAddParameterTypes : list<StructureDefinition> ref structures, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> boolean hit = false
{
	integer membercount = structures.value.MemberCount

	if((structures.value.ConstructorName == funcname) && (paramcount == membercount + 1))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		else
		{
			FindMemberAndAddParameterTypes(structures.value.Members, paramindex - 1, types)
		}
		hit = true
	}
	elseif((structures.value.AnonConstructorName == funcname) && (paramcount == membercount))
	{
		FindMemberAndAddParameterTypes(structures.value.Members, paramindex, types)
		hit = true
	}
	elseif((toplevel) && (structures.value.CopyConstructorName == funcname) && (paramcount == 2))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		elseif(paramindex == 1)
		{
			simpleprepend<integer>(types, structures.value.Type)
		}
		hit = true
	}
	else
	{
		hit = FindConstructorAndAddParameterTypes(structures.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindConstructorAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> false


FindMemberAndAddParameterTypes : list<StructureMember> ref members, integer paramindex, simplelist<integer> ref types [nogc]
{
	if(paramindex == 0)
	{
		AddParameterTypesForMember(members.value, types)
	}
	else
	{
		FindMemberAndAddParameterTypes(members.next, paramindex - 1, types)
	}
}

FindMemberAndAddParameterTypes : nothing, integer paramindex, simplelist<integer> ref types [nogc]
{
	print("Too many arguments to constructor")
	assert(false)
}


AddParameterTypesForMember : StructureMemberVariable ref memvar, simplelist<integer> ref types [nogc]
{
	simpleprepend<integer>(types, memvar.Type)
}

AddParameterTypesForMember : StructureMemberFunctionRef ref memfunc, simplelist<integer> ref types [nogc]
{
	simpleprepend<integer>(types, GetMemberTypeDecompose(memfunc))
}


GetConstructorName : list<StructureDefinition> ref structures, integer typeid -> integer name = 0 [nogc]
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.ConstructorName
	}
	else
	{
		name = GetConstructorName(structures.next, typeid)
	}
}


StructureConstructorExists : list<StructureDefinition> ref structures, integer ctorname -> boolean exists = false [nogc]
{
	if(structures.value.ConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		exists = true
	}
	else
	{
		exists = StructureConstructorExists(structures.next, ctorname)
	}
}

StructureConstructorExists : nothing, integer ctorname -> false [nogc]


CoalesceMemberAccesses : list<ExpressionAtom> ref atoms, Scope ref scope
{
	while(SearchForMemberAccessStart(atoms, atoms.next, scope))
	{
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, list<ExpressionAtom> ref current, Scope ref scope -> boolean found = false
{
	if(IsMemberAccessOperator(current.value))
	{
		CoalesceMemberAccessTriplet(previous, current, current.next, scope)
		found = true
	}
	else
	{
		found = SearchForMemberAccessStart(current, current.next, scope)
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, nothing, Scope ref scope -> false


CoalesceMemberAccessTriplet : list<ExpressionAtom> ref lhs, list<ExpressionAtom> ref op, list<ExpressionAtom> ref rhs, Scope ref scope
{
	CoalesceMemberAccessAtoms(lhs, lhs.value, rhs.value, scope)
	lhs.next = rhs.next
}

CoalesceMemberAccessAtoms : list<ExpressionAtom> ref lhslist, ExpressionAtom ref lhs, ExpressionAtom ref rhs, Scope ref scope
{
	CoalesceMemberAccessAtomsUnwrapped(lhslist, lhs, rhs, scope)
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, IdentifierAtom ref lhs, IdentifierAtom ref rhs, Scope ref scope
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(scope, lhs.Handle, var)
	
	if(var.Name == 0)
	{
		print("Member access is bogus!")
		assert(false)
	}
	
	assert(var.VarType != 0)
	integer lhstypename = GetNameOfType(var.VarType)
	
	integer rhstype = GetStructureMemberType(lhstypename, rhs.Handle)
	assert(rhstype != 0)
	integer rhstypename = GetNameOfType(rhstype)

	RefBinding lhsbinding = lhs.Handle, lhstypename, false, false
	RefBinding rhsbinding = rhs.Handle, rhstypename, false, false

	list<RefBinding> bindings = rhsbinding, nothing
	prepend<RefBinding>(bindings, lhsbinding)
	
	CompoundAtom compound = bindings, rhstype
	ExpressionAtom wrap = compound
	lhslist.value = wrap
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, CompoundAtom ref lhs, IdentifierAtom ref rhs, Scope ref scope
{
	assert(lhs.Type != 0)
	integer typename = GetNameOfType(lhs.Type)
	
	RefBinding temp = rhs.Handle, typename, false, false
	AppendBinding(lhs.Bindings, lhs.Bindings.next, temp)

	lhs.Type = GetStructureMemberType(typename, rhs.Handle)
}

AppendBinding : list<RefBinding> ref bindings, list<RefBinding> ref tail, RefBinding ref binding [nogc]
{
	AppendBinding(tail, tail.next, binding)
}

AppendBinding : list<RefBinding> ref bindings, nothing, RefBinding ref binding [nogc]
{
	list<RefBinding> newtail = binding, nothing
	bindings.next = newtail
}


FindOrCreateTypeMatcher : integer rawname, integer overloadnamehandle, FunctionDefinition ref func -> integer matcherhandle = 0
{
	if(!func.IsTemplate)
	{
		string matchername = func.RawNameString ; "@@typematcher"
		matcherhandle = PoolString(matchername)

		EnsureMatcherIsPending(overloadnamehandle, matcherhandle, func)
	}
}

EnsureMatcherIsPending : integer overloadname, integer matcher, FunctionDefinition ref func [nogc]
{
	boolean found = SearchBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloadname)
	if(found)
	{
		return()
	}

	PendingTypeMatcher m = overloadname, matcher, func
	prepend<PendingTypeMatcher>(PendingTypeMatchers, m)
	InsertIntoBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloadname, m)
	InsertIntoBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matcher, m)
}

GetPendingTypeMatcherReturnType : integer matchername, ContextWrapper<PendingTypeMatcher> ref outcontext -> integer rettype = 0
{
	boolean found = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matchername, outcontext)
	if(found)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = InferFunctionReturnType(outcontext.Wrapped)
		return()
	}
	
	rettype = GetPendingPatternMatcherReturnType(PendingPatternMatchers, matchername)
}


GetPendingPatternMatcherReturnType : list<PendingPatternMatcher> ref pending, integer matchername -> integer rettype = 0
{
	if(pending.value.MatcherName == matchername)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = GetFunctionReturnType(Functions, pending.value.OverloadName)
		return()
	}
	
	rettype = GetPendingPatternMatcherReturnType(pending.next, matchername)
}

GetPendingPatternMatcherReturnType : nothing, integer matchername -> integer typeid = GetBuiltInReturnType(matchername)



GetBuiltInReturnType : integer builtinname -> integer returntype = 0
{
	if(StructureConstructorExists(Structures, builtinname))
	{
		returntype = GetStructureByAnonConstructorName(Structures, builtinname)
		return()
	}
	
	if(builtinname == PooledStringHandleForNarrowString)
	{
		returntype = 0x02000001		// buffer type signature
	}
	elseif(builtinname == PooledStringHandleForUnescape)
	{
		returntype = 0x02000000		// string type signature
	}	
	elseif(builtinname == PooledStringHandleForSubstringWithLength)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubstringNoLength)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubchar)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastRealToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastBooleanToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}	
	elseif(builtinname == PooledStringHandleForCastInteger16ToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastIntegerToInteger16)
	{
		returntype = 0x01000002		// integer16 type signature
	}
	elseif(builtinname == PooledStringHandleForCastIntegerToString)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCastRealToString)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCastStringToReal)
	{
		returntype = 0x01000004		// real type signature
	}
	elseif(builtinname == PooledStringHandleForCastStringToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForLength)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineGet)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForWidenFromPtr)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineGetCount)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineIsValid)
	{
		returntype = 0x01000003		// boolean type signature
	}
}


FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, nothing


FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, ExpressionList ref paramexprs
{
	FindConstructorAndAnnotateTypeMatchedParams(Structures, funcname, paramexprs.Expressions)
}

FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, list<Expression> ref paramexprs
{
	if(structures.value.ConstructorName == funcname)
	{
		listnode<Expression> ne = paramexprs.next
		AnnotateTypeMatchedParamsFromConstructor(structures.value.Members, ne)
	}
	else
	{
		FindConstructorAndAnnotateTypeMatchedParams(structures.next, funcname, paramexprs)
	}
}

FindConstructorAndAnnotateTypeMatchedParams : nothing, integer funcname, list<Expression> ref paramexprs
{
	if(FindSumTypeByName(SumTypes, funcname) != 0)
	{
		AnnotateNonReferenceParameters(paramexprs.next)
	}
}


AnnotateTypeMatchedParamsFromConstructor : list<StructureMember> ref members, list<Expression> ref paramexprs
{
	integer membertype = GetMemberTypeDecompose(members.value)
	if((membertype & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(paramexprs.value.Type) != MakeNonReferenceType(membertype))
		{
			AddTypeAnnotation(paramexprs.value)
		}
	}
	
	listnode<StructureMember> nm = members.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParamsFromConstructor(nm, ne)
}

AnnotateTypeMatchedParamsFromConstructor : nothing, nothing


AnnotateTypeMatchedParams : FunctionParams ref params, list<Expression> ref paramexprs
{
	AnnotateTypeMatchedParams(params.Params, paramexprs)
}

AnnotateTypeMatchedParams : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	if((params.value.ResolvedType & 0x7f000000) == 0x07000000)
	{
		AddTypeAnnotation(paramexprs.value)
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParams(np, ne)
}

AnnotateTypeMatchedParams : nothing, nothing


MakeParametersReferencesUnwrapFast : FunctionDefinition ref function, integer overloadname, ExpressionList ref params
{
	WalkFunctionParamsAndSetReferences(function.Params, params)
}

MakeParametersReferencesForTypeMatcherFast : PendingTypeMatcher ref pending, integer matchername, ExpressionList ref params
{
	if(pending.MatcherName == matchername)
	{
		MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)
	}
}

MakeParametersReferencesUnwrap : PendingTypeMatcher ref pending, ExpressionList ref params
{
	MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
}

MakeParametersReferencesForTypeMatcher : integer matchername, ExpressionList ref params
{
	ContextWrapper<PendingTypeMatcher> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matchername, wrap)
	if(found)
	{
		MakeParametersReferencesUnwrap(wrap.Wrapped, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)	
	}
}


MakeParametersReferencesForConstructor : list<StructureDefinition> ref structures, integer constructorname, ExpressionList ref params
{
	if(structures.value.ConstructorName == constructorname)
	{
		boolean ok = MakeParametersReferencesForStructureMembers(structures.value.Members, params.Expressions.next)
		if(!ok)
		{
			print("Failed to generate call to constructor " ; GetPooledString(GlobalStrings, constructorname))
			assert(false)
		}
	}
	else
	{
		MakeParametersReferencesForConstructor(structures.next, constructorname, params)
	}
}


MakeParametersReferencesForConstructor : nothing, integer constructorname, ExpressionList ref params
{
	MakeParametersReferencesForBuiltIn(constructorname, params)
}

MakeParametersReferencesForBuiltIn : integer funcname, ExpressionList ref params
{
	if(funcname == PooledStringHandleForWriteBuffer)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, list<Expression> ref params -> boolean ret = true
{
	if(IsMemberReferenceType(members.value))
	{
		if(!MarkAtomAsReference(params.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	
	ret = MakeParametersReferencesForStructureMembers(members.next, params.next)
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, nothing -> false
{
	if(GetMemberName(members.value) != 0)
	{
		print("Constructor has too few arguments!")
	}
}

MakeParametersReferencesForStructureMembers : nothing, list<Expression> ref params -> false
{
	print("Constructor has too many arguments!")
}

MakeParametersReferencesForStructureMembers : nothing, nothing -> true



IsMemberReferenceType : StructureMemberVariable ref memvar -> boolean isref = IsReferenceType(memvar.Type) [nogc]
IsMemberReferenceType : StructureMemberFunctionRef ref memfunc -> false [nogc]


WalkFunctionParamsAndSetReferencesShim : FunctionDefinition ref func, OptionalExpressionList ref optexprs
{
	WalkFunctionParamsAndSetReferences(func.Params, optexprs)
}

WalkFunctionParamsAndSetReferences : nothing, ExpressionList ref paramexprs

WalkFunctionParamsAndSetReferences : FunctionParams ref params, ExpressionList ref paramexprs
{
	WalkFunctionParamsAndSetReferencesUnwrapped(params.Params, paramexprs.Expressions)
}


WalkFunctionParamsAndSetReferencesUnwrapped : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	boolean needref = false
	if(IsReferenceType(params.value.ResolvedType))
	{
		needref = true
	}
	if(params.value.ResolvedType == 0x00000004)			// TODO - don't assume "nothing" is always passed by ref
	{
		needref = true
	}
	
	if(needref)
	{
		if(!MarkAtomAsReference(paramexprs.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	WalkFunctionParamsAndSetReferencesUnwrapped(np, ne)
}

WalkFunctionParamsAndSetReferencesUnwrapped : nothing, nothing


DemoteAtomType : list<ExpressionAtom> ref atoms [nogc]
{
	PerformDemotion(atoms, atoms.value)
}

PerformDemotion : list<ExpressionAtom> ref atoms, integer ref atom [nogc]
{
	integer16 newatom = cast(integer16, atom)
	ExpressionAtom wrap = newatom
	atoms.value = wrap
}

PerformDemotion : list<ExpressionAtom> ref atoms, IdentifierAtom ref atom [nogc]

PerformDemotion : list<ExpressionAtom> ref atoms, Statement ref atom [nogc]
{
	assertmsg(atom.Type == 0x01000002, "Failed to demote statement type")
}


DumpOverloadList : list<InferencePossibility> ref possibilities
{
	if(possibilities.value.FunctionName != 0)
	{
		print(GetPooledString(GlobalStrings, possibilities.value.FunctionName))
	}
	
	DumpOverloadList(possibilities.next)
}

DumpOverloadList : nothing



FilterOverloadsForTypeDemotion : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false
	
	CheckIfContainsOnlyDemotedOverloads(in, hasdemoted, hassuperior, hasother)
	
	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedOverloads(in, out)
	}
	else
	{
		out = in
	}
}


FilterTypesForDemotion : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false
	
	CheckIfContainsOnlyDemotedTypes(in, hasdemoted, hassuperior, hasother)
	
	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedTypes(in, out)
	}
	else
	{
		out = in
	}	
}


CheckIfContainsOnlyDemotedOverloads : list<InferencePossibility> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value == 0x01000001)
		{
			hassuperior = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0x01000002)
		{
			hasdemoted = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0)
		{
		}
		else
		{
			hasother = true
		}
	}
	
	CheckIfContainsOnlyDemotedOverloads(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedOverloads : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedOverloads : list<InferencePossibility> ref in, list<InferencePossibility> ref out [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value != 0x01000002)
		{
			prepend<InferencePossibility>(out, in.value)
		}
	}
	
	StripDemotedOverloads(in.next, out)
}

StripDemotedOverloads : nothing, list<InferencePossibility> ref out [nogc]



CheckIfContainsOnlyDemotedTypes : simplelist<integer> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value == 0x01000001)
	{
		hassuperior = true
	}
	elseif(in.value == 0x01000002)
	{
		hasdemoted = true
	}
	elseif(in.value == 0)
	{
	}
	else
	{
		hasother = true
	}
	
	CheckIfContainsOnlyDemotedTypes(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedTypes : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedTypes : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	if(in.value != 0)
	{
		if(in.value != 0x01000002)
		{
			simpleprepend<integer>(out, in.value)
		}
	}
	
	StripDemotedTypes(in.next, out)
}

StripDemotedTypes : nothing, simplelist<integer> ref out [nogc]


InitBuiltInOverloads : [nogc]
{
	Overload substrlength = PooledStringHandleForSubstring, PooledStringHandleForSubstringWithLength, nothing
	prepend<Overload>(AutoGenOverloads, substrlength)

	Overload substrnolen = PooledStringHandleForSubstring, PooledStringHandleForSubstringNoLength, nothing
	prepend<Overload>(AutoGenOverloads, substrnolen)
	
	Overload castrealtoint = PooledStringHandleForCast, PooledStringHandleForCastRealToInteger, nothing
	prepend<Overload>(AutoGenOverloads, castrealtoint)
	
	Overload castinttostr = PooledStringHandleForCast, PooledStringHandleForCastIntegerToString, nothing
	prepend<Overload>(AutoGenOverloads, castinttostr)
	
	Overload caststrtoint = PooledStringHandleForCast, PoolString("cast@@string_to_integer"), nothing
	prepend<Overload>(AutoGenOverloads, caststrtoint)

	Overload castrealtostr = PooledStringHandleForCast, PooledStringHandleForCastRealToString, nothing
	prepend<Overload>(AutoGenOverloads, castrealtostr)
	
	Overload castbooltoint = PooledStringHandleForCast, PooledStringHandleForCastBooleanToInteger, nothing
	prepend<Overload>(AutoGenOverloads, castbooltoint)

	Overload castint16toint = PooledStringHandleForCast, PoolString("cast@@integer16_to_integer"), nothing
	prepend<Overload>(AutoGenOverloads, castint16toint)
	
	Overload castinttoint16 = PooledStringHandleForCast, PoolString("cast@@integer_to_integer16"), nothing
	prepend<Overload>(AutoGenOverloads, castinttoint16)	

	Overload caststrtoreal = PooledStringHandleForCast, PooledStringHandleForCastStringToReal, nothing
	prepend<Overload>(AutoGenOverloads, caststrtoreal)	

	Overload writebuffernormal = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBuffer, nothing
	prepend<Overload>(AutoGenOverloads, writebuffernormal)

	Overload writebuffermultiple = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferMultiple, nothing
	prepend<Overload>(AutoGenOverloads, writebuffermultiple)

	Overload writebufferstring = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferString, nothing
	prepend<Overload>(AutoGenOverloads, writebufferstring)

	Overload writebufferreal = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferReal, nothing
	prepend<Overload>(AutoGenOverloads, writebufferreal)
}



CheckMemberTypes : list<StructureMember> ref members, simplelist<integer> ref types -> boolean match = true
{
	integer membertype = MakeNonReferenceType(GetMemberTypeDecompose(members.value))
	integer curtype = MakeNonReferenceType(types.value)

	if(membertype == curtype)
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	elseif(SumTypeHasBase(SumTypes, membertype, curtype))
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	else
	{
		match = false
	}
}

CheckMemberTypes : nothing, nothing -> true

CheckMemberTypes : list<StructureMember> ref members, nothing -> false

CheckMemberTypes : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}


GetStructureByAnonConstructorName : nothing, integer name -> 0 [nogc]

GetStructureByAnonConstructorName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0 [nogc]
{
	if(structures.value.AnonConstructorName == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureByAnonConstructorName(structures.next, name)
	}
}


stringcontains : string haystack, string needle -> boolean contains = false [nogc]
{
	integer needlelen = length(needle)
	integer haystacklen = length(haystack)
	
	integer index = 0
	while(index < (haystacklen - needlelen))
	{
		if(substring(haystack, index, needlelen) == needle)
		{
			contains = true
			return()
		}
		
		++index
	}
}


PrependFunctionParameter : list<FunctionDefinition> ref functions, integer funcname, integer paramname, integer paramtype
{
	if(functions.value.Name == funcname)
	{
		assert(paramtype != 0)
		UnresolvedParameter p = paramname, GetNameOfType(paramtype), paramtype, IsReferenceType(paramtype), nothing, nothing
		PrependUnresolvedParameter(functions.value.Params, p)
	}
	else
	{
		PrependFunctionParameter(functions.next, funcname, paramname, paramtype)
	}
}

PrependUnresolvedParameter : FunctionParams ref params, UnresolvedParameter ref p
{
	PrependUnresolvedParameter(params.Params, p)
}

PrependUnresolvedParameter : list<UnresolvedParameter> ref thelist, UnresolvedParameter ref p
{
	prepend<UnresolvedParameter>(thelist, p)
}

PrependUnresolvedParameter : nothing, UnresolvedParameter ref p
{
	print("Cannot set constructor tag on function with no parameters")
	assert(false)
}


GetSignatureReturnType : list<FunctionSignature> ref signatures, integer functype -> integer rettype = 0
{
	if(signatures.value.Name == functype)		// stupid overload of "name" to also mean "type"
	{
		rettype = GetTypeByName(signatures.value.ReturnTypeName)
	}
	else
	{
		rettype = GetSignatureReturnType(signatures.next, functype)
	}
}


FindOrCreateFunctionSignatureType : FunctionSignature ref signature -> integer typeid = 0
{
	typeid = FindMatchingSignature(FunctionSignatures, signature)
	if(typeid == 0)
	{
		FunctionSignature newsig = signature
		newsig.Name = (++GlobalFunctionTypeCounter)
		prepend<FunctionSignature>(FunctionSignatures, newsig)
		
		typeid = newsig.Name
	}
}

FindOrCreateFunctionSignatureType : simplelist<integer> ref paramtypenames, integer returntypename -> integer typeid = 0
{
	typeid = FindFunctionSignatureType(FunctionSignatures, paramtypenames, returntypename)
	if(typeid == 0)
	{
		OnCodeGenRegisterFunctionSig((++GlobalFunctionTypeCounter), returntypename)
		OnCodeGenRegisterFunctionSigParamList(paramtypenames)
		
		typeid = GlobalFunctionTypeCounter
	}
}

FindFunctionSignatureType : list<FunctionSignature> ref signatures, simplelist<integer> ref paramtypes, integer returntypename -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == returntypename)
	{
		if(SignatureMatchesParams(signatures.value.Parameters, paramtypes))
		{
			typeid = signatures.value.Name
			return()
		}
	}
	
	typeid = FindFunctionSignatureType(signatures.next, paramtypes, returntypename)
}

FindFunctionSignatureType : nothing, simplelist<integer> ref paramtypes, integer returntypename -> 0


SignatureMatchesParams : list<Parameter> ref params, simplelist<integer> ref paramtypes -> boolean match = true
{
	if(params.value.Name == 0)
	{
		match = SignatureMatchesParams(params.next, paramtypes)
	}
	elseif(paramtypes.value == 0)
	{
		match = SignatureMatchesParams(params, paramtypes.next)
	}
	elseif(params.value.Type != GetTypeByName(paramtypes.value))
	{
		match = false
	}
	else
	{
		match = SignatureMatchesParams(params.next, paramtypes.next)
	}
}

SignatureMatchesParams : nothing, simplelist<integer> ref paramtypes -> (paramtypes.value == 0)
SignatureMatchesParams : list<Parameter> ref params, nothing -> (params.value.Name == 0)

SignatureMatchesParams : nothing, nothing -> true


FindFunctionAndGetSignatureType : list<FunctionDefinition> ref functions, integer funcname -> integer typeid = 0
{
	if(functions.value.Name == funcname)
	{
		simplelist<integer> paramtypes = 0, nothing
		GetFunctionParameterTypes(functions.value.Params, paramtypes)
		
		integer rettypename = 0
		integer rettype = InferFunctionReturnType(functions.value)
		if(rettype != 0)
		{
			rettypename = GetNameOfType(rettype)
		}
		typeid = FindOrCreateFunctionSignatureType(paramtypes, rettypename)
	}
	else
	{
		typeid = FindFunctionAndGetSignatureType(functions.next, funcname)
	}
}


GetFunctionParameterTypes : FunctionParams ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.Params, outtypenames)
}

GetFunctionParameterTypes : list<UnresolvedParameter> ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.next, outtypenames)
	
	assert(params.value.ResolvedType != 0)
	
	simpleprepend<integer>(outtypenames, GetNameOfType(params.value.ResolvedType))
}

GetFunctionParameterTypes : nothing, simplelist<integer> ref outtypenames


FindMatchingSignature : list<FunctionSignature> ref signatures, FunctionSignature ref targetsig -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == targetsig.ReturnTypeName)
	{
		if(SignaturesMatch(signatures.value.Parameters, targetsig.Parameters))
		{
			typeid = signatures.value.Name
			return()
		}
	}
	
	typeid = FindMatchingSignature(signatures.next, targetsig)
}

FindMatchingSignature : nothing, FunctionSignature ref targetsig -> 0


SignaturesMatch : list<Parameter> ref a, list<Parameter> ref b -> boolean match = true
{
	if(a.value.Type != b.value.Type)
	{
		match = false
	}
	else
	{
		match = SignaturesMatch(a.next, b.next)
	}
}

SignaturesMatch : nothing, list<Parameter> ref b -> (b.value.Name == 0)
SignaturesMatch : list<Parameter> ref a, nothing -> (a.value.Name == 0)

SignaturesMatch : nothing, nothing -> true


DumpSignature : FunctionSignature ref sig
{
	print("  Function signature")
	DumpSignatureParams(sig.Parameters)
	print("  ->")
	if(sig.ReturnTypeName != 0)
	{
		print(GetPooledString(GlobalStrings, sig.ReturnTypeName))
	}
}

DumpSignatureParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		print(GetPooledString(GlobalStrings, GetNameOfType(params.value.Type)))
	}
	DumpSignatureParams(params.next)
}

DumpSignatureParams : nothing



ResolveSignatureTypes : FunctionSignature ref signature
{
	ResolveSignatureTypes(signature.Parameters)
}

ResolveSignatureTypes : list<Parameter> ref params
{
	params.value.Type = GetTypeByName(params.value.Type)
	ResolveSignatureTypes(params.next)
}

ResolveSignatureTypes : nothing



FindBuiltinAndGetSignatureType : integer builtinname -> integer typeid = 0
{
	if(builtinname == PooledStringHandleForPassTest)
	{
		simplelist<integer> paramtypes = 0, nothing
		typeid = FindOrCreateFunctionSignatureType(paramtypes, 0)
	}
}


FindPrePostOperatorOverload : integer operatorname, integer operandtype -> integer overloadname = 0 [nogc]
{
	if(operatorname == PooledStringHandleForPrePostIncrement)
	{
		if(operandtype == 0x01000001)
		{
			overloadname = PooledStringHandleForPrePostIncrementInteger
		}
	}
	elseif(operatorname == PooledStringHandleForPrePostDecrement)
	{
		if(operandtype == 0x01000001)
		{
			overloadname = PooledStringHandleForPrePostDecrementInteger
		}
	}
}

FindAssignmentOperator : integer operatorname, integer lhstype, integer rhstype -> integer overloadname = operatorname [nogc]
{
	lhstype = MakeNonReferenceType(lhstype)
	rhstype = MakeNonReferenceType(rhstype)

	if(operatorname == PooledStringHandleForIncrementAssign)
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = PooledStringHandleForIncrementAssignInteger
		}
	}
	elseif(operatorname == PooledStringHandleForDecrementAssign)
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = PooledStringHandleForDecrementAssignInteger
		}
	}
}


SetFunctionReturnType : FunctionDefinition ref func, integer funcname, integer rettype [nogc]
{
	SetOptionalExpressionType(func.Return, rettype)
}


SetOptionalExpressionType : Expression ref expr, integer typeid [nogc]
{
	expr.Type = typeid
}



CheckForNeededPatternMatcher : list<PendingPatternMatcher> ref patternmatchers, integer rawname -> integer matchername = 0 [nogc]
{
	if(patternmatchers.value.RawName == rawname)
	{
		matchername = patternmatchers.value.MatcherName
	}
	else
	{
		matchername = CheckForNeededPatternMatcher(patternmatchers.next, rawname)
	}
}

CheckForNeededPatternMatcher : nothing, integer rawname -> 0 [nogc]


EnsurePatternMatcherExists : list<PendingPatternMatcher> ref patternmatchers, integer rawname, integer mangledname
{
	if(patternmatchers.value.OverloadName == mangledname)
	{
		return()
	}
	
	EnsurePatternMatcherExists(patternmatchers.next, rawname, mangledname)
}

EnsurePatternMatcherExists : nothing, integer rawname, integer mangledname
{
	PendingPatternMatcher pm = rawname, mangledname, PoolStringFast(GetPooledString(GlobalStrings, rawname) ; "@@patternmatch")
	prepend<PendingPatternMatcher>(PendingPatternMatchers, pm)
}



CodeGenEmitPatternMatchers : list<PendingPatternMatcher> ref matchers
{
	if(!listcontains(EmittedPatternMatchers, matchers.value.MatcherName))
	{
		OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
		OnBytecodeEmitInteger(matchers.value.MatcherName)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(0)

		OnBytecodeEnterPatternResolver(matchers.value.MatcherName)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, true)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, false)
		OnBytecodeExitPatternResolver()
		
		simpleprepend<integer>(EmittedPatternMatchers, matchers.value.MatcherName)
	}
	
	CodeGenEmitPatternMatchers(matchers.next)
}

CodeGenEmitPatternMatchers : nothing


EmitOverloadsForPatternMatcher : list<PendingPatternMatcher> ref matchers, integer matchername, boolean preferliterals
{
	if(matchername == matchers.value.MatcherName)
	{
		// TODO - filter down to matchers that fit the most general function pattern
		
		EmitPatternMatchOverload(Functions, matchers.value.OverloadName, preferliterals)		
	}

	EmitOverloadsForPatternMatcher(matchers.next, matchername, preferliterals)
}

EmitOverloadsForPatternMatcher : nothing, integer matchername, boolean preferliterals



EmitPatternMatchOverload : list<FunctionDefinition> ref functions, integer overloadname, boolean preferliterals
{
	if(functions.value.Name == overloadname)
	{
		boolean hasliterals = FunctionSignatureHasLiterals(functions.value.Params)
		if(hasliterals && preferliterals)
		{
			EmitPatternMatchingForFunction(functions.value)
		}
		elseif((!hasliterals) && (!preferliterals))
		{
			EmitPatternMatchingForFunction(functions.value)
		}
	}
	else
	{
		EmitPatternMatchOverload(functions.next, overloadname, preferliterals)
	}
}


FunctionSignatureHasLiterals : FunctionParams ref params -> boolean hasliterals = FunctionSignatureHasLiterals(params.Params) [nogc]

FunctionSignatureHasLiterals : list<UnresolvedParameter> ref params -> boolean hasliterals = false [nogc]
{
	integer exprtype = GetOptionalExpressionType(params.value.PatternMatchValue)
	if((exprtype != 0) && (exprtype != 0x00000002))
	{
		hasliterals = true
		return()
	}

	if(FunctionSignatureHasLiterals(params.next))
	{
		hasliterals = true
	}
}

FunctionSignatureHasLiterals : nothing -> false [nogc]



EmitPatternMatchingForFunction : FunctionDefinition ref function
{
	OnBytecodeEmitByte(0x12)			// PatternMatch instruction
	OnBytecodeEmitInteger(function.Name)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitInteger(CountUnresolvedParameters(function.Params))
	EmitPatternMatchingForParameters(function.Params)
}

EmitPatternMatchingForParameters : FunctionParams ref params
{
	EmitPatternMatchingForParameters(params.Params)
}

EmitPatternMatchingForParameters : list<UnresolvedParameter> ref params
{
	integer parampatterntype = GetOptionalExpressionType(params.value.PatternMatchValue)
	OnBytecodeEmitInteger(MakeNonReferenceType(parampatterntype))

	if(parampatterntype != 0)
	{
		OnBytecodeEmitBoolean(true)
		EmitPatternMatchLiteral(params.value.PatternMatchValue)
	}
	else
	{
		OnBytecodeEmitBoolean(false)
	}

	EmitPatternMatchingForParameters(params.next)
}

EmitPatternMatchingForParameters : nothing


EmitPatternMatchLiteral : Expression ref expr
{
	EmitPatternMatchLiteralAtom(expr.Atoms.value)
}

EmitPatternMatchLiteralAtom : integer value
{
	OnBytecodeEmitInteger(value)
}


PatternMatcherExists : nothing, integer matchername -> false

PatternMatcherExists : list<PendingPatternMatcher> ref matchers, integer matchername -> boolean exists = false
{
	if(matchers.value.MatcherName == matchername)
	{
		exists = true
	}
	else
	{
		exists = PatternMatcherExists(matchers.next, matchername)
	}
}



GetCastOverload : nothing -> 0

GetCastOverload : ExpressionList ref params -> integer overloadname = FigureOutCastOverload(params.Expressions)


FigureOutCastOverload : list<Expression> ref params -> integer overloadname = 0
{
	integer idtype = GetTypeByName(GetIdentifier(params.value.Atoms.value))
	if(idtype != 0)
	{
		integer origintype = FigureOutCastOriginType(params.next)
		
		if((idtype == 0x01000001) && (origintype == 0x01000004))
		{
			overloadname = PooledStringHandleForCastRealToInteger
		}
		elseif((idtype == 0x02000000) && (origintype == 0x01000001))
		{
			overloadname = PooledStringHandleForCastIntegerToString
		}
		elseif((idtype == 0x02000000) && (origintype == 0x01000004))
		{
			overloadname = PooledStringHandleForCastRealToString
		}		
		elseif((idtype == 0x01000001) && (origintype == 0x01000002))
		{
			overloadname = PooledStringHandleForCastInteger16ToInteger
		}
		elseif((idtype == 0x01000002) && (origintype == 0x01000001))
		{
			overloadname = PooledStringHandleForCastIntegerToInteger16
		}		
		elseif((idtype == 0x01000001) && (origintype == 0x01000003))
		{
			overloadname = PooledStringHandleForCastBooleanToInteger
		}
		elseif((idtype == 0x01000004) && (origintype == 0x02000000))
		{
			overloadname = PooledStringHandleForCastStringToReal
		}
		elseif((idtype == 0x01000001) && (origintype == 0x02000000))
		{
			overloadname = PooledStringHandleForCastStringToInteger
		}
	}
}

FigureOutCastOverload : nothing -> 0



FigureOutCastOriginType : list<Expression> ref params -> integer origintype = params.value.Type [nogc]

FigureOutCastOriginType : nothing -> 0 [nogc]


GetIdentifier : IdentifierAtom ref atom -> atom.Handle [nogc]



IRRegisterTemplateParameter : integer paramtype, integer paramname [nogc]
{
	TemplateParameter p = paramname, paramtype
	prepend<TemplateParameter>(TemplateParameterQueue, p)
}


CreateFunctionTemplateAndAttachParams : integer funcname, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateFunction templfunc = funcname, dummyparams
	prepend<TemplateFunction>(TemplateFunctions, templfunc)
}


CreateStructureTemplateAndAttachParams : integer structurename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateStructure templstructure = structurename, dummyparams
	prepend<TemplateStructure>(TemplateStructures, templstructure)
}


CreateSumTypeTemplateAndAttachParams : integer typename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateSumType templtype = typename, dummyparams
	prepend<TemplateSumType>(TemplateSumTypes, templtype)
}



TransferTemplateParamsFromQueue : list<TemplateParameter> ref out, list<TemplateParameter> ref queue
{
	if(queue.value.ParamType != 0)
	{
		TransferTemplateParamsFromQueue(out, queue.next)

		if(out.value.ParamType == 0)
		{
			out.value = queue.value
		}
		else
		{
			prepend<TemplateParameter>(out, queue.value)
		}
	}
}



PopTemplateArgStack : list<TemplateArgumentList> ref stack, list<TemplateArgumentList> ref next [nogc]
{
	stack = next
}

PopTemplateArgList : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail [nogc]
{
	thelist = tail
}


AppendTemplateArgument : list<TemplateArgument> ref thelist, TemplateArgument ref arg [nogc]
{
	AppendTemplateArgumentRecurse(thelist, thelist.next, arg)
}


AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, nothing, TemplateArgument ref arg [nogc]
{
	list<TemplateArgument> newlist = arg, nothing
	thelist.next = newlist
}

AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail, TemplateArgument ref arg [nogc]
{
	AppendTemplateArgumentRecurse(tail, tail.next, arg)
}



InstantiateFunctionTemplate : integer templatename, nothing -> templatename

InstantiateFunctionTemplate : integer templatename, TemplateArgumentList ref args -> integer instancename = templatename
{
	integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, templatename, args.Args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}
	
	instancename = FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, templatename, args.Args)
	
	ContextWrapper<FunctionDefinition> wrap = nothing
	while(PopPendingFunctionForInference(wrap))
	{
		TypeInference(wrap.Wrapped, DummyContextForFunctions)
	}
}


EnumerateOverloadsAndInstantiate : list<Overload> ref overloads, integer templatename, list<TemplateArgument> ref args
{
	if(overloads.value.NormalName == templatename)
	{
		integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, overloads.value.MangledName, args)
		if(existing == 0)
		{
			FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, overloads.value.MangledName, args)
		}
	}
	
	EnumerateOverloadsAndInstantiate(overloads.next, templatename, args)
}

EnumerateOverloadsAndInstantiate : nothing, integer templatename, list<TemplateArgument> ref args


FindFunctionTemplateAndInstantiate : list<TemplateFunction> ref templates, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.FunctionDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = RegisterOverloadForFunction(mangledname, PoolString(mangledname))
		
		// TODO - validate that args suit the formal template parameters!
		
		string basenamemangled = MangleTemplateName(basename, args)
		integer bnmh = PoolString(basenamemangled)
		Overload overload = bnmh, instancename, nothing
		prepend<Overload>(Overloads, overload)
		FindFunctionAndAddOverload(overload)
		
		DoFunctionInstantiation(bnmh, defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindFunctionTemplateAndInstantiate(templates.next, basename, defname, args)
	}
}


FindStructureTemplateAndInstantiate : list<TemplateStructure> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.StructureDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)
		
		// TODO - validate that args suit the formal template parameters!
		
		DoStructureInstantiation(defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindStructureTemplateAndInstantiate(templates.next, defname, args)
	}
}

FindStructureTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateSumType(defname, args)


InstantiateSumType : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateSumTypeInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}
	
	instancename = FindSumTypeTemplateAndInstantiate(TemplateSumTypes, defname, args)
}

FindSumTypeTemplateAndInstantiate : list<TemplateSumType> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.SumTypeName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)
		
		// TODO - validate that args suit the formal template parameters!

		DoSumTypeInstantiation(SumTypes, defname, instancename, templates.value.Parameters, args)		
	}
	else
	{
		instancename = FindSumTypeTemplateAndInstantiate(templates.next, defname, args)
	}
}


FindSumTypeTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer t = GetTypeByName(defname)
	if(t != 0)
	{
		instancename = defname
		return()
	}

	string namestr = GetPooledString(GlobalStrings, defname)
	print("Error - no template provided for '" ; namestr ; "', cannot create instance!")
}


DoStructureInstantiation : integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	ContextWrapper<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, defname, wrap)
	assert(found)

	StructInstInner(wrap.Wrapped, defname, instancename, params, args)
}

StructInstInner : StructureDefinition ref templstruct, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	assert(templstruct.IsTemplate)
	
	++GlobalTemplateInstanceCounter
	
	list<StructureMember> members = dummymember, nothing
	DoMemberListInstantiation(templstruct.Members, members, params, args)
	PopMember(members, members.next)
	
	StructureDefinition struct = instancename, GlobalTemplateInstanceCounter, 0, 0, 0, members, templstruct.MemberCount, GetPooledString(GlobalStrings, instancename), false
	prepend<StructureDefinition>(Structures, struct)
	InsertIntoBinaryTree<StructureDefinition>(StructuresWhichExist, instancename, struct)

	TemplateInstance instance = defname, instancename, args
	prepend<TemplateInstance>(TemplateStructureInstances, instance)

	TypeInference(Structures.value, DummyContextForFunctions)
}


DoSumTypeInstantiation : list<SumType> ref sumtypes, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(sumtypes.value.Name == defname)
	{
		assert(sumtypes.value.IsTemplate)
		
		++GlobalSumTypeCounter
		
		list<SumTypeBase> bases = dummybasetype, nothing
		DoBaseTypeInstantiation(sumtypes.value.Bases, bases, params, args)
		
		SumType st = instancename, GlobalSumTypeCounter, bases, false
		prepend<SumType>(SumTypes, st)

		TemplateInstance instance = defname, instancename, args
		prepend<TemplateInstance>(TemplateSumTypeInstances, instance)

		ResolveSumTypeBases(SumTypes.value.Bases)
	}
	else
	{
		DoSumTypeInstantiation(sumtypes.next, defname, instancename, params, args)
	}
}

PopMember : list<StructureMember> ref members, list<StructureMember> ref tail [nogc]
{
	members = tail
}

DoMemberListInstantiation : list<StructureMember> ref members, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	DoMemberInstantiation(members.value, out, params, args)	
	DoMemberListInstantiation(members.next, out, params, args)
}

DoMemberListInstantiation : nothing, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args

DoMemberInstantiation : StructureMemberVariable ref memvar, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(memvar.Name != 0)
	{	
		integer newtype = MapTemplateType(memvar.TypeNameHandle, params, args)
		
		StructureMemberVariable newmemvar = memvar.Name, 0, newtype, scratchtemplatearglist
		CopyTemplateArgs(memvar.TemplateArgs, newmemvar.TemplateArgs)
		RemapAllTemplateArguments(newmemvar.TemplateArgs, params, args)
		StructureMember newmember = newmemvar
		AppendStructureMember(out, out.next, newmember)
	}
}

CopyTemplateArgs : TemplateArgumentList ref in, TemplateArgumentList ref out [nogc]
{
	TemplateArgumentList copy = in
	out = copy
}

CopyTemplateArgs : nothing, TemplateArgumentList ref out [nogc]

DoBaseTypeInstantiation : list<SumTypeBase> ref bases, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	InstantiateBaseType(bases.value, out, params, args)	
	DoBaseTypeInstantiation(bases.next, out, params, args)
}

DoBaseTypeInstantiation : nothing, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args


InstantiateBaseType : SumTypeBase ref in, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(in.Name != 0)
	{
		integer newtype = MapTemplateType(in.Name, params, args)
		
		SumTypeBase newbase = newtype, scratchtemplatearglist
		CopyTemplateArgs(in.TemplateArgs, newbase.TemplateArgs)
		RemapAllTemplateArguments(newbase.TemplateArgs, params, args)
		prepend<SumTypeBase>(out, newbase)
	}
}

RemapAllTemplateArguments : TemplateArgumentList ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	RemapAllTemplateArguments(toremap.Args, params, args)
}

RemapAllTemplateArguments : list<TemplateArgument> ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(toremap.value.ReplaceWith != 0)
	{
		toremap.value.ReplaceWith = MapTemplateType(toremap.value.ReplaceWith, params, args)
		toremap.value.ReplaceWithString = GetPooledString(GlobalStrings, toremap.value.ReplaceWith)
	}
	
	RemapAllTemplateArguments(toremap.next, params, args)
}

RemapAllTemplateArguments : nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args


DoFunctionInstantiation : integer basenamemangled, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	ContextWrapper<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, defname, wrap)
	assert(found)
	
	FunctionInstantiationInner(wrap.Wrapped, basenamemangled, defname, instancename, params, args)
	EnumerateOverloadsAndInstantiate(wrap.Wrapped, defname, args)
}

EnumerateOverloadsAndInstantiate : FunctionDefinition ref func, integer templatename, list<TemplateArgument> ref args
{
	EnumerateOverloadsAndInstantiate(func.Overloads, templatename, args)
}

FunctionInstantiationInner : FunctionDefinition ref originalfunc, integer basenamemangled, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(!originalfunc.IsTemplate)
	{
		print("Function is not template: " ; GetPooledString(GlobalStrings, defname))
		assert(false)
	}
	
	TemplateInstance inst = defname, instancename, args
	prepend<TemplateInstance>(TemplateFunctionInstances, inst)
	
	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = basenamemangled, instancename, nothing, nothing, nothing, originalfunc.Overloads, scopewrap, GetPooledString(GlobalStrings, basenamemangled), 0, false, false, originalfunc.AnonymousReturn
	prepend<FunctionDefinition>(Functions, func)
	InsertIntoBinaryTree<FunctionDefinition>(FunctionsWhichExist, instancename, func)
	
	Overload selfoverload = instancename, instancename, func
	prepend<Overload>(func.Overloads, selfoverload)
	
	AttachContextToOverload(func.Overloads, instancename, func)
	AttachContextToOverload(Overloads, instancename, func)
		
	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack
	
	DoParameterInstantiation(originalfunc.Params, params, args)
	DoReturnInstantiation(originalfunc.Return, instancename, originalfunc.AnonymousReturn, params, args)

	// TODO - traverse template and instantiate the following stuff
	//ParseFunctionTags(namehandle, rawnamehandle)

	IREnterFunction(instancename)
	Functions.value.AttachedScope.Wrapped = Scopes.value
	OnCodeGenEnterFunctionBody(instancename)

	DoCodeBlockInstantiation(originalfunc.Code, params, args)
	
	IRExitFunction()
	
	PushPendingFunctionForInference(func)
}


DoParameterInstantiation : FunctionParams ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	DoParameterInstantiation(params.Params, templateparams, templateargs)
}

DoParameterInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoParameterInstantiation : list<UnresolvedParameter> ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer newtype = MapTemplateType(params.value.TypeNameHandle, templateparams, templateargs)
	integer resolvedtype = params.value.ResolvedType
	
	if((resolvedtype & 0x7f000000) == 0x09000000)
	{
		resolvedtype = InstantiateFunctionSignature(FunctionSignatures, resolvedtype, templateparams, templateargs)
		newtype = GetNameOfType(resolvedtype)
	}
	
	UnresolvedParameter p = params.value.NameHandle, newtype, resolvedtype, params.value.HasRefTag, params.value.PatternMatchValue, nothing
	PropagateTemplateArgsForParameter(p, params.value.TemplateArgs, templateparams, templateargs)
	
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)

	DoParameterInstantiation(params.next, templateparams, templateargs)
}

InstantiateFunctionSignature : list<FunctionSignature> ref sigs, integer targettype, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs -> integer ret = 0
{
	if(sigs.value.Name == targettype)
	{
		FunctionSignature clone = sigs.value
		clone.ReturnTypeName = MapTemplateType(clone.ReturnTypeName, templateparams, templateargs)
		RemapSignatureParamTypes(clone.Parameters, templateparams, templateargs)
		
		ret = FindOrCreateFunctionSignatureType(clone)
	}
	else
	{
		ret = InstantiateFunctionSignature(sigs.next, targettype, templateparams, templateargs)
	}
}

RemapSignatureParamTypes : list<Parameter> ref parameters, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	parameters.value.Type = GetTypeByName(MapTemplateType(parameters.value.Type, templateparams, templateargs))	
	RemapSignatureParamTypes(parameters.next, templateparams, templateargs)
}

RemapSignatureParamTypes : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs


PropagateTemplateArgsForParameter : UnresolvedParameter ref p, TemplateArgumentList ref check, list<TemplateParameter> ref params, list<TemplateArgument> ref args [nogc]
{
	TemplateArgumentList wrap = args
	RemapAllTemplateArguments(wrap, params, args)
	p.TemplateArgs = wrap
}

PropagateTemplateArgsForParameter : UnresolvedParameter ref p, nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args [nogc]


DoReturnInstantiation : Expression ref retexpr, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterFunctionReturn(funcname, anonymous)
	InstantiateExpression(retexpr, true, templateparams, templateargs)
	OnCodeGenExitContext()
}

DoReturnInstantiation : nothing, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs


MapTemplateType : integer typenamehandle, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs -> integer newtypename = typenamehandle [nogc]
{
	if(templateparams.value.ParamName == typenamehandle)
	{
		newtypename = templateargs.value.ReplaceWith
	}
	else
	{
		newtypename = MapTemplateType(typenamehandle, templateparams.next, templateargs.next)
	}
}

MapTemplateType : integer typenamehandle, nothing, nothing -> typenamehandle [nogc]


MangleTemplateNameByHandle : integer defname, nothing -> integer mangled = defname [nogc]

MangleTemplateNameByHandle : integer defname, TemplateArgumentList ref args -> integer mangled = PoolString(MangleTemplateName(defname, args.Args)) [nogc]


MangleTemplateName : integer defname, list<TemplateArgument> ref args -> string mangled = GetPooledString(GlobalStrings, defname) ; "@@templateinst@" [nogc]
{
	mangled = mangled ; MangleTemplateArguments(args)
}

MangleTemplateArguments : list<TemplateArgument> ref args -> string mangled = args.value.ReplaceWithString [nogc]
{
	mangled = mangled ; MangleTemplateArguments(args.next)
}

MangleTemplateArguments : nothing -> "" [nogc]


FindFunctionTemplateAndInstantiate : nothing, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateStructureTemplate(defname, args)


InstantiateStructureTemplate : integer defname, TemplateArgumentList ref args -> integer instancename = InstantiateStructureTemplate(defname, args.Args)

InstantiateStructureTemplate : integer defname, nothing -> integer instancename = 0

InstantiateStructureTemplate : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateStructureInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}
	
	instancename = FindStructureTemplateAndInstantiate(TemplateStructures, defname, args)
}


FindExistingTemplateInstance : list<TemplateInstance> ref instances, integer defname, list<TemplateArgument> ref args -> integer instancename = 0 [nogc]
{
	if(instances.value.DefName == defname)
	{
		if(TemplateArgumentsMatch(instances.value.Arguments, args))
		{
			instancename = instances.value.InstanceName
			return()
		}
	}
	
	instancename = FindExistingTemplateInstance(instances.next, defname, args)
}

FindExistingTemplateInstance : nothing, integer defname, list<TemplateArgument> ref args -> 0 [nogc]



TemplateArgumentsMatch : list<TemplateArgument> ref a, list<TemplateArgument> ref b -> boolean match = true [nogc]
{
	if(a.value.ReplaceWith != b.value.ReplaceWith)
	{
		match = false
	}
	else
	{
		match = TemplateArgumentsMatch(a.next, b.next)
	}
}

TemplateArgumentsMatch : nothing, list<TemplateArgument> ref b -> false [nogc]
TemplateArgumentsMatch : list<TemplateArgument> ref a, nothing -> false [nogc]
TemplateArgumentsMatch : nothing, nothing -> true [nogc]



InstantiateExpression : Expression ref expr, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateAtoms(expr.Atoms, inret, templateparams, templateargs)
}

InstantiateExpression : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

InstantiateAtoms : list<ExpressionAtom> ref atoms, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateSingleAtom(atoms.value, inret, templateparams, templateargs)
	InstantiateAtoms(atoms.next, inret, templateparams, templateargs)
}

InstantiateAtoms : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support ALL atom types (parenthetical should be the only one left)
InstantiateSingleAtom : IdentifierAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterAtomIdentifier(atom.Handle, 0)
}

InstantiateSingleAtom : OperatorInvokeAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterOperatorInvoke(atom.OperatorName)
}

InstantiateSingleAtom : Statement ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer statementname = MapTemplateType(atom.Name, templateparams, templateargs)

	OnCodeGenEnterSubStatement()
	InstantiateStatement(statementname, inret, atom.TemplateArgs, templateparams, templateargs)

	InstantiateExpressionList(atom.Parameters, false, templateparams, templateargs, 0)
	
	IRExitStatement()
	IRExitStatement()
}


InstantiateSingleAtom : AtomSentinel ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

InstantiateSingleAtom : boolean ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralBoolean(atom)
}

InstantiateSingleAtom : StringHandleAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralString(atom.Handle)
}

InstantiateSingleAtom : integer ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralInteger(atom, 0x01000001)
}

InstantiateSingleAtom : integer16 ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralInteger(cast(integer, atom), 0x01000002)
}

InstantiateSingleAtom : real ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralReal(atom)
}


InstantiateStatement : integer statementname, boolean inret, nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterStatement(statementname, 0, inret, false)
}

InstantiateStatement : integer statementname, boolean inret, TemplateArgumentList ref args, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	Statement statement = statementname, nothing, 0, args, inret, false
	PropagateTemplateArgsForStatement(statement, args, templateargs)
	RemapAllTemplateArguments(statement.TemplateArgs, templateparams, templateargs)
	OnCodeGenEmplaceStatement(statement)
}

PropagateTemplateArgsForStatement : Statement ref s, TemplateArgumentList ref check, list<TemplateArgument> ref args
{
	TemplateArgumentList wrap = args
	s.TemplateArgs = wrap
}

PropagateTemplateArgsForStatement : Statement ref s, nothing, list<TemplateArgument> ref args


InstantiateExpressionList : ExpressionList ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	InstantiateExpressionList(exprs.Expressions, inret, templateparams, templateargs, count)
}

InstantiateExpressionList : list<Expression> ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	if(count != 0)
	{
		OnCodeGenShiftParameter()
	}

	InstantiateExpression(exprs.value, inret, templateparams, templateargs)
	InstantiateExpressionList(exprs.next, inret, templateparams, templateargs, count + 1)
}

InstantiateExpressionList : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count


DoCodeBlockInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoCodeBlockInstantiation : CodeBlock ref code, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntries(code.Entries, templateparams, templateargs)
}

InstantiateCodeBlockEntries : list<CodeBlockEntry> ref entries, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntry(entries.value, templateparams, templateargs)
	InstantiateCodeBlockEntries(entries.next, templateparams, templateargs)
}

InstantiateCodeBlockEntries : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support all code block entry types
InstantiateCodeBlockEntry : Statement ref s, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateStatement(s.Name, true, s.TemplateArgs, templateparams, templateargs)
	InstantiateExpressionList(s.Parameters, false, templateparams, templateargs, 0)
	
	IRExitStatement()
}

InstantiateCodeBlockEntry : Assignment ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support
	
	OnCodeGenEnterAssignment(a.Operator, a.LHSName, 0, 0)
	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCodeBlockEntry : AssignmentCompound ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support
	
	OnCodeGenEnterAssignmentCompound(a.Operator, a.LHS.value, 0, 0)
	InstantiateCompoundAssignmentLHS(a.LHS.next)
	OnCodeGenAssignmentCompoundEnd()

	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCompoundAssignmentLHS : simplelist<integer> ref lhs
{
	FindCurrentFunctionAndAppendCompoundMember(lhs.value)
	InstantiateCompoundAssignmentLHS(lhs.next)
}

InstantiateCompoundAssignmentLHS : nothing


InstantiateCodeBlockEntry : EntityChain ref chain, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterChain()
	InstantiateEntityChainEntries(chain.Entries, templateparams, templateargs)		
	OnCodeGenExitContext()
}

InstantiateEntityChainEntries : EntityList ref entities, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateEntityChainEntries(entities.ActualList, templateparams, templateargs)
}

InstantiateEntityChainEntries : list<Entity> ref entities, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterEntity(entities.value.Tag, entities.value.PostfixTag)
	InstantiateExpression(entities.value.Param, false, templateparams, templateargs)
	OnCodeGenEnterEntityCode()
	DoCodeBlockInstantiation(entities.value.Code, templateparams, templateargs)
	OnCodeGenExitContext()
	OnCodeGenExitContext()
	
	InstantiateEntityChainEntries(entities.next, templateparams, templateargs)
}

InstantiateEntityChainEntries : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs




SetStructureToTemplate : integer name
{
	ContextWrapper<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, name, wrap)
	assert(found)

	SetStructureToTemplate(wrap.Wrapped)
}

SetStructureToTemplate : StructureDefinition ref struct
{
	struct.IsTemplate = true

	CreateStructureTemplateAndAttachParams(struct.Name, TemplateParameterQueue)
	
	// Reset template parameter queue
	list<TemplateParameter> dummylist = scratchtemplateparam, nothing
	TemplateParameterQueue = dummylist
}


structure tailhack :
	simplelistnode<string> tail
	

	
PopPendingFunctionForInference : ContextWrapper<FunctionDefinition> ref out -> boolean hasnode = false
{
	hasnode = PopPendingFunctionForInferenceWorker(PendingInferenceFunctions, PendingInferenceFunctions.next, out)
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, list<FunctionDefinition> ref tail, ContextWrapper<FunctionDefinition> ref out -> boolean hasnode = false
{
	if(head.value.Name != 0)
	{
		out.Wrapped = head.value
		head = tail
		hasnode = true
	}
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, nothing, ContextWrapper<FunctionDefinition> ref out -> boolean hasnode = false
{
	assert(head.value.Name == 0)
}
	
PushPendingFunctionForInference : FunctionDefinition ref func
{
	prepend<FunctionDefinition>(PendingInferenceFunctions, func)
}
	
	
	
//
// EXE generation stuff
//

RoundUp : integer in -> integer out = ((in / 0x1000) + 1) * 0x1000			// TODO - this over-estimates if in is a perfect multiple of 0x1000

WriteFile : integer handle, buffer ref data, integer numbytes, integer ref written, integer ignored2 -> boolean ret = false [external("Kernel32.dll", "WriteFile", "stdcall")]

MakeExe : string filename
{
	integer imagesize = 0x5000 + RoundUp(HackSize)
	integer resourcesize = 0


	integer GENERIC_WRITE = 0x40000000
	integer CREATE_ALWAYS = 2

	integer filehandle = CreateFile(filename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0)
	if(filehandle == 0)
	{
		print("Cannot open " ; filename ; " to emit .EXE!")
		return()
	}


	integer position = 0
	position += WritePEHeader(filehandle, imagesize, resourcesize)
	
	position += WriteSectionHeader(filehandle, ".idata", 0x400, 0x1000, 0x344, 0x400, 0xc0000040)
	position += WriteSectionHeader(filehandle, ".text", 0x800, 0x2000, 0x150, 0x200, 0x60000020)
	position += WriteSectionHeader(filehandle, ".data", 0xa00, 0x3000, 0x29e, 0x400, 0x40000040)
	position += WriteSectionHeader(filehandle, ".rsrc", 0xe00, 0x4000, 0x10, 0x10, 0x40000040)
	position += WriteSectionHeader(filehandle, ".epoch", 0x1000, 0x5000, HackSize, HackSize, 0x40000040)
	
	print("Writing thunk table...")
	position += WritePadding(filehandle, position, 0x400)
	position += WriteThunkTable(filehandle)
	position += WritePadding(filehandle, position, 0x600)
	position += WriteThunkAddresses(filehandle)
	
	print("Writing bootstrap code...")
	position += WritePadding(filehandle, position, 0x800)
	position += WriteBootstrapCode(filehandle)

	position += WritePadding(filehandle, position, 0xa00)
	position += WriteStringTable(filehandle)
	
	position += WritePadding(filehandle, position, 0xe00)
	// TODO - emit resources
		
	// Output the Epoch bytecode section
	position += WritePadding(filehandle, position, 0x1000)
	print("Writing Epoch code block...")
	integer written = 0
	WriteFile(filehandle, Hack, HackSize, written, 0)

	CloseHandle(filehandle)
	
	print("Compilation complete.")
}


WriteStringTable : integer filehandle -> integer writtenbytes = 0
{
	buffer tablebuffer = 1024
	integer tablesize = 0
	
	
	EmitInteger(tablebuffer, tablesize, 0x63657845)
	EmitInteger(tablebuffer, tablesize, 0x42657475)
	EmitInteger(tablebuffer, tablesize, 0x43657479)
	EmitInteger(tablebuffer, tablesize, 0x0065646f)
	
	EmitInteger(tablebuffer, tablesize, 0x00700065)
	EmitInteger(tablebuffer, tablesize, 0x0063006f)
	EmitInteger(tablebuffer, tablesize, 0x00720068)
	EmitInteger(tablebuffer, tablesize, 0x006e0075)
	EmitInteger(tablebuffer, tablesize, 0x00690074)
	EmitInteger(tablebuffer, tablesize, 0x0065006d)
	EmitInteger(tablebuffer, tablesize, 0x0064002e)
	EmitInteger(tablebuffer, tablesize, 0x006c006c)
	EmitInteger16(tablebuffer, tablesize, 0x0000)
	
	// TODO - embed error strings
	
	
	integer written = 0
	WriteFile(filehandle, tablebuffer, tablesize, written, 0)
	
	writtenbytes = tablesize	
}


WriteThunkAddresses : integer filehandle -> integer writtenbytes = 0
{
	buffer thunkbuffer = 1024
	integer thunksize = 0
	
	
	EmitInteger(thunkbuffer, thunksize, 0x000010bc)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x00001096)
	EmitInteger(thunkbuffer, thunksize, 0x000010ec)
	EmitInteger(thunkbuffer, thunksize, 0x000010e4)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	EmitInteger(thunkbuffer, thunksize, 0x000010b1)
	EmitInteger(thunkbuffer, thunksize, 0x00001114)
	
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)
	
	writtenbytes = thunksize
}


WriteBootstrapCode : integer filehandle -> integer writtenbytes = 0
{
	buffer codebuffer = 1024
	integer codesize = 0
	
	EmitInteger(codebuffer, codesize, 0x81ec8b55)
	EmitInteger(codebuffer, codesize, 0x000404ec)
	EmitInteger(codebuffer, codesize, 0x10685600)
	EmitInteger(codebuffer, codesize, 0xff004030)
	EmitInteger(codebuffer, codesize, 0x40110415)
	EmitInteger(codebuffer, codesize, 0x3bf63300)
	EmitInteger(codebuffer, codesize, 0x6a1a75c6)
	EmitInteger(codebuffer, codesize, 0x30326810)
	EmitInteger(codebuffer, codesize, 0x52680040)
	EmitInteger(codebuffer, codesize, 0x56004030)
	EmitInteger(codebuffer, codesize, 0x111415ff)
	EmitInteger(codebuffer, codesize, 0xc0330040)
	EmitInteger(codebuffer, codesize, 0x00008be9)
	EmitInteger(codebuffer, codesize, 0x30006800)
	EmitInteger(codebuffer, codesize, 0xff500040)
	EmitInteger(codebuffer, codesize, 0x40110015)
	EmitInteger(codebuffer, codesize, 0xfc458900)
	EmitInteger(codebuffer, codesize, 0x0e75c63b)
	EmitInteger(codebuffer, codesize, 0x3268106a)
	EmitInteger(codebuffer, codesize, 0x68004030)
	EmitInteger(codebuffer, codesize, 0x004030e8)
	EmitInteger(codebuffer, codesize, 0x6853d1eb)
	EmitInteger(codebuffer, codesize, 0x000001ff)
	EmitInteger(codebuffer, codesize, 0xfbfc858d)
	EmitInteger(codebuffer, codesize, 0x5650ffff)
	EmitInteger(codebuffer, codesize, 0x10fc15ff)
	EmitInteger(codebuffer, codesize, 0x6a560040)
	EmitInteger(codebuffer, codesize, 0x56036a20)
	EmitInteger(codebuffer, codesize, 0x0068016a)
	EmitInteger(codebuffer, codesize, 0x8d800000)
	EmitInteger(codebuffer, codesize, 0xfffbfc85)
	EmitInteger(codebuffer, codesize, 0x15ff50ff)
	EmitInteger(codebuffer, codesize, 0x004010f4)
	EmitInteger(codebuffer, codesize, 0xfb83d88b)
	EmitInteger(codebuffer, codesize, 0x6a0e75ff)
	EmitInteger(codebuffer, codesize, 0x30326810)
	EmitInteger(codebuffer, codesize, 0xf2680040)
	EmitInteger(codebuffer, codesize, 0xeb004031)
	EmitInteger(codebuffer, codesize, 0x5656561d)
	EmitInteger(codebuffer, codesize, 0x5356026a)
	EmitInteger(codebuffer, codesize, 0x10f015ff)
	EmitInteger(codebuffer, codesize, 0xc63b0040)
	EmitInteger(codebuffer, codesize, 0x106a1975)
	EmitInteger(codebuffer, codesize, 0x40303268)
	EmitInteger(codebuffer, codesize, 0x32326800)
	EmitInteger(codebuffer, codesize, 0xff560040)
	EmitInteger(codebuffer, codesize, 0x40111415)
	EmitInteger(codebuffer, codesize, 0x5bc03300)
	EmitInteger(codebuffer, codesize, 0x57c3c95e)
	EmitInteger(codebuffer, codesize, 0x6a565656)
	EmitInteger(codebuffer, codesize, 0x15ff5001)
	EmitInteger(codebuffer, codesize, 0x00401108)
	EmitInteger(codebuffer, codesize, 0xfe3bf88b)
	EmitInteger(codebuffer, codesize, 0x106a1875)
	EmitInteger(codebuffer, codesize, 0x40303268)
	EmitInteger(codebuffer, codesize, 0x326c6800)
	EmitInteger(codebuffer, codesize, 0xff560040)
	EmitInteger(codebuffer, codesize, 0x40111415)
	EmitInteger(codebuffer, codesize, 0x5fc03300)
	
	EmitByte(codebuffer, codesize, 0xeb)
	EmitByte(codebuffer, codesize, 0xd1)
	EmitByte(codebuffer, codesize, 0x68)
	EmitInteger(codebuffer, codesize, HackSize)
	EmitByte(codebuffer, codesize, 0x8d)
	EmitByte(codebuffer, codesize, 0x87)
	EmitInteger(codebuffer, codesize, 0x1000)		// TODO - actual offset of Epoch code beginning (pad for resources)
	EmitByte(codebuffer, codesize, 0x50)
	EmitByte(codebuffer, codesize, 0xff)
	EmitByte(codebuffer, codesize, 0x55)
	
	EmitInteger(codebuffer, codesize, 0x15ff57fc)
	EmitInteger(codebuffer, codesize, 0x0040110c)
	EmitInteger(codebuffer, codesize, 0xec15ff53)
	EmitInteger(codebuffer, codesize, 0x56004010)
	EmitInteger(codebuffer, codesize, 0x10f815ff)
	EmitInteger(codebuffer, codesize, 0x00000040)
	EmitInteger(codebuffer, codesize, 0x00000000)
	
	integer written = 0
	WriteFile(filehandle, codebuffer, codesize, written, 0)
	
	writtenbytes = codesize
}


WriteThunkTable : integer filehandle -> integer writtenbytes = 0
{
	buffer thunkbuffer = 1024
	integer thunksize = 0
	
	// CloseHandle
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x43)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x48)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// CreateFileMappingW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x43)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x67)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// CreateFileW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x43)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// ExitProcess
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x45)
	EmitByte(thunkbuffer, thunksize, 0x78)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x50)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x63)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// GetModuleFileNameW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x47)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x75)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x4e)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x6d)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)

	// GetProcAddress
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x47)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x74)
	EmitByte(thunkbuffer, thunksize, 0x50)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x63)
	EmitByte(thunkbuffer, thunksize, 0x41)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// LoadLibraryW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x4c)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x4c)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x62)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x79)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// MapViewOfFile
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x56)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x77)
	EmitByte(thunkbuffer, thunksize, 0x4f)
	EmitByte(thunkbuffer, thunksize, 0x66)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// UnmapViewOfFile
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x55)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x6d)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x70)
	EmitByte(thunkbuffer, thunksize, 0x56)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x77)
	EmitByte(thunkbuffer, thunksize, 0x4f)
	EmitByte(thunkbuffer, thunksize, 0x66)
	EmitByte(thunkbuffer, thunksize, 0x46)
	EmitByte(thunkbuffer, thunksize, 0x69)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// kernel32.dll
	EmitByte(thunkbuffer, thunksize, 0x6b)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x6e)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x33)
	EmitByte(thunkbuffer, thunksize, 0x32)
	EmitByte(thunkbuffer, thunksize, 0x2e)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// MessageBoxW
	EmitInteger16(thunkbuffer, thunksize, 0)
	EmitByte(thunkbuffer, thunksize, 0x4d)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x61)
	EmitByte(thunkbuffer, thunksize, 0x67)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x42)
	EmitByte(thunkbuffer, thunksize, 0x6f)
	EmitByte(thunkbuffer, thunksize, 0x78)
	EmitByte(thunkbuffer, thunksize, 0x57)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	// user32.dll
	EmitByte(thunkbuffer, thunksize, 0x75)
	EmitByte(thunkbuffer, thunksize, 0x73)
	EmitByte(thunkbuffer, thunksize, 0x65)
	EmitByte(thunkbuffer, thunksize, 0x72)
	EmitByte(thunkbuffer, thunksize, 0x33)
	EmitByte(thunkbuffer, thunksize, 0x32)
	EmitByte(thunkbuffer, thunksize, 0x2e)
	EmitByte(thunkbuffer, thunksize, 0x64)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x6c)
	EmitByte(thunkbuffer, thunksize, 0x00)
	
	EmitInteger(thunkbuffer, thunksize, 0x00001000)
	EmitInteger(thunkbuffer, thunksize, 0x0000100e)
	EmitInteger(thunkbuffer, thunksize, 0x00001023)
	EmitInteger(thunkbuffer, thunksize, 0x00001031)
	EmitInteger(thunkbuffer, thunksize, 0x0000103f)
	EmitInteger(thunkbuffer, thunksize, 0x00001054)
	EmitInteger(thunkbuffer, thunksize, 0x00001065)
	EmitInteger(thunkbuffer, thunksize, 0x00001074)
	EmitInteger(thunkbuffer, thunksize, 0x00001084)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	
	EmitInteger(thunkbuffer, thunksize, 0x000010a3)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	
	// Yes, this appears twice.
	EmitInteger(thunkbuffer, thunksize, 0x00001000)
	EmitInteger(thunkbuffer, thunksize, 0x0000100e)
	EmitInteger(thunkbuffer, thunksize, 0x00001023)
	EmitInteger(thunkbuffer, thunksize, 0x00001031)
	EmitInteger(thunkbuffer, thunksize, 0x0000103f)
	EmitInteger(thunkbuffer, thunksize, 0x00001054)
	EmitInteger(thunkbuffer, thunksize, 0x00001065)
	EmitInteger(thunkbuffer, thunksize, 0x00001074)
	EmitInteger(thunkbuffer, thunksize, 0x00001084)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)
	
	EmitInteger(thunkbuffer, thunksize, 0x000010a3)
	EmitInteger(thunkbuffer, thunksize, 0x00000000)	
	
	integer written = 0
	WriteFile(filehandle, thunkbuffer, thunksize, written, 0)
	
	writtenbytes = thunksize
}


WritePadding : integer filehandle, integer startpos, integer desiredpos -> integer writtenbytes = 0
{
	writtenbytes = desiredpos - startpos
	buffer empty = writtenbytes
	integer written = 0
	WriteFile(filehandle, empty, writtenbytes, written, 0)
}


WriteSectionHeader : integer filehandle, string sectionname, integer location, integer virtuallocation, integer sectionsize, integer sectionvirtualsize, integer flags -> integer writtenbytes = 0
{
	print("Writing header for section '" ; sectionname ; "'...")
	
	buffer headerbuffer = 256
	integer headersize = 0
	
	// This is a pitiful hack.
	
	integer count = 0
	assert(length(sectionname) < 8)
	
	while(count < length(sectionname))
	{
		string char = charat(sectionname, count)
		EmitSubstring(headerbuffer, headersize, char, 1)
		
		++count
	}
	
	while(count < 8)
	{
		EmitByte(headerbuffer, headersize, 0)
		++count
	}
	
	// End hack.
  
	EmitInteger(headerbuffer, headersize, sectionsize)
	EmitInteger(headerbuffer, headersize, virtuallocation)
	EmitInteger(headerbuffer, headersize, sectionvirtualsize)
	EmitInteger(headerbuffer, headersize, location)
	EmitInteger(headerbuffer, headersize, 0)
	EmitInteger(headerbuffer, headersize, 0)
	EmitInteger16(headerbuffer, headersize, 0)
	EmitInteger16(headerbuffer, headersize, 0)
	EmitInteger(headerbuffer, headersize, flags)
	
	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)
	
	writtenbytes = headersize
}


WritePEHeader : integer filehandle, integer imagesize, integer resourcesize -> integer writtenbytes = 0
{
	print("Writing PE headers...")
	
	buffer headerbuffer = 1024
	integer headersize = 0

	// Begin DOS header
	EmitInteger16(headerbuffer, headersize, 0x5a4d)		// e_magic
	EmitInteger16(headerbuffer, headersize, 0x90)		// e_cblp
	EmitInteger16(headerbuffer, headersize, 0x03)		// e_cp
	EmitInteger16(headerbuffer, headersize, 0)		// e_crlc
	EmitInteger16(headerbuffer, headersize, 0x04)		// e_cparhdr
	EmitInteger16(headerbuffer, headersize, 0)		// e_minalloc
	EmitInteger16(headerbuffer, headersize, 0xffff)		// e_maxalloc
	EmitInteger16(headerbuffer, headersize, 0)		// e_ss
	EmitInteger16(headerbuffer, headersize, 0xb8)		// e_sp
	EmitInteger16(headerbuffer, headersize, 0)		// e_csum
	EmitInteger16(headerbuffer, headersize, 0)		// e_ip
	EmitInteger16(headerbuffer, headersize, 0)		// e_cs
	EmitInteger16(headerbuffer, headersize, 0x40)		// e_lfarlc
	EmitInteger16(headerbuffer, headersize, 0)		// e_ovno
	
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[0]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[1]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[2]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res[3]

	EmitInteger16(headerbuffer, headersize, 0)		// e_oemid
	EmitInteger16(headerbuffer, headersize, 0)		// e_oeminfo
	
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[0]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[1]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[2]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[3]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[4]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[5]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[6]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[7]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[8]
	EmitInteger16(headerbuffer, headersize, 0)		// e_res2[9]
	
	EmitInteger(headerbuffer, headersize, 0xb0)		// e_lfanew
	
	
	// Begin DOS stub
	EmitByte(headerbuffer, headersize, 0x0e)
	EmitByte(headerbuffer, headersize, 0x1f)
	EmitByte(headerbuffer, headersize, 0xba)
	EmitByte(headerbuffer, headersize, 0x0e)
	EmitByte(headerbuffer, headersize, 0x00)
	EmitByte(headerbuffer, headersize, 0xb4)
	EmitByte(headerbuffer, headersize, 0x09)
	EmitByte(headerbuffer, headersize, 0xcd)
	EmitByte(headerbuffer, headersize, 0x21)
	EmitByte(headerbuffer, headersize, 0xb8)
	EmitByte(headerbuffer, headersize, 0x01)
	EmitByte(headerbuffer, headersize, 0x4c)
	EmitByte(headerbuffer, headersize, 0xcd)
	EmitByte(headerbuffer, headersize, 0x21)

	EmitByte(headerbuffer, headersize, 0x54)
	EmitByte(headerbuffer, headersize, 0x68)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x73)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x70)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x67)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x61)
	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x69)

	EmitByte(headerbuffer, headersize, 0x73)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x66)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x68)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x66)
	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x74)

	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x2e)
	EmitByte(headerbuffer, headersize, 0x0d)
	EmitByte(headerbuffer, headersize, 0x0a)
	EmitByte(headerbuffer, headersize, 0x49)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x77)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x6c)
	EmitByte(headerbuffer, headersize, 0x6c)
	EmitByte(headerbuffer, headersize, 0x20)

	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x79)
	EmitByte(headerbuffer, headersize, 0x6f)
	EmitByte(headerbuffer, headersize, 0x75)

	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x70)
	EmitByte(headerbuffer, headersize, 0x72)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x76)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x63)
	EmitByte(headerbuffer, headersize, 0x6f)

	EmitByte(headerbuffer, headersize, 0x6d)
	EmitByte(headerbuffer, headersize, 0x70)
	EmitByte(headerbuffer, headersize, 0x75)
	EmitByte(headerbuffer, headersize, 0x74)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x6e)
	EmitByte(headerbuffer, headersize, 0x67)
	EmitByte(headerbuffer, headersize, 0x20)
	EmitByte(headerbuffer, headersize, 0x64)
	EmitByte(headerbuffer, headersize, 0x65)
	EmitByte(headerbuffer, headersize, 0x76)
	EmitByte(headerbuffer, headersize, 0x69)
	EmitByte(headerbuffer, headersize, 0x63)
	EmitByte(headerbuffer, headersize, 0x65)

	EmitByte(headerbuffer, headersize, 0x2e)
	EmitByte(headerbuffer, headersize, 0x0d)
	EmitByte(headerbuffer, headersize, 0x0a)
	EmitByte(headerbuffer, headersize, 0x24)
	
	EmitPadding(headerbuffer, headersize, 0xb0)
	
	
	// Begin NT headers
	EmitInteger(headerbuffer, headersize, 0x00004550)
	EmitInteger16(headerbuffer, headersize, 0x014c)			// Machine
	EmitInteger16(headerbuffer, headersize, 5)			// NumberOfSections
	EmitInteger(headerbuffer, headersize, 0x00000000)		// TimeDateStamp
	EmitInteger(headerbuffer, headersize, 0)			// PointerToSymbolTable
	EmitInteger(headerbuffer, headersize, 0)			// NumberOfSymbols
	EmitInteger16(headerbuffer, headersize, 0xe0)			// SizeOfOptionalHeader
	EmitInteger16(headerbuffer, headersize, 0x0103)			// Characteristics

	EmitInteger16(headerbuffer, headersize, 0x010b)			// Magic
	EmitByte(headerbuffer, headersize, 0x02)			// MajorLinkerVersion
	EmitByte(headerbuffer, headersize, 0x00)			// MinorLinkerVersion
	
	EmitInteger(headerbuffer, headersize, RoundUp(HackSize))			// SizeOfCode
	EmitInteger(headerbuffer, headersize, 0x1000)			// SizeOfInitializedData
	EmitInteger(headerbuffer, headersize, 0)			// SizeOfUninitializedData
	EmitInteger(headerbuffer, headersize, 0x2000)			// AddressOfEntryPoint
	EmitInteger(headerbuffer, headersize, 0x800)			// BaseOfCode
	EmitInteger(headerbuffer, headersize, 0x1000)			// BaseOfData
	
	EmitInteger(headerbuffer, headersize, 0x400000)			// ImageBase
	EmitInteger(headerbuffer, headersize, 0x1000)			// SectionAlignment
	EmitInteger(headerbuffer, headersize, 0x200)			// FileAlignment
	
	EmitInteger16(headerbuffer, headersize, 0x04)			// MajorOperatingSystemVersion
	EmitInteger16(headerbuffer, headersize, 0x00)			// MinorOperatingSystemVersion
	EmitInteger16(headerbuffer, headersize, 0)			// MajorImageVersion
	EmitInteger16(headerbuffer, headersize, 0)			// MinorImageVersion
	EmitInteger16(headerbuffer, headersize, 0x04)			// MajorSubsystemVersion
	EmitInteger16(headerbuffer, headersize, 0x00)			// MinorSubsystemVersion

	EmitInteger(headerbuffer, headersize, 0)			// Win32VersionValue
	EmitInteger(headerbuffer, headersize, imagesize)		// SizeOfImage
	EmitInteger(headerbuffer, headersize, 0x400)			// SizeOfHeaders
	EmitInteger(headerbuffer, headersize, 0xf00d)			// Checksum
	
	EmitInteger16(headerbuffer, headersize, 3)			// Subsystem
	EmitInteger16(headerbuffer, headersize, 0)			// DllCharacteristics

	EmitInteger(headerbuffer, headersize, 0x800000)			// SizeOfStackReserve
	EmitInteger(headerbuffer, headersize, 0x80000)			// SizeOfStackCommit
	EmitInteger(headerbuffer, headersize, 0x500000)			// SizeOfHeapReserve
	EmitInteger(headerbuffer, headersize, 0x50000)			// SizeOfHeapCommit
	EmitInteger(headerbuffer, headersize, 0)			// LoaderFlags
	EmitInteger(headerbuffer, headersize, 0x10)			// NumberOfRvaAndSizes
	
	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 1
	EmitInteger(headerbuffer, headersize, 0)			// Size
	
	EmitInteger(headerbuffer, headersize, 0x1200)			// RVA virtual address 2
	EmitInteger(headerbuffer, headersize, 0x28)			// Size

	EmitInteger(headerbuffer, headersize, 0x4000)			// RVA virtual address 3
	EmitInteger(headerbuffer, headersize, resourcesize)		// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 4
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 5
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 6
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 7
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 8
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 9
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 10
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 11
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 12
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 13
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 14
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 15
	EmitInteger(headerbuffer, headersize, 0)			// Size

	EmitInteger(headerbuffer, headersize, 0)			// RVA virtual address 16
	EmitInteger(headerbuffer, headersize, 0)			// Size


	integer written = 0
	WriteFile(filehandle, headerbuffer, headersize, written, 0)
	
	writtenbytes = headersize
}


EmitInteger : buffer ref b, integer ref size, integer value [nogc]
{
	writebuffer(b, size, (value) & 0xff)
	++size
	writebuffer(b, size, (value / 0x100) & 0xff)
	++size
	writebuffer(b, size, (value / 0x10000) & 0xff)
	++size
	writebuffer(b, size, (value / 0x1000000) & 0xff)
	++size
}

EmitInteger16 : buffer ref b, integer ref size, integer16 value [nogc]
{
	integer v = cast(integer, value)
	writebuffer(b, size, (v) & 0xff)
	++size
	writebuffer(b, size, (v / 0x100) & 0xff)
	++size
}

EmitByte : buffer ref b, integer ref size, integer value [nogc]
{
	writebuffer(b, size, (value) & 0xff)
	++size
}

EmitPadding : buffer ref b, integer ref size, integer targetsize [nogc]
{
	while(size < targetsize)
	{
		EmitByte(b, size, 0x00)
	}
}

EmitSubstring : buffer ref b, integer ref size, string s, integer bytes [nogc]
{
	writebuffer(b, size, s, bytes)
	size += bytes
}




DumpOverloadList : list<Overload> ref overloads
{
	DumpOverload(overloads.value)
	DumpOverloadList(overloads.next)
}


DumpOverload : Overload ref overload
{
	print(GetPooledString(GlobalStrings, overload.NormalName) ; " -> " ; GetPooledString(GlobalStrings, overload.MangledName))
}


CacheGlobalCodeBlock : list<Scope> ref scopes [nogc]
{
	if(scopes.value.Name == GlobalCodeBlockName)
	{
		GlobalScope.Wrapped = scopes.value
	}
	else
	{
		CacheGlobalCodeBlock(scopes.next)
	}
}


//
// Global state (just a hack while we bootstrap!)
//

global
{
	buffer Hack = 8192000
	integer HackSize = 0

	list<StringTableEntry> GlobalStrings = StringTableEntry(0, ""), nothing

	Variable dummyvar = 0, 0, 0, 0
	list<Variable> dummyvarlist = dummyvar, nothing
	Scope dummyscope = 0, 0, dummyvarlist, 0, 0
	list<Scope> Scopes = dummyscope, nothing
	
	Overload dummyoverload = 0, 0, nothing
	list<Overload> dummyoverloadlist = dummyoverload, nothing
	list<Overload> Overloads = dummyoverload, nothing
	list<Overload> AutoGenOverloads = dummyoverload, nothing

	ContextWrapper<Scope> dummyscopewrap = nothing
	FunctionDefinition dummyfunc = 0, 0, nothing, nothing, nothing, dummyoverloadlist, dummyscopewrap, "", 0, false, false, false
	list<FunctionDefinition> Functions = dummyfunc, nothing

	SumTypeBase dummybasetype = 0, nothing
	list<SumTypeBase> dummybases = dummybasetype, nothing
	SumType dummysumtype = 0, 0, dummybases, false
	list<SumType> SumTypes = dummysumtype, nothing


	StructureMemberVariable dummymember = 0, 0, 0, nothing
	list<StructureMember> dummymembers = dummymember, nothing
	StructureDefinition dummystruct = 0, 0, 0, 0, 0, dummymembers, 0, "", false
	list<StructureDefinition> Structures = dummystruct, nothing


	// TODO - convert to an enumeration
	integer STACK_TYPE_GLOBAL = 0
	integer STACK_TYPE_FUNCTION = 1
	integer STACK_TYPE_CODEBLOCK = 2
	integer STACK_TYPE_STATEMENT = 3
	integer STACK_TYPE_ASSIGNMENT = 4
	integer STACK_TYPE_TYPEMATCH = 5
	integer STACK_TYPE_SUBSTATEMENT = 6
	integer STACK_TYPE_FUNCRET = 7
	integer STACK_TYPE_ENTITY_PARAM = 8
	integer STACK_TYPE_ENTITY_CODE = 9
	integer STACK_TYPE_CHAIN = 10
	integer STACK_TYPE_PARENTHETICAL = 11

	ContextStackEntry GlobalStackEntry = STACK_TYPE_GLOBAL, 0
	list<ContextStackEntry> ContextStack = GlobalStackEntry, nothing

	AtomSentinel dummysentinel = 0
	list<ExpressionAtom> dummyatomlist = dummysentinel, nothing
	Expression dummyexpression = dummyatomlist, 0
	list<Expression> ScratchExpressions = dummyexpression, nothing
	Statement dummystatement = 0, nothing, 0, nothing, false, false
	list<Statement> SubStatements = dummystatement, nothing

	Parameter dummyparam = 0, 0
	list<Parameter> dummyparamlist = dummyparam, nothing
	FunctionSignature dummysignature = 0, dummyparamlist, 0
	list<FunctionSignature> dummysignaturelist = dummysignature, nothing
	TypeMatcher dummytypematch = 0, dummysignaturelist
	list<TypeMatcher> TypeMatchers = dummytypematch, nothing

	Entity dummyentity = 0, 0, nothing, nothing
	list<Entity> EntityStack = dummyentity, nothing


	list<string> dummytagparams = "", nothing
	FunctionTag dummytag = 0, "", dummytagparams
	list<FunctionTag> FunctionTags = dummytag, nothing

	integer EmittingFunctionName = 0

	list<OptionalCodeBlock> CurrentCodeBlockStack = nothing, nothing

	list<CodeBlockEntry> dummyblockentries = dummystatement, nothing
	CodeBlock GlobalCodeBlock = dummyblockentries
	integer GlobalCodeBlockName = 0

	list<Entity> chaincontents = dummyentity, nothing
	EntityList foo = chaincontents
	EntityChain dummychain = foo
	list<EntityChain> ChainStack = dummychain, nothing


	simplelist<integer> AutoGeneratedFunctionNames = 0, nothing
	simplelist<integer> CustomConstructors = 0, nothing

	TypeAlias dummyalias = 0, 0, 0
	list<TypeAlias> TypeAliases = dummyalias, nothing
	
	TypeAlias dummyweak = 0, 0, 0
	list<TypeAlias> TypeWeakAliases = dummyweak, nothing

	list<FunctionSignature> FunctionSignatures = dummysignature, nothing

	boolean InFuncRetHack = false

	integer CurrentStringHandle = 0

	simplelist<integer> scratchpossibletypes = 0, nothing
	TypePossibilityList scratchreturns = scratchpossibletypes, false
	TypePossibilityList scratchparams = scratchpossibletypes, false
	list<TypePossibilityList> scratchparampossibles = scratchparams, nothing
	InferencePossibility scratchpossibility = 0, scratchparampossibles, scratchreturns
	
	PendingTypeMatcher dummypending = 0, 0, nothing
	list<PendingTypeMatcher> PendingTypeMatchers = dummypending, nothing
	
	BTPayloadWrap<PendingTypeMatcher> tmwewrap = dummypending
	BinaryTree<PendingTypeMatcher> TypeMatchersWhichExist = 0, tmwewrap, nothing, nothing, -1
	BinaryTree<PendingTypeMatcher> TypeMatchersWhichExistByMatcherName = 0, tmwewrap, nothing, nothing, -1
	
	PendingPatternMatcher dummypatternpending = 0, 0, 0
	list<PendingPatternMatcher> PendingPatternMatchers = dummypatternpending, nothing

	simplelist<string> TokenStream = "", nothing
	tailhack TokenStreamTail = TokenStream

	simplelist<integer> EmittedPatternMatchers = 0, nothing

	TemplateParameter scratchtemplateparam = 0, 0
	list<TemplateParameter> TemplateParameterQueue = scratchtemplateparam, nothing

	list<TemplateParameter> dummytemplateparams = scratchtemplateparam, nothing
	TemplateFunction dummyfunctemplate = 0, dummytemplateparams
	list<TemplateFunction> TemplateFunctions = dummyfunctemplate, nothing

	TemplateArgument scratchtemplatearg = 0, ""
	list<TemplateArgument> scratchtemplateargs = scratchtemplatearg, nothing
	TemplateArgumentList scratchtemplatearglist = scratchtemplateargs
	list<TemplateArgumentList> ScratchTemplateArgumentStack = scratchtemplatearglist, nothing

	TemplateInstance dummytemplateinst = 0, 0, scratchtemplateargs
	list<TemplateInstance> TemplateFunctionInstances = dummytemplateinst, nothing
	list<TemplateInstance> TemplateStructureInstances = dummytemplateinst, nothing
	list<TemplateInstance> TemplateSumTypeInstances = dummytemplateinst, nothing

	TemplateStructure dummystructuretemplate = 0, dummytemplateparams
	list<TemplateStructure> TemplateStructures = dummystructuretemplate, nothing
	
	TemplateSumType dummysumtypetemplate = 0, dummytemplateparams
	list<TemplateSumType> TemplateSumTypes = dummysumtypetemplate, nothing
	
	simplelist<integer> dummycompound = 0, nothing
	PreOpStatement PreOpOnDeck = 0, dummycompound, 0
	PostOpStatement PostOpOnDeck = 0, dummycompound, 0
	
	
	ContextWrapper<Scope> gcdscopewrap = nothing
	ContextWrapper<FunctionDefinition> gcdfuncwrap = nothing
	InferenceContext DummyContextForFunctions = 0, 0, dummycompound, false, 0, false, false, gcdscopewrap, gcdfuncwrap

	simplelist<integer> globalemptyintlist = 0, nothing

	integer CHARACTER_CLASS_WHITE = 0
	integer CHARACTER_CLASS_IDENTIFIER = 1
	integer CHARACTER_CLASS_PUNCTUATION = 2
	integer CHARACTER_CLASS_COMMENT = 3
	integer CHARACTER_CLASS_PUNCTUATION_COMPOUND = 4
	integer CHARACTER_CLASS_STRING_LITERAL = 5
	integer CHARACTER_CLASS_LITERAL = 6

	integer GlobalStructureCounter = 0x03000000
	integer GlobalWeakAliasCounter = 0x04000000
	integer GlobalAliasCounter = 0x05000000
	integer GlobalSumTypeCounter = 0x07000000
	integer GlobalTemplateInstanceCounter = 0x08000000
	integer GlobalFunctionTypeCounter = 0x09000000
	
	integer GlobalNothingCounter = 0
	
	integer PooledStringHandleForBoolean = 0
	integer PooledStringHandleForInteger = 0
	integer PooledStringHandleForInteger16 = 0
	integer PooledStringHandleForString = 0
	integer PooledStringHandleForReal = 0
	integer PooledStringHandleForBuffer = 0
	integer PooledStringHandleForNothing = 0
	integer PooledStringHandleForIdentifier = 0
	integer PooledStringHandleForAnonymousRet = 0
	integer PooledStringHandleForAssignment = 0
	integer PooledStringHandleForCast = 0
	integer PooledStringHandleForMemberAccess = 0
	integer PooledStringHandleForSubstringWithLength = 0
	integer PooledStringHandleForSubstringNoLength = 0
	integer PooledStringHandleForUnescape = 0
	integer PooledStringHandleForUnaryNot = 0
	integer PooledStringHandleForUnaryNotBoolean = 0
	integer PooledStringHandleForIncrementAssign = 0
	integer PooledStringHandleForIncrementAssignInteger = 0
	integer PooledStringHandleForDecrementAssign = 0
	integer PooledStringHandleForDecrementAssignInteger = 0
	integer PooledStringHandleForEquality = 0
	integer PooledStringHandleForInequality = 0
	integer PooledStringHandleForGreaterThan = 0
	integer PooledStringHandleForLessThan = 0
	integer PooledStringHandleForBooleanAnd = 0
	integer PooledStringHandleForBitwiseAnd = 0
	integer PooledStringHandleForStringConcat = 0
	integer PooledStringHandleForPlus = 0
	integer PooledStringHandleForMinus = 0
	integer PooledStringHandleForMultiply = 0
	integer PooledStringHandleForDivide = 0
	integer PooledStringHandleForEqualityInteger = 0
	integer PooledStringHandleForEqualityInteger16 = 0
	integer PooledStringHandleForEqualityBoolean = 0
	integer PooledStringHandleForEqualityReal = 0
	integer PooledStringHandleForEqualityString = 0
	integer PooledStringHandleForInequalityInteger = 0
	integer PooledStringHandleForInequalityBoolean = 0
	integer PooledStringHandleForInequalityString = 0
	integer PooledStringHandleForGreaterThanInteger = 0
	integer PooledStringHandleForLessThanInteger = 0
	integer PooledStringHandleForPrePostIncrementInteger = 0
	integer PooledStringHandleForWriteBuffer = 0
	integer PooledStringHandleForWriteBufferString = 0
	integer PooledStringHandleForWriteBufferMultiple = 0
	integer PooledStringHandleForWriteBufferReal = 0
	integer PooledStringHandleForSubstring = 0
	integer PooledStringHandleForPassTest = 0
	integer PooledStringHandleForAssert = 0
	integer PooledStringHandleForPrint = 0
	integer PooledStringHandleForNarrowString = 0
	integer PooledStringHandleForCastBooleanToInteger = 0
	integer PooledStringHandleForCastRealToInteger = 0
	integer PooledStringHandleForCastRealToString = 0
	integer PooledStringHandleForCastStringToReal = 0
	integer PooledStringHandleForCastIntegerToString = 0
	integer PooledStringHandleForCastStringToInteger = 0
	integer PooledStringHandleForWidenFromPtr = 0
	integer PooledStringHandleForLength = 0
	integer PooledStringHandleForCastIntegerToInteger16 = 0
	integer PooledStringHandleForCastInteger16ToInteger = 0
	integer PooledStringHandleForCmdLineGet = 0
	integer PooledStringHandleForCmdLineGetCount = 0
	integer PooledStringHandleForCmdLineIsValid = 0
	integer PooledStringHandleForPrePostDecrementInteger = 0
	integer PooledStringHandleForPrePostDecrement = 0
	integer PooledStringHandleForPrePostIncrement = 0
	integer PooledStringHandleForDivideInteger = 0
	integer PooledStringHandleForMultiplyInteger = 0
	integer PooledStringHandleForMinusInteger = 0
	integer PooledStringHandleForPlusInteger = 0
	integer PooledStringHandleForPlusReal = 0
	integer PooledStringHandleForSubchar = 0
	
	integer FirstNonBuiltInStringHandle = 0
	
	ContextWrapper<Scope> GlobalScope = nothing
	ContextWrapper<Scope> EmittingScope = nothing
	
	integer CharacterCarriageReturn = subchar(unescape("\r"), 0)
	integer CharacterLineFeed = subchar(unescape("\n"), 0)
	integer CharacterTab = subchar(unescape("\t"), 0)
	integer CharacterQuote = subchar(unescape("\'"), 0)
	integer CharacterSlash = subchar("/", 0)
	integer CharacterSpace = subchar(" ", 0)

	integer CharacterA = subchar("a", 0)
	integer CharacterB = subchar("b", 0)
	integer CharacterC = subchar("c", 0)
	integer CharacterD = subchar("d", 0)
	integer CharacterE = subchar("e", 0)
	integer CharacterF = subchar("f", 0)
	integer CharacterX = subchar("x", 0)
	integer CharacterZero = subchar("0", 0)
	integer CharacterOne = subchar("1", 0)
	integer CharacterTwo = subchar("2", 0)
	integer CharacterThree = subchar("3", 0)
	integer CharacterFour = subchar("4", 0)
	integer CharacterFive = subchar("5", 0)
	integer CharacterSix = subchar("6", 0)
	integer CharacterSeven = subchar("7", 0)
	integer CharacterEight = subchar("8", 0)
	integer CharacterNine = subchar("9", 0)

	integer CharacterOpenBrace = subchar("{", 0)
	integer CharacterCloseBrace = subchar("}", 0)
	integer CharacterColon = subchar(":", 0)
	integer CharacterOpenParen = subchar("(", 0)
	integer CharacterCloseParen = subchar(")", 0)
	integer CharacterEquals = subchar("=", 0)
	integer CharacterAmpersand = subchar("&", 0)
	integer CharacterComma = subchar(",", 0)
	integer CharacterPlus = subchar("+", 0)
	integer CharacterMinus = subchar("-", 0)
	integer CharacterLessThan = subchar("<", 0)
	integer CharacterGreaterThan = subchar(">", 0)
	integer CharacterDot = subchar(".", 0)
	integer CharacterSemicolon = subchar(";", 0)
	integer CharacterExclamation = subchar("!", 0)
	integer CharacterOpenBracket = subchar("[", 0)
	integer CharacterCloseBracket = subchar("]", 0)
	
	
	list<FunctionDefinition> PendingInferenceFunctions = dummyfunc, nothing
	
	Trie GlobalStringTrie = 0, nothing, 0
	
	BTPayloadWrap<FunctionDefinition> fwewrap = dummyfunc
	BinaryTree<FunctionDefinition> FunctionsWhichExist = 0, fwewrap, nothing, nothing, -1
	
	BTPayloadWrap<StructureDefinition> swewrap = dummystruct
	BinaryTree<StructureDefinition> StructuresWhichExist = 0, swewrap, nothing, nothing, -1
}


IsRecognizedBuiltIn : integer namehandle -> boolean recognized = false [nogc]
{
	// This is a REALLY bad hack.
	if(namehandle < FirstNonBuiltInStringHandle)
	{
		recognized = true
	}
}



structure Trie :
	integer Character,
	listnode<Trie> Children,
	integer Handle


PlaceDataInTrie : Trie ref trie, string data, integer handle [nogc]
{
	if(length(data) == 0)
	{
		trie.Handle = handle
		return()
	}
	
	PlaceDataInTrieChild(trie.Children, trie, subchar(data, 0), data, 1, handle)
}

PlaceDataInTrieRecurse : Trie ref trie, string data, integer offset, integer handle [nogc]
{
	if(length(data) == offset)
	{
		trie.Handle = handle
		return()
	}
	
	PlaceDataInTrieChild(trie.Children, trie, subchar(data, offset), data, offset + 1, handle)
}

PlaceDataInTrieChild : list<Trie> ref children, Trie ref originaltrie, integer character, string alldata, integer offset, integer handle [nogc]
{
	if(children.value.Character == character)
	{
		PlaceDataInTrieRecurse(children.value, alldata, offset, handle)
	}
	else
	{
		PlaceDataInTrieChild(children.next, originaltrie, character, alldata, offset, handle)
	}
}

PlaceDataInTrieChild : nothing, Trie ref originaltrie, integer character, string alldata, integer offset, integer handle [nogc]
{
	Trie newtrie = character, nothing, 0
	PlaceDataInTrieRecurse(newtrie, alldata, offset, handle)
	
	list<Trie> newtrielist = newtrie, originaltrie.Children
	originaltrie.Children = newtrielist
}


FindHandleInTrie : Trie ref trie, string data -> integer handle = 0 [nogc]
{
	if(length(data) == 0)
	{
		handle = trie.Handle
		return()
	}
	
	handle = FindHandleInTrieChildren(trie.Children, subchar(data, 0), data, 1, length(data))
}

FindHandleInTrieChildren : list<Trie> ref triechildren, integer character, string alldata, integer offset, integer datalength -> integer handle = 0 [nogc]
{
	if(triechildren.value.Character == character)
	{
		if(datalength == offset)
		{
			handle = triechildren.value.Handle
			return()
		}
		
		handle = FindHandleInTrieChildren(triechildren.value.Children, subchar(alldata, offset), alldata, offset + 1, datalength)
		return()
	}
	
	handle = FindHandleInTrieChildren(triechildren.next, character, alldata, offset, datalength)
}

FindHandleInTrieChildren : nothing, integer character, string alldata, integer offset, integer datalength -> integer handle = 0 [nogc]


assertmsg : boolean check, string message
{
	if(!check)
	{
		print(message)
		assert(false)
	}
}


type BinaryTreeNode<type T> : BinaryTree<T> | nothing

structure BTPayloadWrap<type T> :
	T ref Payload

structure BinaryTree<type T> :
	integer Value,
	BTPayloadWrap<T> Payload,	
	BinaryTreeNode<T> Left,
	BinaryTreeNode<T> Right,
	integer Height


InsertIntoBinaryTree<type T> : BinaryTree<T> ref tree, integer value, T ref payload -> true
{
	if(tree.Value > value)
	{
		if(!InsertIntoBinaryTree<T>(tree.Left, value, payload))
		{
			BTPayloadWrap<T> wrap = payload
			BinaryTree<T> newtree = value, wrap, nothing, nothing, 0
			tree.Left = newtree
		}
	}
	elseif(tree.Value < value)
	{
		if(!InsertIntoBinaryTree<T>(tree.Right, value, payload))
		{
			BTPayloadWrap<T> wrap = payload
			BinaryTree<T> newtree = value, wrap, nothing, nothing, 0
			tree.Right = newtree
		}
	}
	else
	{
		return()
	}
	
	integer balance = ComputeBalance<T>(tree)
	if(balance > 1)
	{
		tree.Height = RecomputeTreeDepth<T>(tree)
		if(ComputeBalance<T>(tree.Left) > 0)
		{
			RotateLL<T>(tree)
		}
		else
		{
			RotateLR<T>(tree)
		}
	}
	elseif(balance < -1)
	{
		tree.Height = RecomputeTreeDepth<T>(tree)
		if(ComputeBalance<T>(tree.Right) < 0)
		{
			RotateRR<T>(tree)
		}
		else
		{
			RotateRL<T>(tree)
		}
	}
}

InsertIntoBinaryTree<type T> : nothing, integer value, T ref payload -> false

RotateLL<type T> : BinaryTree<T> ref tree
{
	BinaryTreeNode<T> temp = tree.Right
	tree.Right = tree.Left
	tree.Left = GetLeft<T>(tree.Right)
	
	BinaryTreeNode<T> newnode = GetRight<T>(tree.Right)
	SetNodeLeft<T>(tree.Right, newnode)
	SetNodeRight<T>(tree.Right, temp)
	
	integer tempvalue = tree.Value
	tree.Value = GetNodeValue<T>(tree.Right)
	SetNodeValue<T>(tree.Right, tempvalue)
		
	SwapNodePayload<T>(tree, tree.Right)
	
	SetHeight<T>(tree.Right, RecomputeTreeDepth<T>(tree.Right))
	tree.Height = RecomputeTreeDepth<T>(tree)
}

GetLeft<type T> : BinaryTree<T> ref tree -> BinaryTreeNode<T> ret = tree.Left
GetLeft<type T> : nothing -> BinaryTreeNode<T> ret = nothing

GetRight<type T> : BinaryTree<T> ref tree -> BinaryTreeNode<T> ret = tree.Right
GetRight<type T> : nothing -> BinaryTreeNode<T> ret = nothing

SetNodeLeft<type T> : BinaryTree<T> ref tree, BinaryTreeNode<T> newleft
{
	tree.Left = newleft
}

SetNodeRight<type T> : BinaryTree<T> ref tree, BinaryTreeNode<T> newright
{
	tree.Right = newright
}

RotateRR<type T> : BinaryTree<T> ref tree
{
	BinaryTreeNode<T> temp = tree.Left
	tree.Left = tree.Right
	tree.Right = GetRight<T>(tree.Left)
	
	BinaryTreeNode<T> newnode = GetLeft<T>(tree.Left)
	SetNodeRight<T>(tree.Left, newnode)
	SetNodeLeft<T>(tree.Left, temp)
	
	integer tempvalue = tree.Value
	tree.Value = GetNodeValue<T>(tree.Left)
	SetNodeValue<T>(tree.Left, tempvalue)
		
	SwapNodePayload<T>(tree, tree.Left)
	
	SetHeight<T>(tree.Left, RecomputeTreeDepth<T>(tree.Left))
	tree.Height = RecomputeTreeDepth<T>(tree)
}

RotateLR<type T> : BinaryTree<T> ref tree
{
	RotateRR<T>(tree.Left)
	RotateLL<T>(tree)
}

RotateRL<type T> : BinaryTree<T> ref tree
{
	RotateLL<T>(tree.Right)
	RotateRR<T>(tree)
}


TreeDepth<type T> : BinaryTree<T> ref tree -> integer depth = tree.Height
TreeDepth<type T> : nothing -> 0


HasNode<type T> : BinaryTree<T> ref tree -> true
HasNode<type T> : nothing -> false

ComputeBalance<type T> : BinaryTree<T> ref tree -> integer balance = 0
{
	integer leftdepth = TreeDepth<T>(tree.Left)
	integer rightdepth = TreeDepth<T>(tree.Right)
	
	balance = leftdepth - rightdepth
}

ComputeBalance<type T> : nothing -> 0


RecomputeTreeDepth<type T> : BinaryTree<T> ref tree -> integer depth = 1
{
	integer ldepth = TreeDepth<T>(tree.Left)
	integer rdepth = TreeDepth<T>(tree.Right)
	
	if(ldepth > rdepth)
	{
		depth += ldepth
	}
	else
	{
		depth += rdepth
	}
}

SetHeight<type T> : BinaryTree<T> ref tree, integer newheight
{
	tree.Height = newheight
}


SearchBinaryTree<type T> : BinaryTree<T> ref tree, integer target -> boolean found = false
{
	if(tree.Value == target)
	{
		found = true
		return()
	}
	elseif(target < tree.Value)
	{
		found = SearchBinaryTree<T>(tree.Left, target)
	}
	else
	{
		found = SearchBinaryTree<T>(tree.Right, target)
	}
}

SearchBinaryTree<type T> : nothing, integer target -> boolean found = false


SearchBinaryTreeForPayload<type T> : BinaryTree<T> ref tree, integer target, ContextWrapper<T> ref out -> boolean found = false
{
	if(tree.Value == target)
	{
		found = true
		out.Wrapped = tree.Payload.Payload
		return()
	}
	elseif(target < tree.Value)
	{
		found = SearchBinaryTreeForPayload<T>(tree.Left, target, out)
	}
	else
	{
		found = SearchBinaryTreeForPayload<T>(tree.Right, target, out)
	}
}

SearchBinaryTreeForPayload<type T> : nothing, integer target, ContextWrapper<T> ref out -> boolean found = false

GetNodeValue<type T> : BinaryTree<T> ref node -> integer ret = node.Value

SetNodeValue<type T> : BinaryTree<T> ref node, integer value
{
	node.Value = value
}

SwapNodePayload<type T> : BinaryTree<T> ref a, BinaryTree<T> ref b
{
	BTPayloadWrap<T> p = a.Payload.Payload
	a.Payload = b.Payload
	b.Payload = p
}

