//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//



//
// Singly linked list data structures
//

type simplelistnode<type T> : simplelist<T> | nothing

structure simplelist<type T> :
	T value,
	simplelistnode<T> next


type listnode<type T> : list<T> | nothing

structure list<type T> :
	T ref value,
	listnode<T> next


//
// List manipulation functions
//

simpleprepend<type T> : simplelist<T> ref thelist, T value
{
	simplelist<T> newlist = value, thelist
	thelist = newlist
}

prepend<type T> : list<T> ref thelist, T ref value
{
	list<T> newlist = value, thelist
	thelist = newlist
}


getelement : simplelist<integer> ref thelist, integer index -> integer value = thelist.value
{
	if(index > 0)
	{
		value = getelement(thelist.next, index - 1)
	}
}




CloseHandle : integer handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]
CreateFile : string filename, integer access, integer sharemode, integer attributes, integer creation, integer flags, integer template -> integer ret = 0 [external("Kernel32.dll", "CreateFileW", "stdcall")]
CreateFileMapping : integer filehandle, integer attributes, integer protection, integer maxsizehigh, integer maxsizelow, integer name -> integer ret = 0 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
MapViewOfFile : integer handle, integer access, integer offsethigh, integer offsetlow, integer bytestomap -> integer ptr = 0 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]
UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]
GetFileSize : integer handle, integer ignored -> integer size = 0 [external("Kernel32.dll", "GetFileSize", "stdcall")]


timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime", "stdcall")]


ExecuteByteCodeBuffer : buffer ref code, integer len [external("EpochRuntime.dll", "ExecuteByteCodeDeferred", "stdcall")]



simple_append_recurse<type T> : simplelist<T> ref thelist, nothing, T value
{
	simplelist<T> newlist = value, nothing
	thelist.next = newlist
}

simple_append_recurse<type T> : simplelist<T> ref thelist, simplelist<T> ref tail, T value
{
	simple_append_recurse<T>(tail, tail.next, value)
}


simple_append<type T> : simplelist<T> ref thelist, T value
{
	simple_append_recurse<T>(thelist, thelist.next, value)
}



entrypoint :
{
	print("Epoch Language Project")
	print("Command line compiler and tools interface")
	print("")

	if(cmdlineisvalid() && (cmdlinegetcount() > 1))
	{
		string filename = cmdlineget(1)

		print("Executing: " ; filename)
		print("")

		integer len = 0
		string contents = ReadFile(filename, len)

		PrepareStringTable()
		InitBuiltInOverloads()

		integer startparsems = timeGetTime()
		boolean parseok = Parse(contents, len)
		integer durationparsems = timeGetTime() - startparsems

		print("Parsing completed in " ; cast(string, durationparsems) ; " milliseconds")
		if(!parseok)
		{
			return()
		}

		integer startprocessms = timeGetTime()
		boolean irok = IRProcess()
		integer durationprocessms = timeGetTime() - startprocessms

		print("Semantic analysis completed in " ; cast(string, durationprocessms) ; " milliseconds")
		if(!irok)
		{
			return()
		}

		integer startcodegenms = timeGetTime()
		OnCodeGenProcessProgram()
		integer durationcodegenms = timeGetTime() - startcodegenms

		print("Code generation completed in " ; cast(string, durationcodegenms) ; " milliseconds")
		print("")

		ExecuteByteCodeBuffer(Hack, HackSize)
	}
	else
	{
		print("Please specify a program to execute!")
	}
}


PrepareStringTable :
{
	integer counter = 0
	OnCodeGenRegisterString((++counter), "+")
	OnCodeGenRegisterString((++counter), "-")
	OnCodeGenRegisterString((++counter), "*")
	OnCodeGenRegisterString((++counter), "/")
	OnCodeGenRegisterString((++counter), "+=@@real")
	OnCodeGenRegisterString((++counter), "+@@real")
	OnCodeGenRegisterString((++counter), "-=@@real")
	OnCodeGenRegisterString((++counter), "-@@real")
	OnCodeGenRegisterString((++counter), "*@@real")
	OnCodeGenRegisterString((++counter), "/@@real")
	OnCodeGenRegisterString((++counter), "+=@@integer")
	OnCodeGenRegisterString((++counter), "+@@integer")
	OnCodeGenRegisterString((++counter), "-=@@integer")
	OnCodeGenRegisterString((++counter), "-@@integer")
	OnCodeGenRegisterString((++counter), "*@@integer")
	OnCodeGenRegisterString((++counter), "/@@integer")
	OnCodeGenRegisterString((++counter), "++@@integer")
	OnCodeGenRegisterString((++counter), "--@@integer")
	OnCodeGenRegisterString((++counter), "!@@integer")
	OnCodeGenRegisterString((++counter), "++@@real")
	OnCodeGenRegisterString((++counter), "--@@real")
	OnCodeGenRegisterString((++counter), "+=")
	OnCodeGenRegisterString((++counter), "-=")
	OnCodeGenRegisterString((++counter), "!")
	OnCodeGenRegisterString((++counter), "++")
	OnCodeGenRegisterString((++counter), "--")
	OnCodeGenRegisterString((++counter), "&")
	OnCodeGenRegisterString((++counter), "&&")
	OnCodeGenRegisterString((++counter), "!@@boolean")
	OnCodeGenRegisterString((++counter), "cmdlineisvalid")
	OnCodeGenRegisterString((++counter), "cmdlinegetcount")
	OnCodeGenRegisterString((++counter), "cmdlineget")
	OnCodeGenRegisterString((++counter), "==")
	OnCodeGenRegisterString((++counter), "!=")
	OnCodeGenRegisterString((++counter), ">")
	OnCodeGenRegisterString((++counter), "<")
	OnCodeGenRegisterString((++counter), "==@@integer")
	OnCodeGenRegisterString((++counter), "==@@integer16")
	OnCodeGenRegisterString((++counter), "!=@@integer")
	OnCodeGenRegisterString((++counter), "==@@boolean")
	OnCodeGenRegisterString((++counter), "!=@@boolean")
	OnCodeGenRegisterString((++counter), "==@@string")
	OnCodeGenRegisterString((++counter), "!=@@string")
	OnCodeGenRegisterString((++counter), "==@@real")
	OnCodeGenRegisterString((++counter), ">@@integer")
	OnCodeGenRegisterString((++counter), "<@@integer")
	OnCodeGenRegisterString((++counter), ">@@real")
	OnCodeGenRegisterString((++counter), "<@@real")
	OnCodeGenRegisterString((++counter), "print")
	OnCodeGenRegisterString((++counter), "read")
	OnCodeGenRegisterString((++counter), "assert")
	OnCodeGenRegisterString((++counter), "passtest")
	OnCodeGenRegisterString((++counter), "sqrt")
	OnCodeGenRegisterString((++counter), "plotpixel")
	OnCodeGenRegisterString((++counter), "breakpoint")
	OnCodeGenRegisterString((++counter), "if")
	OnCodeGenRegisterString((++counter), "elseif")
	OnCodeGenRegisterString((++counter), "else")
	OnCodeGenRegisterString((++counter), "while")
	OnCodeGenRegisterString((++counter), "do")
	OnCodeGenRegisterString((++counter), "return")
	OnCodeGenRegisterString((++counter), "constructor")
	OnCodeGenRegisterString((++counter), "external")
	OnCodeGenRegisterString((++counter), "@@external")
	OnCodeGenRegisterString((++counter), "nogc")
	OnCodeGenRegisterString((++counter), "sizeof")
	OnCodeGenRegisterString((++counter), "marshalstructure")
	OnCodeGenRegisterString((++counter), "writebuffer")
	OnCodeGenRegisterString((++counter), "writebuffer@@string")
	OnCodeGenRegisterString((++counter), "writebuffer@@multiple")
	OnCodeGenRegisterString((++counter), "writebuffer@@real")
	OnCodeGenRegisterString((++counter), "unescape")
	OnCodeGenRegisterString((++counter), "substring")
	OnCodeGenRegisterString((++counter), "substring@@withlength")
	OnCodeGenRegisterString((++counter), "substring@@nolength")
	OnCodeGenRegisterString((++counter), ";")
	OnCodeGenRegisterString((++counter), "length")
	OnCodeGenRegisterString((++counter), "narrowstring")
	OnCodeGenRegisterString((++counter), "widenfromptr")
	OnCodeGenRegisterString((++counter), "widenfrombuffer")
	OnCodeGenRegisterString((++counter), "string")
	OnCodeGenRegisterString((++counter), "integer")
	OnCodeGenRegisterString((++counter), "integer16")
	OnCodeGenRegisterString((++counter), "real")
	OnCodeGenRegisterString((++counter), "cast@@integer_to_string")
	OnCodeGenRegisterString((++counter), "cast@@string_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@real_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@integer_to_real")
	OnCodeGenRegisterString((++counter), "cast@@boolean_to_string")
	OnCodeGenRegisterString((++counter), "cast@@real_to_string")
	OnCodeGenRegisterString((++counter), "cast@@buffer_to_string")
	OnCodeGenRegisterString((++counter), "cast@@boolean_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@integer_to_integer16")
	OnCodeGenRegisterString((++counter), "cast@@integer16_to_integer")
	OnCodeGenRegisterString((++counter), "cast@@string_to_real")
	OnCodeGenRegisterString((++counter), "boolean")
	OnCodeGenRegisterString((++counter), "buffer")
	OnCodeGenRegisterString((++counter), "nothing")
	OnCodeGenRegisterString((++counter), "buffer@@copy")
	OnCodeGenRegisterString((++counter), "cast")
	OnCodeGenRegisterString((++counter), ".")
	OnCodeGenRegisterString((++counter), "identifier")
	OnCodeGenRegisterString((++counter), "function")

	CurrentStringHandle = counter + 1
}


ReadFile : string filename, integer ref len -> string contents = ""
{
	integer INVALID_HANDLE_VALUE = 0xffffffff
	integer FILE_SHARE_READ = 0x01
	integer OPEN_EXISTING = 3
	integer GENERIC_READ = 0x80000000

	integer filehandle = CreateFile(filename, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0)
	if(filehandle != INVALID_HANDLE_VALUE)
	{
		integer PAGE_READONLY = 0x02
		
		len = GetFileSize(filehandle, 0)

		if(len > 0)
		{
			integer mappinghandle = CreateFileMapping(filehandle, 0, PAGE_READONLY, 0, 0, 0)
			if(mappinghandle != 0)
			{
				integer FILE_MAP_READ = 0x04
				integer ptr = MapViewOfFile(mappinghandle, FILE_MAP_READ, 0, 0, len)

				if(ptr != 0)
				{
					contents = widenfromptr(ptr, len)
				}
				CloseHandle(mappinghandle)
			}
			else
			{
				print("Failed to map file!")
			}
		}
		else
		{
			contents = ""
		}
		CloseHandle(filehandle)
	}
	else
	{
		print("Couldn't open that file!")
	}
}


Parse : string code, integer len -> boolean success = false
{
	Lex(code, len)

	// Discard the dummy token
	PopToken()

	IREnterProgram()

	string token = PeekToken(0)
	while(token != "")
	{
		if(ParseGlobalBlock())
		{
		}
		elseif(ParseSumType())
		{
		}
		elseif(ParseWeakAlias())
		{
		}
		elseif(ParseStrongAlias())
		{
		}
		elseif(ParseStructure())
		{
		}
		elseif(!ParseFunction())
		{
			print("Error: function could not be parsed: " ; token)
			return()
		}

		token = PeekToken(0)
	}

	IRExitProgram()
	success = true
}


Lex : string code, integer len
{
	integer index = 0
	integer lasttokenstart = 0

	integer state = CHARACTER_CLASS_WHITE
	integer prevstate = CHARACTER_CLASS_WHITE

	while(index < len)
	{
		string c = charat(code, index)

		if(state == CHARACTER_CLASS_WHITE)
		{
			if((c == "/") && (charat(code, index + 1) == "/"))
			{
				state = CHARACTER_CLASS_COMMENT
			}
			elseif(!IsWhitespace(c))
			{
				state = Classify(c, state)
				lasttokenstart = index
			}
		}
		elseif(state == CHARACTER_CLASS_IDENTIFIER)
		{
			boolean notidentifier = false
			if(IsWhitespace(c))
			{
				notidentifier = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_IDENTIFIER)
			{
				notidentifier = true
				state = Classify(c, state)
			}

			if(notidentifier)
			{
				PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			}
		}
		elseif(state == CHARACTER_CLASS_PUNCTUATION)
		{
			if(IsWhitespace(c))
			{
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_PUNCTUATION)
			{
				state = Classify(c, state)
			}

			PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			lasttokenstart = index
		}
		elseif(state == CHARACTER_CLASS_PUNCTUATION_COMPOUND)
		{
			boolean notcompound = false
			if(IsWhitespace(c))
			{
				notcompound = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_PUNCTUATION_COMPOUND)
			{
				notcompound = true
				state = Classify(c, state)
			}

			if(notcompound)
			{				
				PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			}
		}
		elseif(state == CHARACTER_CLASS_COMMENT)
		{
			if(c == unescape("\r"))
			{
				state = CHARACTER_CLASS_WHITE
			}
			elseif(c == unescape("\n"))
			{
				state = CHARACTER_CLASS_WHITE
			}
		}
		elseif(state == CHARACTER_CLASS_STRING_LITERAL)
		{
			if(c == unescape("\'"))
			{
				state = CHARACTER_CLASS_WHITE
				PushToken(substring(code, lasttokenstart, index - lasttokenstart + 1))
			}
		}
		elseif(state == CHARACTER_CLASS_LITERAL)
		{
			boolean notliteral = false
			if(IsWhitespace(c))
			{
				notliteral = true
				state = CHARACTER_CLASS_WHITE
			}
			elseif(Classify(c, state) != CHARACTER_CLASS_LITERAL)
			{
				notliteral = true
				state = Classify(c, state)
			}

			if(notliteral)
			{
				PushToken(substring(code, lasttokenstart, index - lasttokenstart))
			}
		}


		if(state != prevstate)
		{
			lasttokenstart = index
		}

		prevstate = state
		++index
	}

	if((lasttokenstart < len) && (state != CHARACTER_CLASS_WHITE))
	{		
		PushToken(substring(code, lasttokenstart, len - lasttokenstart))
	}
}


IsWhitespace : string c -> boolean white = false [nogc]
{
	if(c == " ")
	{
		white = true
	}
	elseif(c == unescape("\r"))
	{
		white = true
	}
	elseif(c == unescape("\n"))
	{
		white = true
	}
	elseif(c == unescape("\t"))
	{
		white = true
	}
}

Classify : string c, integer currentclass -> integer class = CHARACTER_CLASS_IDENTIFIER [nogc]
{
	if(c == "{")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "}")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == ":")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "(")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == ")")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "=")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == ",")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == unescape("\'"))
	{
		class = CHARACTER_CLASS_STRING_LITERAL
	}
	elseif(c == "-")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == ">")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == ".")
	{
		if(currentclass == CHARACTER_CLASS_LITERAL)
		{
			class = CHARACTER_CLASS_LITERAL
		}
		else
		{
			class = CHARACTER_CLASS_PUNCTUATION
		}
	}
	elseif(c == ";")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "!")
	{
		class = CHARACTER_CLASS_PUNCTUATION_COMPOUND
	}
	elseif(c == "[")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "]")
	{
		class = CHARACTER_CLASS_PUNCTUATION
	}
	elseif(c == "0")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "1")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "2")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "3")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "4")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "5")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "6")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "7")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "8")
	{
		class = CHARACTER_CLASS_LITERAL
	}
	elseif(c == "9")
	{
		class = CHARACTER_CLASS_LITERAL
	}
}


// TODO - replace with better option
charat : string in, integer index -> string c = substring(in, index, 1) [nogc]


PushToken : string token
{
	if(length(token) == 0)
	{
		print("Lexer attempted to push a zero-length token!")
		assert(false)
	}

	simple_append<string>(TokenStream, token)
}


DumpStream : simplelist<string> ref tokens
{
	print(tokens.value)
	DumpStream(tokens.next)
}

DumpStream : nothing


PopToken :
{
	PopTokenFromStream(TokenStream, TokenStream.next)
}

PopTokens : integer count
{
	while(count > 0)
	{
		--count
		PopToken()
	}
}

PopTokenFromStream : simplelist<string> ref tokens, simplelist<string> ref tail
{
	tokens = tail
}

PopTokenFromStream : simplelist<string> ref tokens, nothing
{
	tokens.value = ""
}


PeekToken : integer displacement -> string token = PeekTokenInStream(TokenStream, displacement)

PeekTokenInStream : simplelist<string> ref tokens, integer displacement -> string token = tokens.value
{
	if(displacement > 0)
	{
		token = PeekTokenInStream(tokens.next, displacement - 1)
	}
}

PeekTokenInStream : nothing, integer displacement -> ""



PeekWithExpectation : integer displacement, string expected -> boolean found = false
{
	string token = PeekToken(displacement)
	if(token == expected)
	{
		found = true
	}
}


ParseGlobalBlock : -> boolean matched = false
{
	if(PeekToken(0) != "global")
	{
		return()
	}
	
	if(PeekToken(1) != "{")
	{
		return()
	}
	
	PopTokens(2)
	
	integer blockname = PoolString("@@globalblock")
	OnCodeGenRegisterScope(blockname, 0)
	OnCodeGenRegisterGlobalBlock(blockname)
	
	while(PeekToken(0) != "}")
	{
		if(!ParseInitialization(false))
		{
			print("Failure to parse global entry")
			return()
		}
	}
	
	PopToken()
	OnCodeGenExitContext()
	matched = true
}


ParseWeakAlias : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "alias"))
	{
		return()
	}

	if(!PeekWithExpectation(2, "="))
	{
		return()
	}
	
	PopToken()
	string aliasname = PeekToken(0)
	string basename = PeekToken(2)
	PopTokens(3)
	
	OnCodeGenRegisterWeakAlias((++GlobalWeakAliasCounter), PoolString(aliasname), PoolString(basename))
	
	matched = true
}


ParseStrongAlias : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "type"))
	{
		return()
	}

	if(!PeekWithExpectation(2, ":"))
	{
		return()
	}
	
	PopToken()
	string aliasname = PeekToken(0)
	string basename = PeekToken(2)
	PopTokens(3)
	
	OnCodeGenRegisterAlias((++GlobalAliasCounter), PoolString(aliasname), PoolString(basename))
	
	matched = true
}


ParseSumType : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "type"))
	{
		return()
	}
	
	if(!PeekWithExpectation(2, ":"))
	{
		return()
	}
	
	if(!PeekWithExpectation(4, "|"))
	{
		return()
	}
	
	PopToken()
	string sumtypename = PeekToken(0)
	integer typename = PoolString(sumtypename)
	integer typeid = (++GlobalSumTypeCounter)
	PopTokens(2)
	
	while(PeekToken(1) == "|")
	{
		string basename = PeekToken(0)		
		OnCodeGenRegisterSumTypeBase(typename, typeid, PoolString(basename))
		PopTokens(2)
	}
	
	string finalbasename = PeekToken(0)		
	OnCodeGenRegisterSumTypeBase(typename, typeid, PoolString(finalbasename))
	PopToken()
	matched = true
}


ParseStructure : -> boolean matched = false
{
	if(!PeekWithExpectation(0, "structure"))
	{
		return()
	}
	
	if(!PeekWithExpectation(2, ":"))
	{
		return()
	}
	
	PopToken()
	string structurename = PeekToken(0)
	integer structuretype = (++GlobalStructureCounter)
	PopTokens(2)
	
	integer structurenamehandle = PoolString(structurename)

	boolean moremembers = true
	while(moremembers)
	{
		if(PeekToken(0) == "(")
		{
			PopToken()
			
			string memberfuncname = PeekToken(0)
			PopToken()
			
			if(!PeekWithExpectation(0, ":"))
			{
				return()
			}
			
			PopToken()
			
			integer memberfuncnamehandle = PoolString(memberfuncname)
			
			simplelist<integer> paramtypenames = 0, nothing
						
			boolean moreparams = true
			while(moreparams)
			{
				string paramtypename = PeekToken(0)
				PopToken()
				
				simpleprepend<integer>(paramtypenames, PoolString(paramtypename))
				
				if(PeekToken(0) != ",")
				{
					moreparams = false
				}
				else
				{
					PopToken()
				}
			}
			
			integer returntypehandle = 0
			
			if(PeekToken(0) == "->")
			{
				PopToken()
				returntypehandle = PoolString(PeekToken(0))
				PopToken()
			}
			
			OnCodeGenRegisterStructureMemFuncSig(structurenamehandle, structuretype, memberfuncnamehandle, returntypehandle)
			OnCodeGenRegisterStructureMemFuncSigParamList(structurenamehandle, structuretype, memberfuncnamehandle, paramtypenames)
			
			if(!PeekWithExpectation(0, ")"))
			{
				return()
			}
			
			PopToken()
		}
		else
		{
			boolean isref = false
			string membertypename = PeekToken(0)
			PopToken()
			string membername = PeekToken(0)
			PopToken()
			
			if(membername == "ref")
			{
				isref = true
				membername = PeekToken(0)
				PopToken()
			}
			
			OnCodeGenRegisterStructureMemVar(structurenamehandle, structuretype, PoolString(membername), PoolString(membertypename), isref)
		}
		
		if(PeekToken(0) != ",")
		{
			moremembers = false
		}
		else
		{
			PopToken()
		}
	}
	
	matched = true
}


ParseFunction : -> boolean matched = false
{
	string functionname = PeekToken(0)

	if(!PeekWithExpectation(1, ":"))
	{
		return()
	}

	PopTokens(2)
	
	integer rawnamehandle = PoolString(functionname)
	integer namehandle = RegisterOverloadForFunction(rawnamehandle)
	
	OnCodeGenRegisterFunction(namehandle)
	ParseFunctionParams()
	ParseFunctionReturn(namehandle)
	ParseFunctionTags(namehandle, rawnamehandle)

	if(!PeekWithExpectation(0, "{"))
	{
		matched = true
		IREnterFunction(namehandle)
		OnCodeGenEnterFunctionBody(namehandle)
		IRExitFunction()
		return()
	}

	PopTokens(1)
	IREnterFunction(namehandle)
	OnCodeGenEnterFunctionBody(namehandle)

	ParseCodeBlock()
	
	IRExitFunction()
	matched = true
}


ParseFunctionParams :
{
	string typetoken = PeekToken(0)
	if(typetoken == "")
	{
		return()
	}
	
	while((typetoken != "{") && (typetoken != "->"))
	{
		if(typetoken == "nothing")
		{
			integer pooledhandle = PoolString(typetoken)
			
			PopToken()
			IRRegisterFunctionParam(pooledhandle, pooledhandle, false)
		}
		elseif(typetoken == "(")
		{
			PopToken()
			string higherordername = PeekToken(0)
			
			if(PeekWithExpectation(1, ":"))
			{
				PopTokens(2)
				
				boolean moreparams = true
				while(moreparams)
				{
					string paramtypename = PeekToken(0)
					PopToken()
					
					// TODO - register higher order function param
					
					if(PeekToken(0) != ",")
					{
						moreparams = false
					}
					else
					{
						PopToken()
					}
				}
				
				if(PeekToken(0) == "->")
				{
					PopToken()
					string returntypename = PeekToken(0)
					PopToken()
				}
				
				// TODO - register higher order function
				
				if(!PeekWithExpectation(0, ")"))
				{
					print("Error in higher order function parameter syntax")
					return()
				}
				
				PopToken()
			}
		}
		else
		{
			string nametoken = PeekToken(1)
			PopTokens(2)
			
			boolean isreference = false
			if(nametoken == "ref")
			{
				isreference = true
				nametoken = PeekToken(0)
				PopToken()
			}
			
			// TODO - error checking
			// TODO - literal params
			
			IRRegisterFunctionParam(PoolString(nametoken), PoolString(typetoken), isreference)
		}
		
		typetoken = PeekToken(0)
		if(typetoken != ",")
		{
			return()
		}
		PopToken()
		typetoken = PeekToken(0)
	}
}


ParseFunctionReturn : integer namehandle
{
	if(!PeekWithExpectation(0, "->"))
	{
		return()
	}
	
	PopToken()
		
	OnCodeGenEnterFunctionReturn(namehandle, true)
	if(!ParseInitialization(true))
	{
		ParseExpression()
	}
	OnCodeGenExitContext()
}


ParseFunctionTags : integer functionname, integer rawfuncname
{
	if(!PeekWithExpectation(0, "["))
	{
		return()
	}
	
	PopToken()
	
	while(PeekToken(0) != "]")
	{
		ParseSingleFunctionTag(functionname, rawfuncname)
	}
	
	PopToken()
}

ParseSingleFunctionTag : integer functionname, integer rawfuncname
{
	string tagname = PeekToken(0)
	
	if(PeekToken(1) == "(")
	{
		PopTokens(2)
		OnCodeGenRegisterFunctionTag(functionname, tagname, rawfuncname)
		
		string token = PeekToken(0)
		while(token != ")")
		{
			if(token == "")
			{
				print("Incomplete function tag")
				return()
			}
			
			string parameter = PeekToken(0)
			if(substring(parameter, 0, 1) == unescape("\'"))
			{
				parameter = substring(parameter, 1, length(parameter) - 2)
			}
			
			PopToken()
			
			OnCodeGenRegisterFunctionTagParam(functionname, tagname, parameter)

			token = PeekToken(0)
			if(token == ",")
			{
				PopToken()
				token = PeekToken(0)
			}			
		}
		
		PopToken()
	}
	else
	{
		PopToken()
		OnCodeGenRegisterFunctionTag(functionname, tagname, rawfuncname)
	}
	
	if(tagname == "external")
	{
		OnCodeGenRegisterFunctionInvokeTag(functionname, PoolString("@@external"))
	}
}


ParseStatement : boolean substatement -> boolean matched = false
{
	string statementname = PeekToken(0)
	
	if(!PeekWithExpectation(1, "("))
	{
		return()
	}

	if(substatement)
	{
		OnCodeGenEnterSubStatement()
	}
	
	IREnterStatement(statementname, !substatement)
	
	PopTokens(2)

	string token = PeekToken(0)
	while(token != ")")
	{
		if(token == "")
		{
			print("Error: missing a )")
			return()
		}

		if(!ParseExpression())
		{
			print("Error: mangled expression")
			return()
		}
		
		token = PeekToken(0)
		if(token == ",")
		{
			PopToken()
			token = PeekToken(0)
			OnCodeGenShiftParameter()
		}
	}
	
	PopToken()
	IRExitStatement()
	
	if(substatement)
	{
		IRExitStatement()
	}
	
	matched = true
}

ParseInitialization : boolean inreturn -> boolean matched = false
{
	string typename = PeekToken(0)
	string varname = PeekToken(1)
	
	if(varname == ".")
	{
		return()
	}

	if(PeekToken(2) != "=")
	{
		return()
	}

	PopTokens(3)
	
	if(inreturn)
	{
		IREnterExpression()
		OnCodeGenEnterSubStatement()
	}

	IREnterStatement(typename, true)
	IREnterExpression()
	IRAddLiteralIdentifier(varname)
	IRExitExpression()
	
	OnCodeGenShiftParameter()
	
	ParseExpression()
	while(PeekToken(0) == ",")
	{
		PopToken()
		OnCodeGenShiftParameter()
		ParseExpression()
	}
	
	IRExitStatement()

	matched = true
	
	if(inreturn)
	{
		IRExitStatement()
		//OnCodeGenShiftParameter()
		Functions.value.AnonymousReturn = false
	}
}


ParseExpression : -> boolean matched = false
{
	boolean matchedstatement = false
	
	if(!ParseExpressionTerm(true, matchedstatement))
	{
		return()
	}
	
	if(matchedstatement && (PeekToken(0) == ")"))
	{
	}
	else
	{
		while(ParseExpressionOperator())
		{
			ParseExpressionTerm(false, matchedstatement)
		}
	}

	IRExitExpression()
	matched = true
}

ParseExpressionTerm : boolean startsexpr, boolean ref matchedstatement -> boolean matched = false
{
	string term = PeekToken(0)
		
	if(term == ")")
	{
		return()
	}
	elseif(term == ",")
	{
		return()
	}
	elseif(term == "")
	{
		return()
	}
	elseif(term == "(")
	{
		OnCodeGenRegisterParenthetical()
		
		PopToken()
		if(ParseExpression())
		{
			PopToken()
			matched = true
		}
		else
		{
			print("Error in parenthetical expression")
		}
		
		OnCodeGenExitContext()
		
		
		return()
	}
	
	if(startsexpr)
	{
		IREnterExpression()
	}
	
	if(term == "false")
	{
		IRAddLiteralBoolean(false)
	}
	elseif(term == "true")
	{
		IRAddLiteralBoolean(true)
	}
	elseif(term == "0")
	{
		IRAddLiteralInteger(0)
	}
	elseif(term == "0.0")
	{
		IRAddLiteralReal(0.0)
	}
	elseif(ParseStatement(true))
	{
		matched = true
		matchedstatement = true
		return()
	}
	else
	{
		if(substring(term, 0, 1) == unescape("\'"))
		{
			string stringliteral = substring(term, 1, length(term) - 2)
			IRAddLiteralString(stringliteral)			
		}
		else
		{
			if(stringcontains(term, "."))
			{
				real realvalue = cast(real, term)
				IRAddLiteralReal(realvalue)
			}
			else
			{
				integer literalvalue = cast(integer, term)
				if(literalvalue != 0)
				{
					IRAddLiteralInteger(literalvalue)
				}
				else
				{
					IRAddLiteralIdentifier(term)
				}
			}
		}
	}

	PopToken()
	matched = true
}

ParseExpressionOperator : -> boolean matched = false
{
	string op = PeekToken(0)
	if(op == ")")
	{
		return()
	}
	elseif(op == ",")
	{
		return()
	}
	elseif(op == "")
	{
		return()
	}
	

	boolean knownoperator = false
	if(op == "+")
	{
		knownoperator = true
	}
	elseif(op == "-")
	{
		knownoperator = true
	}
	elseif(op == "*")
	{
		knownoperator = true
	}
	elseif(op == "/")
	{
		knownoperator = true
	}
	elseif(op == "==")
	{
		knownoperator = true
	}
	elseif(op == "!=")
	{
		knownoperator = true
	}
	elseif(op == ".")
	{
		knownoperator = true
	}
	elseif(op == ";")
	{
		knownoperator = true
	}
	elseif(op == ">")
	{
		knownoperator = true
	}
	
	if(knownoperator)
	{
		IRAddOperator(op)
		PopToken()
		matched = true
	}
}


ParseAssignment : -> boolean matched = false
{
	integer lhslength = 1
	while(PeekToken(lhslength) == ".")
	{
		lhslength += 2
	}
	
	if(PeekToken(lhslength) != "=")
	{
		return()
	}
	
	if(lhslength == 1)
	{
		OnCodeGenEnterAssignment(PoolString(PeekToken(0)), 0, 0)
	}
	else
	{
		OnCodeGenEnterAssignmentCompound(PoolString(PeekToken(0)), 0, 0)
		integer tokenindex = 2
		while(tokenindex < lhslength)
		{
			OnCodeGenAssignmentCompoundMember(PoolString(PeekToken(tokenindex)))
			tokenindex += 2
		}
		OnCodeGenAssignmentCompoundEnd()
	}
	
	PopTokens(lhslength + 1)
	
	if(ParseExpression())
	{
		matched = true
		OnCodeGenExitContext()
	}
	else
	{
		print("Right hand side of assignment is not a valid expression")
	}
}


ParseEntity : -> boolean matched = false
{
	string entityname = PeekToken(0)
	
	if(entityname == "if")
	{
		if(PeekToken(1) == "(")
		{
			PopTokens(2)
			
			OnCodeGenEnterChain()
			OnCodeGenEnterEntity(0x11, 0)
			
			ParseExpression()
			PopToken()
			
			matched = ParseEntityCode()
			
			while(PeekToken(0) == "elseif")
			{
				PopTokens(2)
				OnCodeGenEnterEntity(0x12, 0)
				ParseExpression()
				PopToken()
				matched = ParseEntityCode()
			}
			
			if(PeekToken(0) == "else")
			{
				PopToken()
				OnCodeGenEnterEntity(0x13, 0)
				matched = ParseEntityCode()
			}
			
			OnCodeGenExitContext()
		}
	}
	elseif(entityname == "while")
	{
		if(PeekToken(1) == "(")
		{
			PopTokens(2)
			
			OnCodeGenEnterChain()
			OnCodeGenEnterEntity(0x14, 0)
			
			ParseExpression()
			PopToken()

			matched = ParseEntityCode()
			
			OnCodeGenExitContext()
		}
	}
}

ParseCodeBlock :
{
	string token = PeekToken(0)
	while(token != "}")
	{
		if(token == "")
		{
			print("Error: missing a }")
			return()
		}

		if(ParseEntity())
		{
		}
		elseif(ParseStatement(false))
		{
		}
		elseif(ParseInitialization(false))
		{
		}
		elseif(ParseAssignment())
		{
		}
		else
		{
			print("Parse failure: " ; PeekToken(0) ; " " ; PeekToken(1) ; " " ; PeekToken(2))
			return()
		}
		
		token = PeekToken(0)
	}

	PopToken()
}


ParseEntityCode : -> boolean matched = false
{
	if(PeekToken(0) == "{")
	{
		OnCodeGenEnterEntityCode()
		PopToken()
		ParseCodeBlock()
		OnCodeGenExitContext()
		OnCodeGenExitContext()
		matched = true
	}
	else
	{
		print("Expected code block")
	}
}


//
// List traversal/inspection functions
//

map<type T> : list<T> ref thelist, (func : T)
{
	func(thelist.value)
	map<T>(thelist.next, func)
}

map<type T> : nothing, (func : T)
{
}


listcontains : simplelist<integer> ref thelist, integer value -> boolean ret = false
{
	if(thelist.value == value)
	{
		ret = true
	}
	else
	{
		ret = listcontains(thelist.next, value)
	}
}

listcontains : nothing, integer value -> boolean contains = false



TypeListContains : simplelist<integer> ref thelist, integer value -> integer ret = 0
{
	integer listval = thelist.value
	if((listval & 0x7f000000) == 0x05000000)
	{
		listval = FindTypeAliasBase(TypeAliases, listval)
	}
	
	if((value & 0x7f000000) == 0x07000000)
	{
		if(SumTypeHasBase(SumTypes, MakeNonReferenceType(value), MakeNonReferenceType(listval)))
		{
			ret = value
			return()
		}
	}
	
	if((listval & 0x7f000000) == 0x07000000)
	{
		if(SumTypeHasBase(SumTypes, listval, MakeNonReferenceType(value)))
		{
			ret = value
			return()
		}
	}
	
	if(MakeNonReferenceType(listval) == value)
	{
		ret = listval
	}
	elseif(listval == value)
	{
		ret = listval
	}
	else
	{
		ret = TypeListContains(thelist.next, value)
	}
}

TypeListContains : nothing, integer value -> 0



//
// Callback used to emit a byte to a bytecode stream
//

OnBytecodeEmitByte : integer b
{
	writebuffer(Hack, HackSize, b)
	++HackSize
}


//
// Callback used to emit a series of bytes to a bytecode stream
//

OnBytecodeEmitBytes : integer bytes, integer size
{
	writebuffer(Hack, HackSize, bytes, size)
	HackSize += size
}


//
// Callback used to retrieve a bytecode stream's pointer
//

OnBytecodeGetBuffer : -> buffer ret = Hack


//
// Callback used to retrieve the size of a bytecode stream
//

OnBytecodeGetSize : -> integer size = HackSize



OnBytecodeEmitInteger : integer value
{
	writebuffer(Hack, HackSize, (value) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x100) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x10000) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (value / 0x1000000) & 0xff)
	++HackSize
}

OnBytecodeEmitInteger16 : integer16 value
{
	integer v = cast(integer, value)
	writebuffer(Hack, HackSize, (v) & 0xff)
	++HackSize
	writebuffer(Hack, HackSize, (v / 0x100) & 0xff)
	++HackSize
}

OnBytecodeEmitReal : real value
{
	writebuffer(Hack, HackSize, value)
	HackSize = HackSize + 4
}

OnBytecodeEmitString : string value
{
	integer len = (length(value) + 1) * 2
	writebuffer(Hack, HackSize, value, len)
	HackSize += len
}

OnBytecodeEmitBoolean : boolean value
{
	OnBytecodeEmitByte(cast(integer, value))
}


OnBytecodePoolString : integer handle, string data
{
	OnBytecodeEmitByte(0x10)			// PoolString instruction
	OnBytecodeEmitInteger(handle)
	OnBytecodeEmitString(data)
}

OnBytecodeLexicalScope : integer name, integer parent, integer count
{
	OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(parent)
	OnBytecodeEmitInteger(count)
}

OnBytecodeLexicalScopeEntry : integer varname, integer vartype, integer origin
{
	OnBytecodeEmitInteger(varname)
	OnBytecodeEmitInteger(vartype)
	OnBytecodeEmitInteger(origin)
	OnBytecodeEmitBoolean(false)
}

OnBytecodeInvokeOffset : integer name
{
	OnBytecodeEmitByte(0x27)			// InvokeOffset instruction
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(0)
}

OnBytecodeHalt :
{
	OnBytecodeEmitByte(0x00)			// Halt instruction
}

OnBytecodeEnterFunction : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x01)			// EntityTags::Function
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitFunction :
{
	OnBytecodeEmitByte(0x09)			// Return instruction
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeInvoke : integer target
{
	OnBytecodeEmitByte(0x07)			// Invoke instruction
	OnBytecodeEmitInteger(target)
}

OnBytecodeEnterEntity : integer tag, integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(tag)
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitEntity :
{
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeBeginChain :
{
	OnBytecodeEmitByte(0x0d)			// BeginChain instruction
}

OnBytecodeEndChain :
{
	OnBytecodeEmitByte(0x0e)			// EndChain instruction
}

OnBytecodeDefineStructure : integer typeid, integer nummembers
{
	OnBytecodeEmitByte(0x14)			// DefineStructure instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(nummembers)
}

OnBytecodeStructureMember : integer name, integer typeid
{
	OnBytecodeEmitInteger(name)
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeReadReference :
{
	OnBytecodeEmitByte(0x17)			// ReadRef instruction
}

OnBytecodeReadReferenceAnnotated :
{
	OnBytecodeEmitByte(0x24)			// ReadRefAnnotated instruction
}

OnBytecodeAllocStructure : integer typeid
{
	OnBytecodeEmitByte(0x13)			// AllocStructure instruction
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeBindReference : integer frameskip, integer index
{
	if(index < 0)
	{
		print("Binding reference to a missing variable!")
		assert(false)
	}

	OnBytecodeEmitByte(0x03)			// BindRef instruction
	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(index)
}

OnBytecodeAssign :
{
	OnBytecodeEmitByte(0x06)			// Assign instruction
}

OnBytecodePushVarValueNoCopy : integer name
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(name)
}

OnBytecodePushVarValue : integer name, integer typeid
{
	OnBytecodePushVarValueNoCopy(name)
	
	integer family = typeid & 0x7f000000

	if(typeid == 0x02000001)			// Buffer type signature
	{
		OnBytecodeCopyBuffer()
	}
	//elseif(family == 0x03000000)			// Structure family signature
	//{
	//	OnBytecodeCopyStructure()
	//}
	//elseif(family == 0x08000000)			// Template instance family signature
	//{
	//	OnBytecodeCopyStructure()
	//}
}

OnBytecodeCopyBuffer :
{
	OnBytecodeEmitByte(0x19)			// CopyBuffer instruction
}

OnBytecodeCopyStructure :
{
	OnBytecodeEmitByte(0x1b)			// CopyStructure instruction
}

OnBytecodeCopyToStructure : integer structurename, integer membername
{
	OnBytecodeEmitByte(0x16)			// CopyToStructure instruction
	OnBytecodeEmitInteger(structurename)
	OnBytecodeEmitInteger(membername)
}

OnBytecodeSetReturnRegister : integer varindex
{
	OnBytecodeEmitByte(0x0a)			// SetRetVal instruction
	OnBytecodeEmitInteger(varindex)
}

OnBytecodePushVarNoCopy : integer varname
{
	OnBytecodeEmitByte(0x05)			// Read instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeInvokeIndirect : integer varname
{
	OnBytecodeEmitByte(0x08)			// InvokeIndirect instruction
	OnBytecodeEmitInteger(varname)
}

OnBytecodeEnterPatternResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x02)			// EntityTags::PatternMatchingResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitPatternResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodeConstructSumType :
{
	OnBytecodeEmitByte(0x21)			// ConstructSumType instruction
}

OnBytecodeEnterTypeResolver : integer name
{
	OnBytecodeEmitByte(0x0b)			// BeginEntity instruction
	OnBytecodeEmitInteger(0x05)			// EntityTags::TypeResolver
	OnBytecodeEmitInteger(name)
}

OnBytecodeExitTypeResolver :
{
	OnBytecodeHalt()
	OnBytecodeEmitByte(0x0c)			// EndEntity instruction
}

OnBytecodePopStack : integer bytes
{
	OnBytecodeEmitByte(0x04)			// Pop instruction
	OnBytecodeEmitInteger(bytes)
}

OnBytecodeBindRefByHandle : integer id
{
	OnBytecodeEmitByte(0x1d)
	OnBytecodeEmitInteger(id)
}

OnBytecodeBindStructReference : integer membertype, integer memberoffset
{
	OnBytecodeEmitByte(0x18)			// BindMemberRef instruction
	OnBytecodeEmitInteger(MakeNonReferenceType(membertype))
	OnBytecodeEmitInteger(memberoffset)
}

OnBytecodePushType : integer typeid
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(typeid)
}

OnBytecodeAssignSumType :
{
	OnBytecodeEmitByte(0x23)			// AssignSumType instruction
}

OnBytecodePushLocal : boolean isparam, integer frameskip, integer offset, integer size
{
	if(isparam)
	{
		OnBytecodeEmitByte(0x26)		// ReadParam instruction
	}
	else
	{
		OnBytecodeEmitByte(0x25)		// ReadStack instruction
	}

	OnBytecodeEmitInteger(frameskip)
	OnBytecodeEmitInteger(offset)
	OnBytecodeEmitInteger(size)
}

OnBytecodePushBoolean : boolean literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000003)		// Boolean type signature
	OnBytecodeEmitBoolean(literal)
}

OnBytecodePushLiteralString : integer literalhandle
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x02000000)		// String type signature
	OnBytecodeEmitInteger(literalhandle)
}

OnBytecodePushLiteralInteger : integer literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(literal)
}

OnBytecodePushLiteralInteger16 : integer16 literal
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000002)		// Integer16 type signature
	OnBytecodeEmitInteger16(literal)
}

OnBytecodePushTypeAnnotation : integer annotation
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000001)		// Integer type signature
	OnBytecodeEmitInteger(annotation)
}

OnBytecodePushLiteralFunction : integer name
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x09000000)		// Function family signature (N.B. not the actual function type!)
	OnBytecodeEmitInteger(name)
}

OnBytecodePushLiteralReal : real value
{
	OnBytecodeEmitByte(0x02)			// Push instruction
	OnBytecodeEmitInteger(0x01000004)		// Real type signature
	OnBytecodeEmitReal(value)
}

OnBytecodeEmitFunctionSignature : integer typeid, integer rettype, integer paramcount
{
	OnBytecodeEmitByte(0x28)			// FuncSig instruction
	OnBytecodeEmitInteger(typeid)
	OnBytecodeEmitInteger(rettype)
	OnBytecodeEmitInteger(paramcount)
}

OnBytecodeEmitFunctionSigParam : integer paramtype
{
	OnBytecodeEmitInteger(paramtype)
	OnBytecodeEmitBoolean(false)
}


GetTypeSize : integer typeid -> integer size = 0
{
	if(typeid == 0x01000001)			// Integer
	{
		size = 4
	}
	elseif(typeid == 0x01000002)			// Integer16
	{
		size = 2
	}
	elseif(typeid == 0x01000003)			// Boolean
	{
		size = 1
	}
	elseif(typeid == 0x01000004)			// Real
	{
		size = 4
	}
	elseif(typeid == 0x02000000)			// StringHandle
	{
		size = 4
	}
	elseif(IsStructureType(typeid))			// StructureHandle
	{
		size = 4
	}
	elseif((typeid & 0xff000000) == 0x07000000)	// SumType
	{
		size = 4 + GetLargestSumTypeBaseSize(typeid)
	}
	elseif(typeid == 0x00000004)			// Nothing
	{
		size = 0
	}
	else
	{
		print("Undefined type for size retrieval - " ; cast(string, typeid))
		assert(false)
	}
}


//
// Data structures for holding the internal representation of a compiled program
//

structure StringTableEntry :
	integer Handle,
	string Data

structure TypeAlias :
	integer TypeID,
	integer AliasNameHandle,
	integer BaseNameHandle

structure StructureMemberVariable :
	integer Name,
	integer Type,
	integer TypeNameHandle

structure StructureMemberFunctionRef :
	integer Name,
	FunctionSignature ref Signature


type StructureMember : StructureMemberVariable | StructureMemberFunctionRef

structure StructureDefinition :
	integer Name,
	integer Type,
	integer ConstructorName,
	integer AnonConstructorName,
	integer CopyConstructorName,
	list<StructureMember> ref Members


structure IdentifierAtom :
	integer Handle,
	integer Type,
	boolean IsReference

structure StringHandleAtom :
	integer Handle

structure OperatorInvokeAtom :
	integer OperatorName

structure TypeAnnotationAtom :
	integer Type

structure RefBinding :
	integer Identifier,
	integer StructureName,
	boolean IsReference,
	boolean InputIsReference
	
structure CompoundAtom :
	list<RefBinding> ref Bindings,
	integer Type

structure AtomSentinel :
	integer dummy


type ExpressionAtom : 	integer | integer16 | boolean | real | StringHandleAtom |
			IdentifierAtom | OperatorInvokeAtom | TypeAnnotationAtom | RefBinding |
			CompoundAtom |
			Statement |
			ParentheticalExpression |
			AtomSentinel


structure Expression :
	list<ExpressionAtom> ref Atoms,
	integer Type

type OptionalExpression : Expression | nothing

structure ExpressionList :
	list<Expression> ref Expressions

type OptionalExpressionList : ExpressionList | nothing


structure ParentheticalExpression :
	Expression ref Inner


structure Statement :
	integer Name,
	OptionalExpressionList Parameters,
	integer Type,
	boolean TopLevel

structure Assignment :
	integer LHSName,
	integer LHSType,
	integer Annotation,
	Expression ref RHS

structure AssignmentCompound :
	simplelist<integer> ref LHS,
	integer LHSType,
	integer Annotation,
	Expression ref RHS

structure PreOpStatement :
	integer Operator,
	simplelist<integer> ref Operand

structure PostOpStatement :
	integer Operator,
	simplelist<integer> ref Operand


type CodeBlockEntry : Statement | PreOpStatement | PostOpStatement |
		      Assignment | AssignmentCompound | EntityChain

structure CodeBlock :
	list<CodeBlockEntry> ref Entries

type OptionalCodeBlock : CodeBlock | nothing

structure Entity :
	integer Tag,
	integer PostfixTag,
	OptionalExpression Param,
	OptionalCodeBlock Code


structure EntityList :
	list<Entity> ref ActualList

type OptionalEntityList : EntityList | nothing


structure EntityChain :
	OptionalEntityList Entries
		
		
structure UnresolvedParameter :
	integer NameHandle,
	integer TypeNameHandle,
	integer ResolvedType,
	boolean HasRefTag
		
structure FunctionParams :
	list<UnresolvedParameter> ref Params
	
type OptionalParameters : FunctionParams | nothing

structure Overload :
	integer NormalName,
	integer MangledName

structure FunctionDefinition :
	integer Name,
	OptionalExpression Return,
	OptionalCodeBlock Code,
	boolean AnonymousReturn,
	integer InvokeTag,
	OptionalParameters Params,
	boolean InferenceDone


structure Variable :
	integer Name,
	integer VarType,
	integer Origin,
	integer Offset

structure Scope :
	integer Name,
	integer ParentName,
	list<Variable> Variables,
	integer ParamOffset,
	integer LocalOffset


structure Parameter :
	integer Name,
	integer Type
	

structure ContextStackEntry :
	integer EntryType,
	integer EntryName


structure SumType :
	integer Name,
	integer Type,
	simplelist<integer> Bases


structure FunctionSignature :
	integer Name,
	list<Parameter> ref Parameters,
	integer ReturnTypeName

structure PendingTypeMatcher :
	integer OverloadName,
	integer MatcherName

structure TypeMatcher :
	integer Name,
	list<FunctionSignature> ref Overloads


structure FunctionTag :
	integer FunctionName,
	string TagName,
	list<string> ref Parameters




//
// Callback invoked when the code generation process can begin
//

OnCodeGenProcessProgram :
{
	GeneratePendingTypeMatchers(PendingTypeMatchers)

	CodeGenEmitStrings(GlobalStrings)
	CodeGenEmitSumTypes(SumTypes)
	CodeGenRearrangeStructures(Structures)
	CodeGenEmitStructures(Structures)
	CodeGenEmitFunctionSignatures(FunctionSignatures)
	
	if(GlobalCodeBlockName != 0)
	{
		CodeGenEmitSpecificScope(Scopes, GlobalCodeBlockName)
	}
	
	CodeGenEmitScopes(Scopes)
	CodeGenEmitFunctionTags(FunctionTags)
	CodeGenEmitGlobalBlockPrologue(GlobalCodeBlock)
	CodeGenEmitFunctions(Functions)
	CodeGenEmitGlobalBlockEpilogue(GlobalCodeBlock)
	CodeGenEmitTypeMatchers(TypeMatchers)
	CodeGenEmitConstructors(Structures)
}

OnCodeGenRegisterString : integer handle, string data
{
	StringTableEntry entry = handle, data
	prepend<StringTableEntry>(GlobalStrings, entry)

	if(handle > CurrentStringHandle)
	{
		CurrentStringHandle = handle
	}
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer typenamehandle, boolean isref
{
	integer refnum = 0
	if(isref)
	{
		refnum = 0x80000000
	}

	StructureMemberVariable member = membername, refnum, typenamehandle
	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettypename
{
	list<Parameter> p = dummyparam, nothing
	FunctionSignature signature = name, p, rettypename
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype
{
	Parameter param = 1, paramtype
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, simplelist<integer> ref typenames
{
	OnCodeGenRegisterStructureMemFuncSigParamList(structurename, structuretype, membername, typenames.next)
	
	if(typenames.value != 0)
	{
		OnCodeGenRegisterStructureMemFuncSigParam(structurename, structuretype, membername, typenames.value)
	}
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, nothing



FindStructureAndAddMember : list<StructureDefinition> ref structures, integer structurename, integer structuretype, StructureMember ref member
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMember(structures.value.Members, structures.value.Members.next, member)
	}
	else
	{
		FindStructureAndAddMember(structures.next, structurename, structuretype, member)
	}
}

FindStructureAndAddMember : nothing, integer structurename, integer structuretype, StructureMember ref member
{
	list<StructureMember> members = member, nothing
	StructureDefinition def = structurename, structuretype, 0, 0, 0, members

	AppendStructure(Structures, Structures.next, def)
}

AppendStructure : list<StructureDefinition> ref structures, list<StructureDefinition> ref tail, StructureDefinition ref def
{
	AppendStructure(tail, tail.next, def)
}

AppendStructure : list<StructureDefinition> ref structures, nothing, StructureDefinition ref def
{
	list<StructureDefinition> newtail = def, nothing
	structures.next = newtail
}

AppendStructureMember : list<StructureMember> ref members, list<StructureMember> ref tail, StructureMember ref member
{
	AppendStructureMember(tail, tail.next, member)
}

AppendStructureMember : list<StructureMember> ref members, nothing, StructureMember ref member
{
	list<StructureMember> newtail = member, nothing
	members.next = newtail
}


FindStructureAndAddMemberParam : list<StructureDefinition> ref structures, integer structurename, integer structuretype, integer membername, Parameter ref param
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMemberParam(structures.value.Members, membername, param)
	}
	else
	{
		FindStructureAndAddMemberParam(structures.next, structurename, structuretype, membername, param)
	}
}

AppendStructureMemberParam : list<StructureMember> ref members, integer membername, Parameter ref param
{
	boolean match = CheckMemberForAddingParam(members.value, membername, param)
	if(!match)
	{
		AppendStructureMemberParam(members.next, membername, param)
	}
}

CheckMemberForAddingParam : StructureMemberVariable ref member, integer membername, Parameter ref param -> false

CheckMemberForAddingParam : StructureMemberFunctionRef ref member, integer membername, Parameter ref param -> boolean ret = false
{
	if(member.Name == membername)
	{
		AppendParameter(member.Signature.Parameters, param)
		ret = true
	}
}



OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname
{
	FindStructureAndSetConstructors(Structures, structurename, constructorname, anonname, copyname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, constructorname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, anonname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, copyname)
}

FindStructureAndSetConstructors : list<StructureDefinition> ref structures, integer structurename, integer constructorname, integer anonname, integer copyname
{
	if(structures.value.Name == structurename)
	{
		structures.value.ConstructorName = constructorname
		structures.value.AnonConstructorName = anonname
		structures.value.CopyConstructorName = copyname
	}
	else
	{
		FindStructureAndSetConstructors(structures.next, structurename, constructorname, anonname, copyname)
	}
}

FindStructureAndSetConstructors : nothing, integer structurename, integer constructorname, integer anonname, integer copyname



OnCodeGenRegisterSumTypeBase : integer sumtypename, integer sumtypeid, integer basetypeid
{
	FindSumTypeAndAddBase(SumTypes, sumtypename, sumtypeid, basetypeid)
}


FindSumTypeAndAddBase : list<SumType> ref sumtypes, integer sumtypename, integer sumtypeid, integer basetypeid
{
	if(sumtypes.value.Type == sumtypeid)
	{
		simpleprepend<integer>(sumtypes.value.Bases, basetypeid)
	}
	else
	{
		FindSumTypeAndAddBase(sumtypes.next, sumtypename, sumtypeid, basetypeid)
	}
}

FindSumTypeAndAddBase : nothing, integer sumtypename, integer sumtypeid, integer basetypeid
{
	simplelist<integer> bases = basetypeid, nothing
	SumType st = sumtypename, sumtypeid, bases
	prepend<SumType>(SumTypes, st)
}



OnCodeGenRegisterScope : integer scopename, integer parentname
{
	list<Variable> v = dummyvar, nothing
	Scope scope = scopename, parentname, v, 0, 0
	prepend<Scope>(Scopes, scope)
}

OnCodeGenRegisterVariable : integer scopename, integer varname, integer vartype, integer origin
{
	StoreVariableInScope(Scopes, scopename, varname, vartype, false, origin)
}

StoreVariableInScope : list<Scope> ref scopes, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	if(scopes.value.Name == scopename)
	{
		integer size = 4		// TODO - actual variable sizes

		if((vartype & 0xff000000) == 0x07000000)		// Sum type family signature
		{
			size = 8
		}

		integer offset = -1
		if(origin == 1)			// VARIABLE_ORIGIN_PARAMETER
		{
			if(isref)
			{
				size = 8
			}

			offset = scopes.value.ParamOffset
			scopes.value.ParamOffset = scopes.value.ParamOffset + size
		}
		else
		{
			offset = scopes.value.LocalOffset
			scopes.value.LocalOffset = scopes.value.LocalOffset + size
		}

		Variable var = varname, vartype, origin, offset
		append(scopes.value.Variables, var)
	}
	else
	{
		StoreVariableInScope(scopes.next, scopename, varname, vartype, isref, origin)
	}
}

StoreVariableInScope : nothing, integer scopename, integer varname, integer vartype, boolean isref, integer origin
{
	print("No scope available for identifier " ; GetPooledString(GlobalStrings, scopename))
	assert(false)
}


OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
}


RegisterOverloadForFunction : integer rawname -> integer mangledname = rawname
{
	integer existingcount = CountOverloads(Overloads, rawname)
	if(existingcount > 0)
	{
		mangledname = PoolString(GetPooledString(GlobalStrings, rawname) ; "@overload@" ; cast(string, existingcount))
	}
	
	Overload overload = rawname, mangledname
	prepend<Overload>(Overloads, overload)
}


CountOverloads : list<Overload> ref overloads, integer rawname -> integer count = 0
{
	if(rawname == overloads.value.NormalName)
	{
		++count
	}
	
	count += CountOverloads(overloads.next, rawname)
}

CountOverloads : nothing, integer rawname -> 0


OnCodeGenRegisterFunction : integer funcname
{
	FunctionDefinition func = funcname, nothing, nothing, false, 0, nothing, false
	prepend<FunctionDefinition>(Functions, func)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack
}

IRRegisterFunctionParam : integer paramname, integer paramtypename, boolean isref
{
	UnresolvedParameter p = paramname, paramtypename, 0, isref
	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, FunctionParams ref params, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(params.Params, params.Params.next, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	OptionalParameters params = newlist
	func.Params = params
}


AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, list<UnresolvedParameter> ref tail, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(tail, tail.next, p)
}

AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	thelist.next = newlist
}


OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyexpression
	ScratchExpressions.value = d

	Functions.value.AnonymousReturn = anonymous
	InFuncRetHack = true
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	PopContext(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToSubStatement(ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToSubStatement(ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
		InFuncRetHack = false
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		assert(CodeBlockDepth(CurrentCodeBlockStack) == 1)
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		AppendEntityToChain(ChainStack, entity)
		PopEntityStack(EntityStack, EntityStack.next)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		EntityChain chain = ChainStack.value
		CodeBlockEntry cbe = chain
		AppendEntryToCurrentCodeBlock(cbe)
		PopChain(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		ParentheticalExpression parenthetical = ScratchExpressions.value
		ExpressionAtom atom = parenthetical
		PopExpression(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}

PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	print("No contexts available")
	assert(false)
}

PopExpression : list<Expression> ref thelist, list<Expression> ref next
{
	thelist = next
}

PopExpression : list<Expression> ref thelist, nothing



PopCodeBlock : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref next
{
	stack = next
}

PopCodeBlock : list<OptionalCodeBlock> ref stack, nothing
{
	list<OptionalCodeBlock> newlist = nothing, nothing
	stack = newlist
}


PopEntityStack : list<Entity> ref stack, list<Entity> ref next
{
	stack = next
}

PopEntityStack : list<Entity> ref stack, nothing


PopChain : list<EntityChain> ref stack, list<EntityChain> ref next
{
	stack = next
}

PopChain : list<EntityChain> ref stack, nothing



PopCurrentStatementAndAppendToScratchExpression : list<Expression> ref expressions, list<Expression> ref tail
{
	Statement stmt = SubStatements.value
	ExpressionAtom atom = stmt

	expressions = tail

	PlaceAtomInScratchExpression(atom)
	PopSubStatement(SubStatements, SubStatements.next)
}

SetReturnExpression : FunctionDefinition ref funcdef, Expression ref expr
{
	funcdef.Return = expr

	Expression d = dummyexpression
	ScratchExpressions.value = d
}

SetGlobalCodeBlock : CodeBlock ref block
{
	GlobalCodeBlock = block
}

SetGlobalCodeBlock : nothing


PopSubStatement : list<Statement> ref statements, list<Statement> ref tail
{
	statements = tail
}



AppendExpressionToSubStatement : Expression ref expr
{
	AppendExpressionToStatement(SubStatements.value, expr)
}


OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	list<FunctionSignature> dsl = dummysignature, nothing
	TypeMatcher matcher = matchername, dsl
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


PlaceAtomInScratchExpression : ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(ScratchExpressions.value.Atoms.value))
	{
		list<ExpressionAtom> atoms = atom, nothing
		ScratchExpressions.value = Expression(atoms, 0)
	}
	else
	{
		AppendAtomToExpression(ScratchExpressions.value.Atoms, ScratchExpressions.value.Atoms.next, atom)
	}
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0xff000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(TypeAliases, literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifierReference : integer idhandle
{
	IdentifierAtom id = idhandle, 0, true
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterTypeAnnotation : integer annotationtype
{
	TypeAnnotationAtom taa = annotationtype
	ExpressionAtom atom = taa
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}


ExpressionAtomIsSentinel : AtomSentinel 	   ref sentinel    -> true
ExpressionAtomIsSentinel : StringHandleAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : IdentifierAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : OperatorInvokeAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : TypeAnnotationAtom 	   ref nonsentinel -> false
ExpressionAtomIsSentinel : integer 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : integer16 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : boolean 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : real 		   ref nonsentinel -> false
ExpressionAtomIsSentinel : Statement		   ref nonsentinel -> false
ExpressionAtomIsSentinel : RefBinding              ref nonsentinel -> false
ExpressionAtomIsSentinel : CompoundAtom            ref nonsentinel -> false
ExpressionAtomIsSentinel : ParentheticalExpression ref nonsentinel -> false



AppendAtomToExpression : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, ExpressionAtom ref atom
{
	AppendAtomToExpression(tail, tail.next, atom)
}

AppendAtomToExpression : list<ExpressionAtom> ref atoms, nothing, ExpressionAtom ref atom
{
	list<ExpressionAtom> newatoms = atom, nothing
	atoms.next = newatoms
}


OnCodeGenEnterStatement : integer statementname, integer statementtype, boolean toplevel
{
	Statement statement = statementname, nothing, statementtype, toplevel

	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statementname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}

OnCodeGenEnterAssignment : integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	Assignment assignment = lhsname, lhstype, annotation, tempexpr
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpressions.value = Expression(dummyatomlist, 0)
}


OnCodeGenEnterAssignmentCompound : integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	AssignmentCompound assignment = idlist, lhstype, annotation, tempexpr
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundMember : integer membername
{
	FindCurrentFunctionAndAppendCompoundMember(membername)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	ScratchExpressions.value = Expression(dummyatomlist, 0)
}


OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}



AppendEntryToCurrentCodeBlock : CodeBlockEntry ref cbe
{
	AppendEntryToCurrentCodeBlockWorker(CurrentCodeBlockStack, cbe)
}

AppendEntryToCurrentCodeBlockWorker : list<OptionalCodeBlock> ref blockstack, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(blockstack, blockstack.value, entry)
}

AppendEntryToCurrentCodeBlockWorker : nothing, CodeBlockEntry ref entry
{
	print("No code block is being processed")
	assert(false)
}


FindCurrentFunctionAndAppendCompoundMember : integer membername
{
	FindLastAssignmentAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}



FindLastAssignmentAndAppendCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(code.Entries, code.Entries.next, membername)
}



AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, CodeBlock ref code, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(code.Entries, entry)
}

AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> stmtlist = entry, nothing
	CodeBlock block = stmtlist
	OptionalCodeBlock blockwrap = block
	stack.value = blockwrap
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(entries, entries.next, entry)
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> newlist = entry, nothing
	entries.next = newlist
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, CodeBlockEntry ref value
{
	AppendEntryToCodeBlock(tail, tail.next, value)
}


FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}

AppendCompoundMemberHelper : AssignmentCompound ref a, integer membername
{
	AppendCompoundMember(a.LHS, a.LHS.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, simplelist<integer> ref tail, integer membername
{
	AppendCompoundMember(tail, tail.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, nothing, integer membername
{
	simplelist<integer> newtail = membername, nothing
	members.next = newtail
}



FindCurrentStatementAndAppendExpression : Expression ref expression
{
	FindLastStatementInBlockAndAppendExpression(CurrentCodeBlockStack.value, expression)
}

FindCurrentStatementAndAppendExpression : nothing


FindCurrentAssignmentAndSetExpression : Expression ref expression
{
	FindLastAssignmentInBlockAndSetExpression(CurrentCodeBlockStack.value, expression)
}



FindLastStatementInBlockAndAppendExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastStatementAndAppendExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastStatementInBlockAndAppendExpression : nothing, Expression ref expression
{
	print("Not processing an active code block!")
	assert(false)
}


FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastStatementAndAppendExpression(tail, tail.next, expression)
}

FindLastStatementAndAppendExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	AppendExpressionToStatement(codeblockentries.value, expression)
}


AppendExpressionToStatement : Statement ref statement, Expression ref expression
{
	AppendExpressionToStatementParams(statement, statement.Parameters, expression)
}

AppendExpressionToStatementParams : Statement ref statement, ExpressionList ref parameters, Expression ref expression
{
	AppendExpression(parameters.Expressions, parameters.Expressions.next, expression)
}

AppendExpressionToStatementParams : Statement ref statement, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	ExpressionList params = newlist
	statement.Parameters = params
}

AppendExpression : list<Expression> ref expressions, list<Expression> ref tail, Expression ref expression
{
	AppendExpression(tail, tail.next, expression)
}

AppendExpression : list<Expression> ref expressions, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	expressions.next = newlist
}


FindLastAssignmentInBlockAndSetExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastAssignmentAndSetExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastAssignmentAndSetExpression(tail, tail.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	SetAssignmentExpression(codeblockentries.value, expression)
}

SetAssignmentExpression : Assignment ref assignment, Expression ref expression
{
	assignment.RHS = expression
}

SetAssignmentExpression : AssignmentCompound ref assignment, Expression ref expression
{
	assignment.RHS = expression
}



SetFunctionCodeBlock : FunctionDefinition ref funcdef, OptionalCodeBlock ref optblock
{
	SetFunctionCodeBlockWorker(funcdef, optblock)
}

SetFunctionCodeBlock : nothing, OptionalCodeBlock ref optblock
{
	print("No function in flight")
	assert(false)
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, CodeBlock ref block
{
	funcdef.Code = block
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, nothing



CodeGenEmitStrings : list<StringTableEntry> ref table
{
	map<StringTableEntry>(table, CodeGenEmitSingleString)
}

CodeGenEmitSingleString : StringTableEntry entry			// TODO - this should be passed by ref
{
	if(entry.Handle != 0)
	{
		OnBytecodePoolString(entry.Handle, entry.Data)
	}
}


CodeGenEmitStructures : list<StructureDefinition> ref structures
{
	CodeGenEmitStructures(structures.next)
	CodeGenEmitSingleStructure(structures.value)
}

CodeGenEmitStructures : nothing


CodeGenEmitSingleStructure : StructureDefinition ref def
{
	if(def.Name != 0)
	{
		integer membercount = CountMembers(def.Members)
		OnBytecodeDefineStructure(def.Type, membercount)
		CodeGenEmitMembers(def.Members)
	}
}

CodeGenEmitMembers : list<StructureMember> ref members
{
	CodeGenEmitMember(members.value)
	CodeGenEmitMembers(members.next)
}

CodeGenEmitMembers : nothing

CodeGenEmitMember : StructureMemberVariable ref memvar
{
	OnBytecodeStructureMember(memvar.Name, memvar.Type)
}

CodeGenEmitMember : StructureMemberFunctionRef ref member
{
	OnBytecodeStructureMember(member.Name, 0x09000000)
}


CountMembers : list<StructureMember> ref members -> integer count = 0
{
	CountMembers(members, count)
}

CountMembers : list<StructureMember> ref members, integer ref count
{
	++count
	CountMembers(members.next, count)
}

CountMembers : nothing, integer ref count





CodeGenEmitScopes : list<Scope> ref scopes
{
	CodeGenEmitScopes(scopes.next)
	CodeGenEmitSingleScope(scopes.value, scopes.value.Name)
}

CodeGenEmitScopes : nothing


CodeGenEmitSingleScope : Scope ref scope, integer funcname
{
	if((scope.Name != 0) && (scope.Name != GlobalCodeBlockName))
	{
		integer parentname = scope.ParentName
		if((parentname == 0) && (scope.Name != GlobalCodeBlockName))
		{
			parentname = GlobalCodeBlockName
		}
		
		integer varcount = CountScopeVariables(scope)
		OnBytecodeLexicalScope(scope.Name, parentname, varcount)
		CodeGenEmitVariables(scope.Variables, funcname)
	}
}


CodeGenEmitSpecificScope : list<Scope> ref scopes, integer scopename
{
	if(scopes.value.Name == scopename)
	{
		integer varcount = CountScopeVariables(scopes.value)
		OnBytecodeLexicalScope(scopes.value.Name, 0, varcount)
		CodeGenEmitVariables(scopes.value.Variables, 0)
	}
	else
	{
		CodeGenEmitSpecificScope(scopes.next, scopename)
	}
}


CountScopeVariables : Scope ref scope -> integer count = 0
{
	CountScopeVariables(scope.Variables, count)
}

CountScopeVariables : list<Variable> ref variables, integer ref count
{
	if(variables.value.Name != 0)
	{
		++count
	}

	CountScopeVariables(variables.next, count)
}

CountScopeVariables : nothing, integer ref count


CodeGenEmitVariables : list<Variable> ref vars, integer funcname
{
	CodeGenEmitSingleVariable(vars.value, funcname)
	CodeGenEmitVariables(vars.next, funcname)
}

CodeGenEmitVariables : nothing, integer funcname


CodeGenEmitSingleVariable : Variable ref var, integer funcname
{
	if(var.Name != 0)
	{
		integer basetype = var.VarType
		while((basetype & 0x7f000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(TypeAliases, basetype)
		}


		if((var.Origin == 2) && (listcontains(CustomConstructors, funcname)))
		{
			OnBytecodeLexicalScopeEntry(var.Name, basetype, 0)
		}
		else
		{
			OnBytecodeLexicalScopeEntry(var.Name, basetype, var.Origin)
		}
	}
}


CodeGenEmitFunctions : list<FunctionDefinition> ref table
{
	CodeGenEmitSingleFunction(table.value)
	CodeGenEmitFunctions(table.next)
}

CodeGenEmitFunctions : nothing


CodeGenEmitSingleFunction : FunctionDefinition ref def
{
	if(def.Name != 0)
	{
		EmittingFunctionName = def.Name
		OnBytecodeEnterFunction(def.Name)
		CodeGenEmitFunctionReturn(def.Return)

		if(def.InvokeTag != 0)
		{
			OnBytecodeInvoke(def.InvokeTag)
		}

		CodeGenEmitCodeBlock(def.Code)
		if(listcontains(CustomConstructors, def.Name))
		{
			OnBytecodePushVarNoCopy(FindReturnVariableName())
			OnBytecodeBindReference(0, 0)			// TODO - kind of a hack
			OnBytecodeAssign()
		}
		else
		{
			if(def.AnonymousReturn)
			{
				CodeGenEmitReturnRegisterAnonymous(def.Return)
			}
			else
			{
				CodeGenEmitReturnRegister(def.Return)
			}
		}
		OnBytecodeExitFunction()
	}
}

CodeGenEmitFunctionReturn : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitFunctionReturn : nothing


CodeGenEmitReturnRegister : Expression ref expr
{
	integer index = FindReturnVariableIndex()
	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegister : nothing


CodeGenEmitReturnRegisterAnonymous : Expression ref expr
{
	integer index = FindReturnVariableIndex()

	OnBytecodeBindReference(0, index)
	OnBytecodeAssign()

	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegisterAnonymous : nothing



CodeGenEmitCodeBlock : CodeBlock ref block
{
	CodeGenEmitCodeBlockEntries(block.Entries)
}

CodeGenEmitCodeBlock : nothing


CodeGenEmitCodeBlockEntries : list<CodeBlockEntry> ref entries
{
	CodeGenEmitSingleCodeBlockEntry(entries.value)
	CodeGenEmitCodeBlockEntries(entries.next)
}

CodeGenEmitCodeBlockEntries : nothing


CodeGenEmitSingleCodeBlockEntry : Statement ref s
{
	boolean sumtype = SumTypeExists(s.Name)
	boolean constructssumtype = false
	if((s.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtype = true
	}

	boolean constructorcall = StructureConstructorExists(Structures, s.Name)

	CodeGenEmitExpressionList(s.Parameters, constructssumtype, constructorcall)

	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(EmittingFunctionName, s.Name, var)
	if((var.Name != 0) && ((var.VarType & 0xff000000) == 0x09000000))
	{
		OnBytecodeInvokeIndirect(s.Name)
	}
	elseif(sumtype)
	{
		OnBytecodeConstructSumType()
	}
	elseif(FunctionIsAutoGenOrHasIR(s.Name))
	{
		OnBytecodeInvokeOffset(s.Name)
	}
	else
	{
		OnBytecodeInvoke(s.Name)
	}
}

CodeGenEmitSingleCodeBlockEntry : Assignment ref a
{
	CodeGenEmitExpressionAtoms(a.RHS.Atoms, false, false)

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}

CodeGenEmitSingleCodeBlockEntry : AssignmentCompound ref a
{
	CodeGenEmitExpressionAtoms(a.RHS.Atoms, false, false)

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHS.value, frames)
	OnBytecodeBindReference(frames, index)

	integer typeid = MakeNonReferenceType(FindVariableType(a.LHS.value))

	integer structurename = GetNameOfStructureByType(typeid)
	BindAssignmentMembers(a.LHS.next, structurename)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()	
	}
	else
	{
		OnBytecodeAssign()
	}
}


CodeGenEmitBindingsForOperand : simplelist<integer> ref operand
{
	integer frames = 0
	integer index = FindVariable(operand.value, frames)
	OnBytecodeBindReference(frames, index)

	integer structurename = GetNameOfStructureByType(FindVariableType(operand.value))
	BindAssignmentMembers(operand.next, structurename)
}


CodeGenEmitSingleCodeBlockEntry : PreOpStatement ref preop
{
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(preop.Operator)
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeAssign()
	// TODO - push extra copy of value LAST if in a parenthetical
}

CodeGenEmitSingleCodeBlockEntry : PostOpStatement ref postop
{
	// TODO - push extra copy of value FIRST if in a parenthetical
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(postop.Operator)
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeAssign()
}



CodeGenEmitSingleCodeBlockEntry : EntityChain ref chain
{
	OnBytecodeBeginChain()
	CodeGenEmitEntityChain(chain.Entries)
	OnBytecodeEndChain()
}


CodeGenEmitEntityChain : EntityList ref entities
{
	CodeGenEmitEntityList(entities.ActualList)
}

CodeGenEmitEntityList : list<Entity> ref thelist
{
	if(thelist.value.Tag != 0)
	{
		CodeGenEmitExpression(thelist.value.Param, false, false)
		OnBytecodeEnterEntity(thelist.value.Tag, 0)
		CodeGenEmitCodeBlock(thelist.value.Code)
		OnBytecodeExitEntity()
	}

	CodeGenEmitEntityList(thelist.next)
}

CodeGenEmitEntityList : nothing


BindAssignmentMembers : simplelist<integer> ref lhsmembers, integer structurename
{
	integer membertype = GetStructureMemberType(Structures, structurename, lhsmembers.value)
	integer memberoffset = GetStructureMemberOffset(Structures, structurename, lhsmembers.value)

	OnBytecodeBindStructReference(membertype, memberoffset)

	// Recurse
	BindAssignmentMembers(lhsmembers.next, GetNameOfType(membertype))
}

BindAssignmentMembers : nothing, integer structurename


ComputeCompoundAssignmentLHSType : AssignmentCompound ref assignment, integer scopename -> integer typeid = 0
{
	integer rootname = assignment.LHS.value
	
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(scopename, rootname, var)
	
	integer vartypename = GetNameOfType(var.VarType)
	typeid = ComputeCompoundAssignmentLHSTypeMembers(assignment.LHS.next, vartypename)
}

ComputeCompoundAssignmentLHSTypeMembers : simplelist<integer> ref lhsmembers, integer structurename -> integer typeid = 0
{
	integer membertype = GetStructureMemberType(Structures, structurename, lhsmembers.value)
	typeid = ComputeCompoundAssignmentLHSTypeMembers(lhsmembers.next, GetNameOfType(membertype))
}

ComputeCompoundAssignmentLHSTypeMembers : nothing, integer structurename -> integer typeid = GetTypeByName(structurename)




CodeGenEmitExpressionList : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpressionList : ExpressionList ref expressions, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionList(expressions.Expressions, constructssumtype, constructorcall)
}

CodeGenEmitExpressionList : list<Expression> ref expressions, boolean constructssumtype, boolean constructorcall
{
	boolean constructssumtypetemp = constructssumtype
	if((expressions.value.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtypetemp = true
	}

	CodeGenEmitExpressionAtoms(expressions.value.Atoms, constructssumtypetemp, constructorcall)
	CodeGenEmitExpressionList(expressions.next, constructssumtype, constructorcall)
}

CodeGenEmitExpression : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpression : Expression ref expr, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionAtoms(expr.Atoms, constructssumtype, constructorcall)
}

CodeGenEmitExpressionAtoms : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean constructorcall
{
	boolean needsref = false
	CodeGenEmitExpressionAtomsWorker(atoms, constructssumtype, needsref, constructorcall)
	if(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

CodeGenEmitExpressionAtomsWorker : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean ref needsref, boolean constructorcall
{
	boolean thisneedsref = CodeGenCheckAtomForReadRef(atoms.value)
	if(thisneedsref)
	{
		needsref = true
	}
	elseif(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
		needsref = false
	}

	CodeGenEmitSingleAtom(atoms.value, constructorcall)
	CodeGenEmitExpressionAtomsWorker(atoms.next, constructssumtype, needsref, constructorcall)
}

CodeGenEmitExpressionAtomsWorker : nothing, boolean constructssumtype, boolean ref needsref, boolean constructorcall


CodeGenCheckAtomForReadRef : RefBinding ref atom -> !atom.IsReference
CodeGenCheckAtomForReadRef : CompoundAtom ref atom -> false

CodeGenCheckAtomForReadRef : integer ref atom -> false
CodeGenCheckAtomForReadRef : integer16 ref atom -> false
CodeGenCheckAtomForReadRef : boolean ref atom -> false
CodeGenCheckAtomForReadRef : real ref atom -> false
CodeGenCheckAtomForReadRef : IdentifierAtom ref atom -> false
CodeGenCheckAtomForReadRef : StringHandleAtom ref atom -> false
CodeGenCheckAtomForReadRef : OperatorInvokeAtom ref atom -> false
CodeGenCheckAtomForReadRef : TypeAnnotationAtom ref atom -> false
CodeGenCheckAtomForReadRef : Statement ref atom -> false
CodeGenCheckAtomForReadRef : ParentheticalExpression ref atom -> false
CodeGenCheckAtomForReadRef : AtomSentinel ref atom -> false




CodeGenEmitSingleAtom : integer ref literalinteger, boolean constructor
{
	OnBytecodePushLiteralInteger(literalinteger)
}

CodeGenEmitSingleAtom : integer16 ref literalinteger16, boolean constructor
{
	OnBytecodePushLiteralInteger16(literalinteger16)
}

CodeGenEmitSingleAtom : boolean ref literalboolean, boolean constructor
{
	OnBytecodePushBoolean(literalboolean)
}

CodeGenEmitSingleAtom : real ref literalreal, boolean constructor
{
	OnBytecodePushLiteralReal(literalreal)
}

CodeGenEmitSingleAtom : StringHandleAtom ref atom, boolean constructor
{
	OnBytecodePushLiteralString(atom.Handle)
}

CodeGenEmitSingleAtom : OperatorInvokeAtom ref atom, boolean constructor
{
	OnBytecodeInvoke(atom.OperatorName)
}

CodeGenEmitSingleAtom : IdentifierAtom ref idatom, boolean constructor
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		OnBytecodePushLiteralInteger(0)
	}
	else
	{
		if(FunctionIsAutoGenOrHasIR(idatom.Handle))
		{
			OnBytecodePushLiteralFunction(idatom.Handle)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			OnBytecodePushLiteralString(idatom.Handle)
		}	
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if((!constructor) && (!idatom.IsReference))
				{
					OnBytecodePushLiteralString(idatom.Handle)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				OnBytecodePushLiteralFunction(idatom.Handle)
			}
			else
			{
				if(idatom.IsReference)
				{	
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)

					if(frames == 0)
					{
						OnBytecodePushVarValue(idatom.Handle, atomtype)
					}
					else
					{
						Variable var = 0, 0, 0, 0
						FindVariableDataInScope(EmittingFunctionName, idatom.Handle, var)
						
						OnBytecodePushLocal(false, frames, var.Offset, 0)
					}
				}
			}
		}
	}
}

CodeGenEmitSingleAtom : TypeAnnotationAtom ref atom, boolean constructor
{
	OnBytecodePushTypeAnnotation(MakeNonReferenceType(atom.Type))
}

CodeGenEmitSingleAtom : Statement ref atom, boolean constructor
{
	CodeGenEmitSingleCodeBlockEntry(atom)
}

CodeGenEmitSingleAtom : RefBinding ref atom, boolean constructor
{
	integer memtype = GetStructureMemberType(Structures, atom.StructureName, atom.Identifier)
	integer memoffset = GetStructureMemberOffset(Structures, atom.StructureName, atom.Identifier)
	OnBytecodeBindStructReference(memtype, memoffset)
}

CodeGenEmitSingleAtom : ParentheticalExpression ref expr, boolean constructor
{
	CodeGenEmitExpression(expr.Inner, false, false)
}

CodeGenEmitSingleAtom : CompoundAtom ref atom, boolean constructor
{
	integer frames = 0
	integer index = FindVariable(atom.Bindings.value.Identifier, frames)
	OnBytecodeBindReference(frames, index)
	
	EmitCompoundBindings(atom.Bindings, atom.Bindings.next)
	
	if(!IsReferenceType(atom.Type))
	{
		if((atom.Type & 0x7f000000) == 0x07000000)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

EmitCompoundBindings : list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(EmittingFunctionName, bindings.value.Identifier, var)
	
	integer lhstypename = GetNameOfType(var.VarType)

	integer memtype = GetStructureMemberType(Structures, lhstypename, tail.value.Identifier)
	integer memoffset = GetStructureMemberOffset(Structures, lhstypename, tail.value.Identifier)
	OnBytecodeBindStructReference(memtype, memoffset)

	EmitCompoundSubsequentBindings(tail.next)
}

EmitCompoundSubsequentBindings : nothing

EmitCompoundSubsequentBindings : list<RefBinding> ref bindings
{
	CodeGenEmitSingleAtom(bindings.value, false)
	EmitCompoundSubsequentBindings(bindings.next)
}


CodeGenEmitSingleAtom : AtomSentinel ref sentinel, boolean constructor


GetNameOfStructureByType : integer typeid -> integer name = 0
{
	name = GetNameOfStructureByType(Structures, typeid)
}

GetNameOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.Name
	}
	else
	{
		name = GetNameOfStructureByType(structures.next, typeid)
	}
}

GetNameOfStructureByType : nothing, integer typeid -> integer name = 0



GetSizeOfStructureByType : integer typeid -> integer size = 0
{
	size = GetSizeOfStructureByType(Structures, typeid)
}

GetSizeOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer size = 0
{
	if(structures.value.Type == typeid)
	{
		size = GetTotalMemberSize(structures.value.Members)
	}
	else
	{
		size = GetSizeOfStructureByType(structures.next, typeid)
	}
}

GetSizeOfStructureByType : nothing, integer typeid -> integer name = 0


GetTotalMemberSize : list<StructureMember> ref members -> integer size = 0
{
	size = GetMemberSize(members.value) + GetTotalMemberSize(members.next)
}

GetTotalMemberSize : nothing -> integer size = 0



GetStructureMemberType : list<StructureDefinition> ref structures, integer structurename, integer membername -> integer rtype = 0
{
	if(structures.value.Name == structurename)
	{
		rtype = GetMemberType(structures.value.Members, membername)
	}
	else
	{
		rtype = GetStructureMemberType(structures.next, structurename, membername)
	}
}

GetStructureMemberType : nothing, integer structurename, integer membername -> integer rtype = 0

GetMemberType : list<StructureMember> ref members, integer membername -> integer rtype = 0
{
	if(GetMemberName(members.value) == membername)
	{
		rtype = GetMemberTypeDecompose(members.value)
	}
	else
	{
		rtype = GetMemberType(members.next, membername)
	}
}

GetMemberType : nothing, integer membername -> integer rtype = 0

GetMemberTypeDecompose : StructureMemberVariable ref memvar -> integer rtype = memvar.Type

GetMemberTypeDecompose : StructureMemberFunctionRef ref member -> integer rtype = 0x09000000



GetMemberName : StructureMemberVariable ref memvar -> integer name = memvar.Name

GetMemberName : StructureMemberFunctionRef ref member -> integer name = member.Name


GetMemberOffset : list<StructureMember> ref members, integer membername -> integer offset = 0
{
	integer counter = 0
	GetMemberOffset(members, membername, counter)
	offset = counter
}

GetMemberOffset : list<StructureMember> ref members, integer membername, integer ref counter
{
	if(GetMemberName(members.value) != membername)
	{
		if(GetMemberName(members.value) != 0)
		{
			counter += GetMemberSize(members.value)
		}
		GetMemberOffset(members.next, membername, counter)
	}
}

GetMemberOffset : nothing, integer membername, integer ref counter

GetMemberSize : StructureMemberVariable ref memvar -> integer r = GetTypeSize(memvar.Type)

GetMemberSize : StructureMemberFunctionRef ref member -> 4



GetStructureMemberOffset : list<StructureDefinition> ref structures, integer structurename, integer membername -> integer offset = 0
{
	if(structures.value.Name == structurename)
	{
		offset = GetMemberOffset(structures.value.Members, membername)
	}
	else
	{
		offset = GetStructureMemberOffset(structures.next, structurename, membername)
	}
}

GetStructureMemberOffset : nothing, integer structurename, integer membername -> 0



CodeGenEmitSumTypes : list<SumType> ref sumtypes
{
	CodeGenEmitSingleSumType(sumtypes.value)
	CodeGenEmitSumTypes(sumtypes.next)
}

CodeGenEmitSumTypes : nothing


CodeGenEmitSingleSumType : SumType ref sumtype
{
	if(sumtype.Type != 0)
	{
		OnBytecodeEmitByte(0x1f)			// SumTypeDef instruction
		OnBytecodeEmitInteger(sumtype.Type)
		OnBytecodeEmitInteger(CountSumTypeBases(sumtype.Bases))
		CodeGenEmitSumTypeBase(sumtype.Bases)
	}
}

CountSumTypeBases : simplelist<integer> ref bases -> integer count = 0
{
	count = CountSumTypeBases(bases.next)

	if(bases.value != 0)	
	{
		++count
	}
}

CountSumTypeBases : nothing -> integer count = 0

CodeGenEmitSumTypeBase : simplelist<integer> ref bases
{
	CodeGenEmitSumTypeBase(bases.next)

	if(bases.value != 0)
	{
		OnBytecodeEmitInteger(bases.value)
	}
}

CodeGenEmitSumTypeBase : nothing


SumTypeExists : integer typename -> boolean exists = SumTypeExists(SumTypes, typename)

SumTypeExists : list<SumType> ref sumtypes, integer typename -> boolean exists = false
{
	if(sumtypes.value.Name == typename)
	{
		exists = true
	}
	else
	{
		exists = SumTypeExists(sumtypes.next, typename)
	}
}

SumTypeExists : nothing, integer typename -> boolean exists = false


FindSumTypeName : integer typeid -> integer name = FindSumTypeName(SumTypes, typeid)

FindSumTypeName : list<SumType> ref sumtypes, integer typeid -> integer name = 0
{
	if(sumtypes.value.Type == typeid)
	{
		name = sumtypes.value.Name
	}
	else
	{
		name = FindSumTypeName(sumtypes.next, typeid)
	}
}

FindSumTypeName : nothing, integer typeid -> 0


SumTypeHasBase : list<SumType> ref sumtypes, integer sumtypeid, integer basetypeid -> boolean hasbase = false
{
	if(sumtypes.value.Type == sumtypeid)
	{
		hasbase = listcontains(sumtypes.value.Bases, basetypeid)
	}
	else
	{
		hasbase = SumTypeHasBase(sumtypes.next, sumtypeid, basetypeid)
	}
}

SumTypeHasBase : nothing, integer sumtypeid, integer basetypeid -> false



FunctionIsAutoGenOrHasIR : integer funcname -> boolean ret = false
{
	if(FunctionExists(Functions, funcname))
	{
		ret = true
	}
	elseif(TypeMatcherExists(TypeMatchers, funcname))
	{
		ret = true
	}
	elseif(FunctionIsAutoGen(AutoGeneratedFunctionNames, funcname))
	{
		ret = true
	}
}

FunctionExists : list<FunctionDefinition> ref funcs, integer funcname -> boolean ret = false
{
	if(funcs.value.Name == funcname)
	{
		ret = true
	}
	else
	{
		ret = FunctionExists(funcs.next, funcname)
	}
}

FunctionExists : nothing, integer funcname -> boolean ret = false


FunctionIsAutoGen : simplelist<integer> ref genlist, integer target -> boolean ret = false
{
	if(genlist.value == target)
	{
		ret = true
	}
	else
	{
		ret = FunctionIsAutoGen(genlist.next, target)
	}
}

FunctionIsAutoGen : nothing, integer target -> boolean ret = false



TypeMatcherExists : list<TypeMatcher> ref matchers, integer matchername -> boolean ret = false
{
	if(matchers.value.Name == matchername)
	{
		ret = true
	}
	else
	{
		ret = TypeMatcherExists(matchers.next, matchername)
	}
}

TypeMatcherExists : nothing, integer matchername -> boolean ret = false



FindVariable : integer name, integer ref frames -> integer index = FindVariableInScope(EmittingFunctionName, name)
{
	if(index < 0)
	{
		index = FindVariableInScope(GlobalCodeBlockName, name)
		frames = -1
	}
}



FindVariableInScope : integer scopename, integer varname -> integer index = FindVariableInScopeList(Scopes, scopename, varname)

FindVariableInScopeList : list<Scope> ref scopes, integer scopename, integer varname -> integer index = -1
{
	if(scopes.value.Name == scopename)
	{
		index = 0
		FindVariableInSingleScope(scopes.value.Variables, varname, index)
	}
	else
	{
		index = FindVariableInScopeList(scopes.next, scopename, varname)
	}
}

FindVariableInScopeList : nothing, integer scopename, integer varname -> integer index = -1


FindVariableInSingleScope : list<Variable> ref vars, integer varname, integer ref index
{
	if(vars.value.Name != varname)
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindVariableInSingleScope(vars.next, varname, index)
	}
}

FindVariableInSingleScope : nothing, integer varname, integer ref index
{
	index = -1
}


FindReturnVariableIndex : -> integer index = FindReturnVariableInScopeList(Scopes, EmittingFunctionName)

FindReturnVariableName: -> integer index = FindReturnVariableNameInScopeList(Scopes, EmittingFunctionName)


FindReturnVariableInScopeList : list<Scope> ref scopes, integer scopename -> integer index = -1
{
	if(scopes.value.Name == scopename)
	{
		index = 0
		FindReturnVariableInSingleScope(scopes.value.Variables, index)
	}
	else
	{
		index = FindReturnVariableInScopeList(scopes.next, scopename)
	}
}

FindReturnVariableInSingleScope : list<Variable> ref vars, integer ref index
{
	if(vars.value.Origin != 2)		// VARIABLE_ORIGIN_RETURN
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindReturnVariableInSingleScope(vars.next, index)
	}
}

FindReturnVariableInSingleScope : nothing, integer ref index
{
	index = -1
}


FindReturnVariableNameInScopeList : list<Scope> ref scopes, integer scopename -> integer name = 0
{
	if(scopes.value.Name == scopename)
	{
		FindReturnVariableNameInSingleScope(scopes.value.Variables, name)
	}
	else
	{
		name = FindReturnVariableNameInScopeList(scopes.next, scopename)
	}
}

FindReturnVariableNameInSingleScope : list<Variable> ref vars, integer ref name
{
	if(vars.value.Origin == 2)		// VARIABLE_ORIGIN_RETURN
	{
		name = vars.value.Name
	}
	else
	{
		FindReturnVariableNameInSingleScope(vars.next, name)
	}
}

FindReturnVariableNameInSingleScope : nothing, integer ref name
{
	name = 0
}



FindVariableType : integer varname -> integer rettype = 0
{
	Variable var = 0, 0, 0, 0
	if(!FindVariableDataInScope(EmittingFunctionName, varname, var))
	{
		FindVariableDataInScope(GlobalCodeBlockName, varname, var)
	}
	rettype = var.VarType
}


FindVariableDataInScope : integer scopename, integer varname, Variable ref outvar 
	->
	boolean found = FindVariableDataInScopeList(Scopes, scopename, varname, outvar)

FindVariableDataInScopeList : list<Scope> ref scopes, integer scopename, integer varname, Variable ref outvar -> boolean found = false
{
	if(scopes.value.Name == scopename)
	{
		found = FindVariableDataInSingleScope(scopes.value.Variables, varname, outvar)
		if((!found) && (GlobalCodeBlockName != 0) && (scopename != GlobalCodeBlockName))
		{
			found = FindVariableDataInScopeList(Scopes, GlobalCodeBlockName, varname, outvar)
		}
	}
	else
	{
		found = FindVariableDataInScopeList(scopes.next, scopename, varname, outvar)
	}
}

FindVariableDataInScopeList : nothing, integer scopename, integer varname, Variable ref outvar -> boolean found = false

FindVariableDataInSingleScope : list<Variable> ref vars, integer varname, Variable ref outvar -> boolean found = false
{
	if(vars.value.Name == varname)
	{
		outvar = vars.value
		found = true
	}
	else
	{
		found = FindVariableDataInSingleScope(vars.next, varname, outvar)
	}
}

FindVariableDataInSingleScope : nothing, integer varname, Variable ref outvar -> boolean found = false



CodeGenEmitTypeMatchers : list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{
		CodeGenEmitSingleTypeMatcher(matchers.value)
	}

	CodeGenEmitTypeMatchers(matchers.next)
}

CodeGenEmitTypeMatchers : nothing


CodeGenEmitSingleTypeMatcher : TypeMatcher ref matcher
{
	OnBytecodeLexicalScope(matcher.Name, 0, 0)
	OnBytecodeEnterTypeResolver(matcher.Name)
	CodeGenEmitTypeMatcherOverloads(matcher.Overloads)
	OnBytecodeExitTypeResolver()
}


OnCodeGenRegisterTypeMatchParam : integer matchername, integer overloadname, integer varname, integer vartype
{
	Parameter p = varname, vartype
	FindTypeMatcherAndAppendOverloadParameter(TypeMatchers, matchername, overloadname, p)
}

FindTypeMatcherAndAppendOverloadParameter : list<TypeMatcher> ref matchers, integer matchername, integer overloadname, Parameter ref p
{
	if(matchers.value.Name == matchername)
	{
		FindTMOverloadAndAppendParameter(matchers.value.Overloads, matchers.value.Overloads, overloadname, p)
	}
	else
	{
		FindTypeMatcherAndAppendOverloadParameter(matchers.next, matchername, overloadname, p)
	}
}

FindTypeMatcherAndAppendOverloadParameter : nothing, integer matchername, integer overloadname, Parameter ref p
{
	print("No type matcher available")
	assert(false)
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, list<FunctionSignature> ref signatures, integer overloadname, Parameter ref p
{
	if(signatures.value.Name == overloadname)
	{
		AppendParameter(signatures.value.Parameters, p)
	}
	else
	{
		FindTMOverloadAndAppendParameter(originallist, signatures.next, overloadname, p)
	}
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, nothing, integer overloadname, Parameter ref p
{
	list<Parameter> paramlist = p, nothing
	FunctionSignature sig = overloadname, paramlist, 0
	prepend<FunctionSignature>(originallist, sig)
}

AppendParameter : list<Parameter> ref params, Parameter ref p
{
	AppendParameterRecurse(params, params.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, list<Parameter> ref tail, Parameter ref p
{
	AppendParameterRecurse(tail, tail.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, nothing, Parameter ref p
{
	list<Parameter> newlist = p, nothing
	params.next = newlist
}


CodeGenEmitTypeMatcherOverloads : list<FunctionSignature> ref signatures
{
	CodeGenEmitTypeMatcherOverloads(signatures.next)

	if(signatures.value.Name != 0)
	{
		OnBytecodeEmitByte(0x20)				// TypeMatch instruction
		OnBytecodeEmitInteger(signatures.value.Name)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(CountParameters(signatures.value.Parameters))
		
		CodeGenEmitTypeMatcherParams(signatures.value.Parameters)
	}
}

CodeGenEmitTypeMatcherOverloads : nothing


CountParameters : list<Parameter> ref params -> integer count = 0
{
	count = CountParameters(params.next)

	if(params.value.Name != 0)
	{
		++count
	}
}

CountParameters : nothing -> integer count = 0


CodeGenEmitTypeMatcherParams : list<Parameter> ref params
{
	CodeGenEmitTypeMatcherParams(params.next)

	if(params.value.Name != 0)
	{
		integer refflag = 0
		if(IsReferenceType(params.value.Type))
		{
			refflag = 1
		}

		OnBytecodeEmitByte(refflag)
		OnBytecodeEmitInteger(MakeNonReferenceType(params.value.Type))
	}
}

CodeGenEmitTypeMatcherParams : nothing



OnCodeGenRegisterFunctionInvokeTag : integer funcname, integer invoketarget
{
	FindFunctionAndSetInvokeTag(Functions, funcname, invoketarget)
}

FindFunctionAndSetInvokeTag : list<FunctionDefinition> ref functions, integer funcname, integer invoketarget
{
	if(functions.value.Name == funcname)
	{
		functions.value.InvokeTag = invoketarget
	}
	else
	{
		FindFunctionAndSetInvokeTag(functions.next, funcname, invoketarget)
	}
}

FindFunctionAndSetInvokeTag : nothing, integer funcname, integer invoketarget
{
	print("Cannot tag non-existent function")
	assert(false)
}

OnCodeGenRegisterFunctionTag : integer funcname, string tagname, integer rawfuncname
{
	list<string> dtp = "", nothing
	FunctionTag tag = funcname, tagname, dtp
	prepend<FunctionTag>(FunctionTags, tag)

	if(tagname == "constructor")
	{
		simpleprepend<integer>(CustomConstructors, funcname)
		
		integer baseconstructorname = PoolString(GetPooledString(GlobalStrings, rawfuncname) ; "@@constructor")
		
		Overload overload = baseconstructorname, funcname
		prepend<Overload>(Overloads, overload)
		
		PrependFunctionParameter(Functions, funcname, PoolString("@id"), 0x81000000)		// reference to identifier type signature
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParam(FunctionTags.value.Parameters, FunctionTags.value.Parameters.next, param)
}

AppendFunctionTagParam : list<string> ref params, list<string> ref tail, string param
{
	AppendFunctionTagParam(tail, tail.next, param)
}

AppendFunctionTagParam : list<string> ref params, nothing, string param
{
	list<string> newlist = param, nothing
	params.next = newlist
}


CodeGenEmitFunctionTags : list<FunctionTag> ref tags
{
	CodeGenEmitSingleFunctionTag(tags.value)
	CodeGenEmitFunctionTags(tags.next)
}

CodeGenEmitFunctionTags : nothing


CodeGenEmitSingleFunctionTag : FunctionTag ref tag
{
	if(tag.FunctionName != 0)
	{
		if(tag.TagName != "")
		{
			OnBytecodeEmitByte(0x1a)
			OnBytecodeEmitInteger(tag.FunctionName)
			OnBytecodeEmitInteger(CountTagParams(tag.Parameters))
			OnBytecodeEmitString(tag.TagName)

			CodeGenEmitFunctionTagParams(tag.Parameters)
		}
	}
}


CodeGenEmitFunctionTagParams : list<string> ref params
{
	if(params.value != "")
	{
		OnBytecodeEmitString(params.value)
	}

	CodeGenEmitFunctionTagParams(params.next)
}

CodeGenEmitFunctionTagParams : nothing


CountTagParams : list<string> ref params -> integer count = 0
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0


CodeGenEmitConstructors : list<StructureDefinition> ref structures
{
	if(structures.value.Name != 0)
	{
		EmitCtorTag(structures.value.ConstructorName)
		EmitCtorTag(structures.value.AnonConstructorName)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCtorTag(structures.value.CopyConstructorName)
		}

		EmitConstructor(structures.value)
		EmitAnonConstructor(structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCopyConstructor(structures.value)
		}
	}

	CodeGenEmitConstructors(structures.next)
}

CodeGenEmitConstructors : nothing

EmitCtorTag : integer funcname
{
	OnBytecodeEmitByte(0x1a)
	OnBytecodeEmitInteger(funcname)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitString("@@autogen@constructor")
}


EmitConstructor : StructureDefinition ref def
{
	integer idhandle = FindString(GlobalStrings, "identifier")

	OnBytecodeLexicalScope(def.ConstructorName, 0, CountMembers(def.Members) + 1)
	OnBytecodeLexicalScopeEntry(idhandle, 0x81000000, 1)
	EmitScopeEntriesForMembers(def.Members)

	OnBytecodeEnterFunction(def.ConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, idhandle)

	OnBytecodeExitFunction()
}

EmitAnonConstructor : StructureDefinition ref def
{
	integer membercount = CountMembers(def.Members)
	OnBytecodeLexicalScope(def.AnonConstructorName, 0, membercount + 1)
	EmitScopeEntriesForMembers(def.Members)
	OnBytecodeLexicalScopeEntry(def.AnonConstructorName, def.Type, 2)

	OnBytecodeEnterFunction(def.AnonConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, membercount)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, def.AnonConstructorName)

	OnBytecodeSetReturnRegister(membercount)
	OnBytecodeExitFunction()
}

EmitCopyConstructor : StructureDefinition ref def
{
	OnBytecodeLexicalScope(def.CopyConstructorName, 0, 2)
	OnBytecodeLexicalScopeEntry(FindString(GlobalStrings, "identifier"), 0x81000000, 1)
	OnBytecodeLexicalScopeEntry(def.Name, def.Type, 1)

	OnBytecodeEnterFunction(def.CopyConstructorName)
	OnBytecodePushVarNoCopy(def.Name)
	OnBytecodeCopyStructure()
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()
	OnBytecodeExitFunction()
}


EmitScopeEntriesForMembers : list<StructureMember> ref members
{
	EmitScopeEntryForMember(members.value)
	EmitScopeEntriesForMembers(members.next)
}

EmitScopeEntriesForMembers : nothing


EmitScopeEntryForMember : StructureMemberVariable ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, memvar.Type, 1)
	}
}

EmitScopeEntryForMember : StructureMemberFunctionRef ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, 0x09000000, 1)
	}
}



EmitMemberDataCopies : list<StructureMember> ref members, integer idhandle
{
	EmitMemberDataCopy(members.value, idhandle)
	EmitMemberDataCopies(members.next, idhandle)
}

EmitMemberDataCopies : nothing, integer idhandle

EmitMemberDataCopy : StructureMemberVariable ref memvar, integer idhandle
{
	if(memvar.Name != 0)
	{
		OnBytecodePushVarValue(memvar.Name, memvar.Type)
		OnBytecodeCopyToStructure(idhandle, memvar.Name)
	}
}

EmitMemberDataCopy : StructureMemberFunctionRef ref member, integer idhandle
{
	if(member.Name != 0)
	{
		OnBytecodePushVarValue(member.Name, 0x09000000)
		OnBytecodeCopyToStructure(idhandle, member.Name)
	}
}


FindString : list<StringTableEntry> ref strings, string target -> integer handle = 0
{
	if(strings.value.Data == target)
	{
		handle = strings.value.Handle
	}
	else
	{
		handle = FindString(strings.next, target)
	}
}

FindString : nothing, string target -> integer handle = 0



GetNameOfType : integer typeid -> integer name = 0
{
	typeid = MakeNonReferenceType(typeid)
	if(typeid == 0x01000001)
	{
		name = FindString(GlobalStrings, "integer")
	}
	elseif(typeid == 0x01000002)
	{
		name = FindString(GlobalStrings, "integer16")
	}
	elseif(typeid == 0x01000003)
	{
		name = FindString(GlobalStrings, "boolean")
	}
	elseif(typeid == 0x01000004)
	{
		name = FindString(GlobalStrings, "real")
	}
	elseif(typeid == 0x02000000)
	{
		name = FindString(GlobalStrings, "string")
	}
	elseif(typeid == 0x02000001)
	{
		name = FindString(GlobalStrings, "buffer")
	}
	elseif(typeid == 0x00000004)
	{
		name = FindString(GlobalStrings, "nothing")
	}
	elseif(typeid == 0x01000000)
	{
		name = FindString(GlobalStrings, "identifier")
	}
	elseif(IsStructureType(typeid))
	{
		name = GetNameOfStructureByType(typeid)
	}
	elseif((typeid & 0xff000000) == 0x07000000)
	{
		name = FindSumTypeName(typeid)
	}
	elseif((typeid & 0x7f000000) == 0x09000000)
	{
		name = PoolString("{function}")
	}
	else
	{
		print("Unknown type " ; cast(string, typeid))
		assert(false)
	}
}

GetTypeByName : integer name -> integer typeid = 0
{
	integer unaliasedname = UnaliasType(TypeWeakAliases, name)
	while(unaliasedname != name)
	{
		name = unaliasedname
		unaliasedname = UnaliasType(TypeWeakAliases, name)
	}
	name = unaliasedname

	if(name == FindString(GlobalStrings, "identifier"))
	{
		typeid = 0x01000000
	}
	elseif(name == FindString(GlobalStrings, "integer"))
	{
		typeid = 0x01000001
	}
	elseif(name == FindString(GlobalStrings, "integer16"))
	{
		typeid = 0x01000002
	}
	elseif(name == FindString(GlobalStrings, "boolean"))
	{
		typeid = 0x01000003
	}
	elseif(name == FindString(GlobalStrings, "real"))
	{
		typeid = 0x01000004
	}
	elseif(name == FindString(GlobalStrings, "string"))
	{
		typeid = 0x02000000
	}
	elseif(name == FindString(GlobalStrings, "nothing"))
	{
		typeid = 0x00000004
	}
	elseif(name == FindString(GlobalStrings, "buffer"))
	{
		typeid = 0x02000001
	}
	else
	{
		integer structuretype = GetStructureTypeByName(Structures, name)
		if(structuretype != 0)
		{
			typeid = structuretype
			return()
		}
		
		integer strongaliastype = FindTypeAliasByName(TypeAliases, name)
		if(strongaliastype != 0)
		{
			typeid = strongaliastype
			return()
		}
		
		integer sumtype = FindSumTypeByName(SumTypes, name)
		if(sumtype != 0)
		{
			typeid = sumtype
			return()
		}
	}
}


FindSumTypeByName : list<SumType> ref sumtypes, integer name -> integer typeid = 0
{
	if((sumtypes.value.Type != 0) && (sumtypes.value.Name == name))
	{
		typeid = sumtypes.value.Type
		return()
	}
	
	typeid = FindSumTypeByName(sumtypes.next, name)
}

FindSumTypeByName : nothing, integer name -> 0


UnaliasType : list<TypeAlias> ref aliases, integer namehandle -> integer unaliasedname = 0
{
	if(aliases.value.AliasNameHandle == namehandle)
	{
		unaliasedname = aliases.value.BaseNameHandle
	}
	else
	{
		unaliasedname = UnaliasType(aliases.next, namehandle)
	}
}

UnaliasType : nothing, integer namehandle -> integer unaliasedname = namehandle



GetStructureTypeByName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0
{
	if(structures.value.Name == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureTypeByName(structures.next, name)
	}
}

GetStructureTypeByName : nothing, integer name -> 0



// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	simplelist<integer> processed = 0, nothing
	boolean changed = CodeGenRearrangeStructuresRecurse(thelist, processed)

	if(changed)
	{
		CodeGenRearrangeStructures(thelist)
	}
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref thelist, simplelist<integer> ref processed -> boolean changed = false
{
	if(thelist.value.Name != 0)
	{
		simplelist<integer> dependencies = 0, nothing
		ParseStructDependencies(thelist.value.Members, dependencies)

		if(MissingDependency(dependencies, processed))
		{
			SwapDown(thelist, thelist.next)
			changed = true
		}

		simpleprepend<integer>(processed, thelist.value.Type)
	}

	if(!changed)
	{
		CodeGenRearrangeStructuresRecurse(thelist.next, processed)
	}
}

CodeGenRearrangeStructuresRecurse : nothing, simplelist<integer> ref processed -> false


SwapDown : list<StructureDefinition> ref thelist, list<StructureDefinition> ref tail
{
	StructureDefinition temp = tail.value
	tail.value = thelist.value
	thelist.value = temp
}

SwapDown : list<StructureDefinition> ref thelist, nothing



ParseStructDependencies : list<StructureMember> ref members, simplelist<integer> ref out
{
	integer dependency = GetMemberDependency(members.value)
	if(dependency != 0)
	{
		simpleprepend<integer>(out, dependency)
	}

	ParseStructDependencies(members.next, out)
}

ParseStructDependencies : nothing, simplelist<integer> ref out


GetMemberDependency : StructureMemberVariable ref var -> integer dep = 0
{
	if(var.Name != 0)
	{
		if((var.Type & 0xff000000) == 0x03000000)
		{
			dep = var.Type
		}
	}
}

GetMemberDependency : StructureMemberFunctionRef ref member -> 0


MissingDependency : simplelist<integer> ref dependencies, simplelist<integer> ref processed -> boolean missing = true
{
	// TODO - clean up this horrible code
	if(dependencies.value != 0)
	{
		if(listcontains(processed, dependencies.value))
		{
			missing = false
		}
		else
		{
			missing = MissingDependency(dependencies.next, processed)
		}
	}
	else
	{
		missing = MissingDependency(dependencies.next, processed)
	}
}

MissingDependency : nothing, simplelist<integer> ref processed -> boolean missing = true


OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	Expression d = dummyexpression
	ScratchExpressions.value = d
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = ScratchExpressions.value
	EntityStack.value.Param = expr

	OptionalCodeBlock block = nothing
	prepend<OptionalCodeBlock>(CurrentCodeBlockStack, block)
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


AppendEntityToChain : list<EntityChain> ref chainstack, Entity ref e
{
	AppendEntityToChainUnwrap(chainstack.value.Entries, e)
}

AppendEntityToChainUnwrap : EntityList ref entitylist, Entity ref e
{
	AppendEntityToChainWorker(entitylist.ActualList, entitylist.ActualList.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, list<Entity> ref tail, Entity ref e
{
	AppendEntityToChainWorker(tail, tail.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, nothing, Entity ref e
{
	list<Entity> newtail = e, nothing
	chain.next = newtail
}


FindTypeAliasBase : list<TypeAlias> ref aliases, integer aliastype -> integer basetype = 0
{
	if(aliases.value.TypeID == aliastype)
	{
		basetype = GetTypeByName(aliases.value.BaseNameHandle)
	}
	else
	{
		basetype = FindTypeAliasBase(aliases.next, aliastype)
	}
}

FindTypeAliasBase : nothing, integer aliastype -> integer basetype = 0


FindTypeAliasByName : list<TypeAlias> ref aliases, integer aliasname -> integer aliastype = 0
{
	if(aliases.value.AliasNameHandle == aliasname)
	{
		aliastype = aliases.value.TypeID
	}
	else
	{
		aliastype = FindTypeAliasByName(aliases.next, aliasname)
	}
}

FindTypeAliasByName : nothing, integer aliasname -> 0


OnCodeGenRegisterAlias : integer aliastype, integer aliasname, integer base
{
	TypeAlias newalias = aliastype, aliasname, base
	prepend<TypeAlias>(TypeAliases, newalias)
}

OnCodeGenRegisterWeakAlias : integer aliastype, integer aliasname, integer basename
{
	TypeAlias newalias = aliastype, aliasname, basename
	prepend<TypeAlias>(TypeWeakAliases, newalias)
}


OnCodeGenRegisterFunctionSig : integer sigtype, integer rettypename
{
	list<Parameter> d = dummyparam, nothing
	FunctionSignature sig = sigtype, d, rettypename
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype
{
	Parameter param = 1, paramtype
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigEnd :
{
	// TODO - dead code?
}

CodeGenEmitFunctionSignatures : list<FunctionSignature> ref thelist
{
	CodeGenEmitSingleFunctionSignature(thelist.value)
	CodeGenEmitFunctionSignatures(thelist.next)
}

CodeGenEmitFunctionSignatures : nothing


CodeGenEmitSingleFunctionSignature : FunctionSignature ref signature
{
	if(signature.Name != 0)
	{
		OnBytecodeEmitFunctionSignature(signature.Name, GetTypeByName(signature.ReturnTypeName), CountParameters(signature.Parameters))
		CodeGenEmitFunctionSigParams(signature.Parameters)
	}
}

CodeGenEmitFunctionSigParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		OnBytecodeEmitFunctionSigParam(params.value.Type)
	}
	CodeGenEmitFunctionSigParams(params.next)
}

CodeGenEmitFunctionSigParams : nothing


OnCodeGenRegisterParenthetical : 
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyexpression
	prepend<Expression>(ScratchExpressions, d)
}


OnCodeGenRegisterPreOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist
	CodeBlockEntry cbe = preop
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}


GetLargestSumTypeBaseSize : integer typeid -> integer size = FindSumTypeAndGetBaseMaxSize(SumTypes, typeid)

FindSumTypeAndGetBaseMaxSize : list<SumType> ref sumtypes, integer typeid -> integer size = 0
{
	if(sumtypes.value.Type == typeid)
	{
		GetBaseMaxSize(sumtypes.value.Bases, size)
	}
	else
	{
		size = FindSumTypeAndGetBaseMaxSize(sumtypes.next, typeid)
	}
}

FindSumTypeAndGetBaseMaxSize : nothing, integer typeid -> 0


GetBaseMaxSize : simplelist<integer> ref basetypes, integer ref outsize
{
	if(basetypes.value != 0)
	{
		integer thissize = GetTypeSize(basetypes.value)
		if(thissize > outsize)
		{
			outsize = thissize
		}
	}

	GetBaseMaxSize(basetypes.next, outsize)
}

GetBaseMaxSize : nothing, integer ref outsize



OnCodeGenSetExpressionType : integer typeid
{
	ScratchExpressions.value.Type = typeid
}

OnCodeGenShiftParameter :
{
	if(InFuncRetHack)
	{
		AppendExpressionToSubStatement(ScratchExpressions.value)
	}
	elseif(PeekContext(ContextStack, 1) != STACK_TYPE_SUBSTATEMENT)
	{
		FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
	}
	else
	{
		AppendExpressionToSubStatement(ScratchExpressions.value)
	}

	Expression d = dummyexpression
	ScratchExpressions.value = d
}

PeekContext : list<ContextStackEntry> ref stack, integer depth -> integer peek = STACK_TYPE_GLOBAL
{
	if(depth == 0)
	{
		peek = stack.value.EntryType
	}
	else
	{
		peek = PeekContext(stack.next, depth - 1)
	}
}


CodeGenEmitGlobalBlockPrologue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeEnterEntity(4, GlobalCodeBlockName)
		CodeGenEmitCodeBlock(block)
		OnBytecodeInvokeOffset(FindString(GlobalStrings, "entrypoint"))
		OnBytecodeHalt()
	}
}

CodeGenEmitGlobalBlockEpilogue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeExitEntity()
	}
}


IsStructureType : integer typeid -> boolean ret = false
{
	if((typeid & 0x7f000000) == 0x03000000)
	{
		ret = true
	}
	elseif((typeid & 0x7f000000) == 0x08000000)
	{
		ret = true
	}
}

IsReferenceType : integer typeid -> boolean ret = false
{
	if((typeid & 0x80000000) != 0)
	{
		ret = true
	}
}

MakeReferenceType : integer typeid -> integer reftypeid = typeid
{
	if(!IsReferenceType(typeid))
	{
		reftypeid = typeid + 0x80000000
	}
}

MakeNonReferenceType : integer typeid -> (typeid & 0x7fffffff)


append_recurse : list<Variable> ref thelist, nothing, Variable ref value
{
	list<Variable> newlist = value, nothing
	thelist.next = newlist
}

append_recurse : list<Variable> ref thelist, list<Variable> ref tail, Variable ref value
{
	append_recurse(tail, tail.next, value)
}


append : list<Variable> ref thelist, Variable ref value
{
	append_recurse(thelist, thelist.next, value)
}



CodeBlockDepth : list<OptionalCodeBlock> ref stack -> integer count = 0
{
	count = CodeBlockDepth(stack.next) + 1
}

CodeBlockDepth : nothing -> 0



IRProcess : -> boolean success = true
{
	if(!IRCompileTimeCodeExecution())
	{
		success = false
		return()
	}

	if(!IRTypeInference())
	{
		success = false
		return()
	}

	if(!IRValidate())
	{
		success = false
		return()
	}
}


IRCompileTimeCodeExecution : -> boolean success = true
{
	if(!CompileTimeCodeExecution(Functions))
	{
		success = false
	}
}



CompileTimeCodeExecution : nothing -> true


CompileTimeCodeExecution : list<FunctionDefinition> ref functions -> boolean success = true
{
	if(!CompileTimeCodeExecution(functions.value))
	{
		success = false
	}
	
	if(!CompileTimeCodeExecution(functions.next))
	{
		success = false
	}
}


CompileTimeCodeExecution : FunctionDefinition ref func -> boolean success = true
{
	// TODO
}

GeneratePendingTypeMatchers : list<PendingTypeMatcher> ref pendingmatchers -> boolean success = true
{
	if(!GeneratePendingTypeMatcher(pendingmatchers.value))
	{
		success = false
	}
	
	if(!GeneratePendingTypeMatchers(pendingmatchers.next))
	{
		success = false
	}
}

GeneratePendingTypeMatchers : nothing -> true

GeneratePendingTypeMatcher : PendingTypeMatcher ref matcher -> boolean success = true
{
	if(matcher.OverloadName == 0)
	{
		return()
	}

	if(!TypeMatcherExists(TypeMatchers, matcher.MatcherName))
	{
		OnCodeGenEnterTypeMatcher(matcher.MatcherName)
		OnCodeGenExitContext()
	}
	
	EnsureTypeMatcherIsConfigured(Functions, matcher.OverloadName, matcher.MatcherName)
}

EnsureTypeMatcherIsConfigured : list<FunctionDefinition> ref functions, integer overloadname, integer matchername
{
	if(functions.value.Name == overloadname)
	{
		CreateTypeMatcherEntryForFunction(functions.value, matchername)
		return()
	}

	EnsureTypeMatcherIsConfigured(functions.next, overloadname, matchername)
}


CreateTypeMatcherEntryForFunction : FunctionDefinition ref func, integer matchername
{
	integer name = func.Name		// TODO - more dumb compiler bug
	WalkParametersForTypeMatcher(func.Params, matchername, name)
}

WalkParametersForTypeMatcher : FunctionParams ref params, integer matchername, integer overloadname
{
	WalkParametersForTypeMatcherUnwrapped(params.Params, matchername, overloadname)
}


WalkParametersForTypeMatcherUnwrapped : list<UnresolvedParameter> ref params, integer matchername, integer overloadname
{
	if(params.value.NameHandle != 0)
	{
		OnCodeGenRegisterTypeMatchParam(matchername, overloadname, params.value.NameHandle, params.value.ResolvedType)
	}
	
	WalkParametersForTypeMatcherUnwrapped(params.next, matchername, overloadname)
}

WalkParametersForTypeMatcherUnwrapped : nothing, integer matchername, integer overloadname



DumpTypeList : simplelist<integer> ref types
{
	if(types.value != 0)
	{
		print(" Potential type: " ; GetPooledString(GlobalStrings, GetNameOfType(types.value)))
	}
	
	DumpTypeList(types.next)
}

DumpTypeList : nothing


structure InferenceContext :
	integer ScopeName,
	integer StatementName,
	simplelist<integer> ref ExpectedTypes,
	boolean FunctionReturn,
	integer NumParameters,
	boolean TopLevelStatement

structure TypePossibilityList :
	simplelist<integer> ref Types,
	boolean Consumed

structure InferencePossibility :
	integer FunctionName,
	list<TypePossibilityList> ref ParameterTypes,
	TypePossibilityList ref ReturnType

structure ExpressionInferenceStackEntry :
	list<InferencePossibility> ref PossibilityList


IRTypeInference : -> boolean success = true
{
	simplelist<integer> temp = 0, nothing
	InferenceContext context = 0, 0, temp, false, 0, false
	
	if(!TypeInference(SumTypes, context))
	{
		success = false
	}
	
	if(!TypeInference(Structures, context))
	{
		success = false
	}

	if(GlobalCodeBlockName != 0)
	{
		InferenceContext globalcontext = GlobalCodeBlockName, 0, temp, false, 0, false
		if(!TypeInference(GlobalCodeBlock, globalcontext))
		{
			success = false
		}
	}

	if(!TypeInference(Functions, context))
	{
		success = false
	}
}

TypeInference : nothing, InferenceContext ref context -> true


TypeInference : list<SumType> ref sumtypes, InferenceContext ref context -> boolean success = true
{
	if(sumtypes.value.Type != 0)
	{
		if(!ResolveSumTypeBases(sumtypes.value.Bases))
		{
			success = false
		}
	}
	
	if(!TypeInference(sumtypes.next, context))
	{
		success = false
	}
}

ResolveSumTypeBases : simplelist<integer> ref bases -> boolean success = true
{
	if(bases.value != 0)
	{
		integer resolvedtype = GetTypeByName(bases.value)
		if(resolvedtype == 0)
		{
			print("Sum type has unknown base type")
			success = false
		}
		else
		{
			bases.value = resolvedtype
		}
	}
	
	if(!ResolveSumTypeBases(bases.next))
	{
		success = false
	}
}

ResolveSumTypeBases : nothing -> true


TypeInference : list<StructureDefinition> ref structures, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(structures.value, context))
	{
		success = false
	}
	
	if(!TypeInference(structures.next, context))
	{
		success = false
	}
}

TypeInference : StructureDefinition ref structuredef, InferenceContext ref context -> boolean success = true
{
	if(structuredef.Name == 0)
	{
		return()
	}

	if(!TypeInference(structuredef.Members, context))
	{
		success = false
	}
	
	string readablename = GetPooledString(GlobalStrings, structuredef.Name)
	integer ctorname = PoolString(readablename ; "@@constructor")
	integer anonname = PoolString(readablename ; "@@anonconstructor")
	integer copyname = PoolString(readablename ; "@@copyconstructor")
	OnCodeGenRegisterConstructors(structuredef.Name, ctorname, anonname, copyname)
	
	Overload anonoverload = ctorname, anonname
	prepend<Overload>(Overloads, anonoverload)
	
	Overload copyoverload = ctorname, copyname
	prepend<Overload>(Overloads, copyoverload)
}


TypeInference : list<StructureMember> ref members, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(members.value, context))
	{
		success = false
	}
	
	if(!TypeInference(members.next, context))
	{
		success = false
	}
}

TypeInference : StructureMemberVariable ref memvar, InferenceContext ref context -> boolean success = true
{
	if(memvar.Name == 0)
	{
		return()
	}

	integer pretype = memvar.Type
	memvar.Type = GetTypeByName(memvar.TypeNameHandle)
	if(memvar.Type == 0)
	{
		print("Type not recognized: " ; GetPooledString(GlobalStrings, memvar.TypeNameHandle))
		success = false
	}
	else
	{
		memvar.Type = memvar.Type + pretype			// Hack to accept reference marker
	}
}

TypeInference : StructureMemberFunctionRef ref memfunc, InferenceContext ref context -> true


TypeInference : list<FunctionDefinition> ref functions, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(functions.value, context))
	{
		success = false
	}

	if(!TypeInference(functions.next, context))
	{
		success = false
	}
}

TypeInference : FunctionDefinition ref func, InferenceContext ref context -> boolean success = true
{
	if(func.InferenceDone)
	{
		return()
	}
	
	func.InferenceDone = true

	simplelist<integer> temp = 0, nothing
	InferenceContext innercontext = func.Name, 0, temp, false, 0, false
	
	
	if(!TypeInference(func.Params, innercontext))
	{
		print("Parameters to function failed type inference")
		success = false
	}
	

	simplelist<integer> tempret = 0, nothing
	InferenceContext retcontext = func.Name, 0, tempret, true, 0, false

	if(!TypeInference(func.Return, retcontext))
	{
		print("Function return expression failed type inference")
		success = false
	}
	
	integer rettype = GetOptionalExpressionType(func.Return)
	if((rettype != 0) && (rettype != 0x00000002))	// void magic
	{
		if(func.AnonymousReturn)
		{
			OnCodeGenRegisterVariable(func.Name, PoolString("@@anonymousret"), rettype, 2)
		}
	}
	
	if(!TypeInference(func.Code, innercontext))
	{
		print(GetPooledString(GlobalStrings, func.Name) ; "() - Function code body failed type inference")
		success = false
	}
}

TypeInference : FunctionParams ref params, InferenceContext ref context -> boolean success = TypeInference(params.Params, context)

TypeInference : list<UnresolvedParameter> ref params, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(params.value, context))
	{
		success = false
	}
	
	if(!TypeInference(params.next, context))
	{
		success = false
	}
}

TypeInference : UnresolvedParameter ref param, InferenceContext ref context -> boolean success = true
{
	param.ResolvedType = GetTypeByName(param.TypeNameHandle)
	if(param.ResolvedType == 0)
	{
		print("Unknown parameter type: " ; GetPooledString(GlobalStrings, param.TypeNameHandle))
		success = false
	}
	else
	{
		if(param.HasRefTag)
		{
			param.ResolvedType = param.ResolvedType + 0x80000000
		}
		
		OnCodeGenRegisterVariable(context.ScopeName, param.NameHandle, param.ResolvedType, 1)
	}
}

TypeInference : CodeBlock ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.Entries, context))
	{
		success = false
	}
}

TypeInference : list<CodeBlockEntry> ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.value, context))
	{
		success = false
	}

	if(!TypeInference(code.next, context))
	{
		success = false
	}
}

TypeInference : Statement ref statement, InferenceContext ref context -> boolean success = true
{
	integer paramcount = CountExpressions(statement.Parameters)

	integer vartype = GetTypeByName(statement.Name)
	if(vartype != 0)
	{
		integer origin = 0
		if(context.FunctionReturn)
		{
			origin = 2
		}
		
		while((vartype & 0x7f000000) == 0x05000000)
		{
			vartype = FindTypeAliasBase(TypeAliases, vartype)
		}
		
		if((vartype & 0x7f000000) == 0x03000000)
		{
			statement.Name = GetConstructorName(Structures, vartype)
		}
		else
		{
			statement.Name = GetNameOfType(vartype)
		}
		
		if(statement.TopLevel)
		{
			ConstructVariableFromStatement(statement, context.ScopeName, vartype, origin)
		}
	}
	
	InferenceContext newcontext = context.ScopeName, statement.Name, context.ExpectedTypes, false, paramcount, statement.TopLevel

	if(!TypeInference(statement.Parameters, newcontext))
	{
		success = false
		print("Type inference failed for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
	}


	simplelist<integer> paramtypes = 0, nothing
	AccumulateParameterTypes(paramtypes, statement.Parameters)
	
	integer overloadname = FindOverloadWithParameterTypes(Overloads, statement.Name, paramtypes)
	if(overloadname != 0)
	{
		statement.Name = overloadname
	}
	else
	{
		success = false
		print("No matching overload for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
	}
	
	if(context.FunctionReturn)
	{
		statement.Type = vartype
	}
	else
	{
		statement.Type = GetFunctionReturnType(Functions, statement.Name)
	}
	
	MakeParametersReferences(Functions, statement.Name, statement.Parameters)

	if(vartype != 0)
	{
		InsertAnnotationsForTypeMatchedParams(Functions, statement.Name, statement.Parameters)
	}
	elseif(IsPendingTypeMatcher(PendingTypeMatchers, overloadname))
	{
		AnnotateAllParameters(statement.Parameters)
	}
}

CountExpressions : nothing -> 0

CountExpressions : ExpressionList ref exprs -> integer count = CountExpressions(exprs.Expressions)

CountExpressions : list<Expression> ref exprs -> integer count = 1
{
	count += CountExpressions(exprs.next)
}


AnnotateAllParameters : ExpressionList ref exprs
{
	AnnotateAllParameters(exprs.Expressions)
}

AnnotateAllParameters : list<Expression> ref params
{
	AddTypeAnnotation(params.value)
	AnnotateAllParameters(params.next)
}

AnnotateAllParameters : nothing


AnnotateNonReferenceParameters : ExpressionList ref exprs
{
	AnnotateNonReferenceParameters(exprs.Expressions)
}

AnnotateNonReferenceParameters : list<Expression> ref params
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	AnnotateNonReferenceParameters(params.next)
}

AnnotateNonReferenceParameters : nothing



AddTypeAnnotation : nothing

AddTypeAnnotation : list<Expression> ref params
{
	AddTypeAnnotation(params.value)
}

AddTypeAnnotation : Expression ref expr
{
	integer typeid = expr.Type
	TypeAnnotationAtom atom = typeid
	ExpressionAtom wrap = atom
	AppendAtomToExpression(expr.Atoms, expr.Atoms.next, wrap)
}


AccumulateParameterTypes : simplelist<integer> ref types, OptionalExpressionList ref exprs
{
	AccumulateParameterTypesUnwrap(types, exprs)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, ExpressionList ref exprs
{
	AccumulateParameterTypesUnwrapped(exprs.Expressions, types)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, nothing

AccumulateParameterTypesUnwrapped : list<Expression> ref exprs, simplelist<integer> ref types
{
	AccumulateParameterTypesUnwrapped(exprs.next, types)
	simpleprepend<integer>(types, exprs.value.Type)
}

AccumulateParameterTypesUnwrapped : nothing, simplelist<integer> ref types


FindOverloadWithParameterTypes : list<Overload> ref overloads, integer rawname, simplelist<integer> ref types -> integer overloadname = rawname
{
	if(overloads.value.NormalName == rawname)
	{
		if(FunctionMatchesParameterTypes(Functions, overloads.value.MangledName, types))
		{
			overloadname = overloads.value.MangledName
			return()
		}
		elseif(countnonzero(types) == GetFunctionParameterCount(Functions, overloads.value.MangledName))
		{
			if(CheckForNeededTypeMatcher(types))
			{
				overloadname = FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName)
				FindOverloadWithParameterTypes(overloads.next, rawname, types)
				return()
			}
		}
	}

	overloadname = FindOverloadWithParameterTypes(overloads.next, rawname, types)
}


GetFunctionParameterCount : list<FunctionDefinition> ref functions, integer funcname -> integer count = 0
{
	if(functions.value.Name == funcname)
	{
		count = CountUnresolvedParameters(functions.value.Params)
	}
	else
	{
		count = GetFunctionParameterCount(functions.next, funcname)
	}
}

GetFunctionParameterCount : nothing, integer funcname -> integer count = -1
{
	string readablename = GetPooledString(GlobalStrings, funcname)
	if(readablename == "substring@@withlength")
	{
		count = 3
	}
	elseif(readablename == "substring@@nolength")
	{
		count = 2
	}
}



CountUnresolvedParameters : FunctionParams ref params -> integer count = CountUnresolvedParametersUnwrapped(params.Params)
CountUnresolvedParameters : nothing -> 0

CountUnresolvedParametersUnwrapped : list<UnresolvedParameter> ref params -> integer count = 0
{
	if(params.value.NameHandle != 0)
	{
		 ++count
	}
	
	count += CountUnresolvedParametersUnwrapped(params.next)
}

CountUnresolvedParametersUnwrapped : nothing -> 0


CheckForNeededTypeMatcher : simplelist<integer> ref types -> boolean needsmatcher = false
{
	if((types.value & 0x7f000000) == 0x07000000)
	{
		needsmatcher = true
	}
	else
	{
		needsmatcher = CheckForNeededTypeMatcher(types.next)
	}
}

CheckForNeededTypeMatcher : nothing -> false


FindOverloadWithParameterTypes : nothing, integer rawname, simplelist<integer> ref types -> integer overloadname = 0
{
	string readablename = GetPooledString(GlobalStrings, rawname)
	if(readablename == "substring")
	{
		integer withlen = PoolString("substring@@withlength")
		integer nolen = PoolString("substring@@nolength")
		
		if(FunctionMatchesParameterTypes(nothing, withlen, types))
		{
			overloadname = withlen
		}
		elseif(FunctionMatchesParameterTypes(nothing, nolen, types))
		{
			overloadname = nolen
		}
	}
	else
	{
		if(ConstructorMatchesParameterTypes(Structures, rawname, types))
		{
			overloadname = rawname
		}
		elseif((!StructureConstructorExists(Structures, rawname)) && (!FunctionExists(Functions, rawname)))
		{
			overloadname = rawname
		}
	}
}


FunctionMatchesParameterTypes : list<FunctionDefinition> ref functions, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	if(functions.value.Name == funcname)
	{
		match = CheckParameterTypesForMatch(functions.value.Params, types)
	}
	else
	{
		match = FunctionMatchesParameterTypes(functions.next, funcname, types)
	}
}

FunctionMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	string readablename = GetPooledString(GlobalStrings, funcname)
	if(readablename == "substring@@withlength")
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(readablename == "substring@@nolength")
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	else
	{
		match = ConstructorMatchesParameterTypes(Structures, funcname, types)
	}
}


ConstructorMatchesParameterTypes : list<StructureDefinition> ref structures, integer ctorname, simplelist<integer> ref types -> boolean match = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}
		
		match = CheckMemberTypes(structures.value.Members, types.next)
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		match = CheckMemberTypes(structures.value.Members, types)
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}
		
		match = CheckCopyType(types.next, structures.value.Type)
	}
	else
	{
		match = ConstructorMatchesParameterTypes(structures.next, ctorname, types)
	}
}

ConstructorMatchesParameterTypes : nothing, integer ctorname, simplelist<integer> ref types -> false


CheckCopyType : simplelist<integer> ref a, integer b -> boolean match = (a.value == b)


CheckParameterTypesForMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	integer count = countnonzero(types)
	if(count == 0)
	{
		match = true
	}
	elseif(count == 1)
	{
		if(types.value == 0x00000002)		// void type signature
		{
			match = true
		}
	}
}

CheckParameterTypesForMatch : FunctionParams ref params, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(params.Params, types)

CheckParameterTypesForMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	if(!ResolvedTypesMatch(params, types))
	{
		match = false
	}
}

CheckParameterTypesForMatch : simplelist<integer> ref atypes, simplelist<integer> ref btypes -> boolean match = TypesMatch(atypes, btypes)


TypesMatch : simplelist<integer> ref a, simplelist<integer> ref b -> boolean match = true
{
	if(a.value != b.value)
	{
		match = false
	}
	else
	{
		match = TypesMatch(a.next, b.next)
	}
}

TypesMatch : nothing, nothing -> true

TypesMatch : nothing, simplelist<integer> ref b -> boolean match = (b.value == 0)
TypesMatch : simplelist<integer> ref a, nothing -> boolean match = (a.value == 0)



ResolvedTypesMatch : nothing, nothing -> true

ResolvedTypesMatch : list<UnresolvedParameter> ref params, nothing -> false
ResolvedTypesMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}

ResolvedTypesMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	integer resolved = params.value.ResolvedType
	while((resolved & 0x7f000000) == 0x05000000)
	{
		resolved = FindTypeAliasBase(TypeAliases, resolved)
	}

	integer expected = types.value
	while((expected & 0x7f000000) == 0x0500000)
	{
		expected = FindTypeAliasBase(TypeAliases, expected)
	}

	if(resolved != expected)
	{
		match = false
	}
	else
	{
		listnode<UnresolvedParameter> n = params.next
		simplelistnode<integer> nt = types.next
		match = ResolvedTypesMatch(n, nt)			// TODO - this is some kind of compiler bug... or maybe a runtime bug?!
	}
}


TypeInference : Assignment ref assignment, InferenceContext ref context -> boolean success = true
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(context.ScopeName, assignment.LHSName, var)

	simplelist<integer> temp = var.VarType, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		DumpExpressionAtoms(assignment.RHS.Atoms)
		success = false
	}
		
	assignment.LHSType = var.VarType
	
	if(assignment.LHSType != assignment.RHS.Type)
	{
		// TODO - check type of RHS vs. LHS?
		
		assignment.Annotation = assignment.RHS.Type
	}
}

TypeInference : AssignmentCompound ref assignment, InferenceContext ref context -> boolean success = true
{
	integer hack = context.ScopeName
	integer lhstype = ComputeCompoundAssignmentLHSType(assignment, hack)
	
	simplelist<integer> temp = lhstype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		DumpExpressionAtoms(assignment.RHS.Atoms)
		success = false
	}
	
	assignment.LHSType = lhstype

	if(assignment.LHSType != assignment.RHS.Type)
	{
		// TODO - check type of RHS vs. LHS?
		
		assignment.Annotation = assignment.RHS.Type
	}
}

TypeInference : EntityChain ref chain, InferenceContext ref context -> boolean success = TypeInference(chain.Entries, context)

TypeInference : EntityList ref entities, InferenceContext ref context -> boolean success = TypeInference(entities.ActualList, context)

TypeInference : list<Entity> ref entities, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(entities.value, context))
	{
		success = false
	}
	
	if(!TypeInference(entities.next, context))
	{
		success = false
	}
}

TypeInference : Entity ref entity, InferenceContext ref context -> boolean success = true
{
	simplelist<integer> temp = 0x01000003, nothing			// TODO - don't assume all entities take a boolean!
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false
	
	if(!TypeInference(entity.Param, newcontext))
	{
		success = false
	}
	
	if(!TypeInference(entity.Code, context))
	{
		success = false
	}
}


TypeInference : ExpressionList ref parameters, InferenceContext ref context -> boolean success = true
{
	if(!TypeInferenceExpressionList(parameters.Expressions, context, 0))
	{
		success = false
	}
}

TypeInferenceExpressionList : list<Expression> ref parameters, InferenceContext ref context, integer paramindex -> boolean success = true
{
	simplelist<integer> temp = 0, nothing
	GetExpectedParameterTypes(context.StatementName, paramindex, context.NumParameters, context.TopLevelStatement, temp)
	InferenceContext newcontext = context.ScopeName, context.StatementName, temp, context.FunctionReturn, context.NumParameters, context.TopLevelStatement

	if(!TypeInference(parameters.value, newcontext))
	{
		print("Parameter " ; cast(string, paramindex) ; " failed type inference!")	
		success = false
	}
	else
	{
		context.StatementName = newcontext.StatementName
	}

	if(!TypeInferenceExpressionList(parameters.next, context, paramindex + 1))
	{
		success = false
	}
}

TypeInferenceExpressionList : nothing, InferenceContext ref context, integer paramindex -> boolean success = true


TypeInference : Expression ref expression, InferenceContext ref context -> boolean success = true
{
	if(expression.Type != 0)
	{
		return()
	}

	if(ExpressionAtomIsSentinel(expression.Atoms.value))
	{
		expression.Type = 0x00000002
		return()
	}

	CoalesceMemberAccesses(expression.Atoms, context.ScopeName)
	ShuntingYard(expression.Atoms)

	InferencePossibility temp = scratchpossibility
	list<InferencePossibility> possibilities = temp, nothing
	ExpressionInferenceStackEntry stackentry = possibilities
	list<ExpressionInferenceStackEntry> stack = stackentry, nothing

	integer counter = 0
	integer scopename = context.ScopeName
		
	boolean flag = context.FunctionReturn		// TODO - stupid workaround for a compiler bug
	WalkAtomsForType(expression.Atoms, expression.Atoms.next, stack, counter, scopename, flag)
	
	integer possibilitycount = CountPossibilities(stack.value.PossibilityList)
	if(possibilitycount == 1)
	{
		if((!context.FunctionReturn) && (context.StatementName != 0))
		{
			simplelist<integer> types = 0, nothing
			EliminateImpossibleType(stack.value.PossibilityList.value.ReturnType.Types, context.ExpectedTypes, types)

			integer typecount = countnonzero(types)
			if(typecount == 1)
			{
				assert(types.value != 0)
				expression.Type = types.value
			}
			elseif(typecount > 1)
			{
				print("Multiple types possible:")
				DumpTypeList(types)
			}
			else
			{
				// TODO - demotion logic here is MESSY
				if((countnonzero(stack.value.PossibilityList.value.ReturnType.Types) == 1) && (countnonzero(context.ExpectedTypes) == 1) && (stack.value.PossibilityList.value.ReturnType.Types.value == 0x01000001) && (context.ExpectedTypes.value == 0x01000002))
				{
					expression.Type = 0x01000002
				}
				else
				{
					print("All types ruled out")
					DumpTypeList(stack.value.PossibilityList.value.ReturnType.Types)
					print("Expected types are")
					DumpTypeList(context.ExpectedTypes)
				}
			}
		}
		else
		{
			simplelist<integer> possibletypes = 0, nothing
			FilterTypesForDemotion(stack.value.PossibilityList.value.ReturnType.Types, possibletypes)
			
			integer typecount = countnonzero(possibletypes)
			if(typecount == 1)
			{
				expression.Type = possibletypes.value
				assert(expression.Type != 0)
			}
			elseif(context.FunctionReturn)
			{
				print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
				DumpTypeList(possibletypes)
			}
			else
			{
				print("Expression has " ; cast(string, typecount) ; " types possible")
				DumpTypeList(possibletypes)
			}
		}
	}
	else
	{
		// TODO - error context!
		if(possibilitycount > 0)
		{
			print("Multiple overloads possible:")
			DumpOverloadList(stack.value.PossibilityList)
		}
		else
		{
			print("No types possible in this expression:")
			DumpExpressionAtoms(expression.Atoms)
			print("End expression")
		}
	}

	if(expression.Type == 0)
	{
		success = false
	}
	elseif(expression.Type == 0x01000002)
	{
		DemoteAtomType(expression.Atoms)
	}
}



CountPossibilities : list<InferencePossibility> ref thelist -> integer count = 0
{
	count = CountPossibilities(thelist.next)

	if(thelist.value.FunctionName != 0)
	{
		++count
	}
}

CountPossibilities : nothing -> 0


countnonzero : simplelist<integer> ref thelist -> integer count = 0
{
	count = countnonzero(thelist.next)

	if(thelist.value != 0)
	{
		++count
	}
}

countnonzero : nothing -> 0



WalkAtomsForType : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, integer funcname, boolean funcret -> boolean demotedtoright = false
{
	boolean didrightdemote = WalkAtomsForType(tail, tail.next, stack, counter, funcname, funcret)
	
	if(IsOperatorInvoke(atoms.value))
	{
		if(counter > 0)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter + 1)
			--counter
		}
		
		list<InferencePossibility> possibleoperators = scratchpossibility, nothing
		GetAtomTypeOperator(atoms.value, possibleoperators)
		
		ExpressionInferenceStackEntry entry = possibleoperators
		prepend<ExpressionInferenceStackEntry>(stack, entry)
	}
	else
	{
		list<InferencePossibility> out = scratchpossibility, nothing
		EliminateImpossibleParametersForAllOverloads(stack.value.PossibilityList, out, atoms.value, funcname, funcret)
		
		if(counter == 1)
		{
			list<InferencePossibility> filtered = scratchpossibility, nothing
			FilterOverloadsForTypeDemotion(out, filtered)
			stack.value.PossibilityList = filtered
		}
		else
		{
			stack.value.PossibilityList = out
		}

		if(CountPossibilities(stack.value.PossibilityList) == 1)
		{
			if(listcontains(stack.value.PossibilityList.value.ParameterTypes.value.Types, 0x01000002))
			{
				DemoteAtomType(atoms)
				demotedtoright = true
				
				if((!didrightdemote) && (!IsOperatorInvoke(tail.value)))
				{
					DemoteAtomType(tail)
				}
			}
		}
		elseif(didrightdemote)
		{
			DemoteAtomType(atoms)
		}
	
		if(AllOptionsConsumed(stack.value.PossibilityList.value.ParameterTypes))
		{
			TypePossibilityList rettypes = stack.value.PossibilityList.value.ReturnType
			PopExpressionInferenceStack(stack, stack.next)
			AddPossibleParamTypeForAllOverloads(stack.value.PossibilityList, rettypes)
		}
		
		++counter
		if(counter > 1)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter)
			++counter
		}
	}
}


AddPossibleParamTypeForAllOverloads : list<InferencePossibility> ref possibilities, TypePossibilityList ref paramtypes
{
	prepend<TypePossibilityList>(possibilities.value.ParameterTypes, paramtypes)

	AddPossibleParamTypeForAllOverloads(possibilities.next, paramtypes)
}

AddPossibleParamTypeForAllOverloads : nothing, TypePossibilityList ref paramtypes


AllOptionsConsumed : list<TypePossibilityList> ref options -> boolean allconsumed = true
{
	if(!options.value.Consumed)
	{
		allconsumed = false
	}
	else
	{
		allconsumed = AllOptionsConsumed(options.next)
	}
}

AllOptionsConsumed : nothing -> true


PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail
{
	stack = tail
}

PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, nothing


WalkAtomsForType : list<ExpressionAtom> ref atoms, nothing, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, integer funcname, boolean funcret -> false
{
	if(IsOperatorInvoke(atoms.value))
	{
		GetAtomTypeOperator(atoms.value, stack.value.PossibilityList)
	}
	else
	{
		TypePossibilityList poss = scratchparams
		GetAtomType(atoms.value, poss, funcname, funcret)

		InferencePossibility newpossibility = -1, scratchparampossibles, poss
		prepend<InferencePossibility>(stack.value.PossibilityList, newpossibility)
	}
}


EliminateImpossibleParametersForAllOverloads : list<InferencePossibility> ref possibilities, list<InferencePossibility> ref out, ExpressionAtom ref atom, integer funcname, boolean funcret
{
	if(possibilities.value.FunctionName != 0)
	{
		if(EliminateImpossibleParameters(possibilities.value.ParameterTypes, atom, funcname, funcret))
		{
			prepend<InferencePossibility>(out, possibilities.value)
		}
	}
	
	EliminateImpossibleParametersForAllOverloads(possibilities.next, out, atom, funcname, funcret)
}

EliminateImpossibleParametersForAllOverloads : nothing, list<InferencePossibility> ref out, ExpressionAtom ref atom, integer funcname, boolean funcret


EliminateImpossibleParameters : list<TypePossibilityList> ref params, ExpressionAtom ref atom, integer funcname, boolean funcret -> boolean valid = true
{
	if(!params.value.Consumed)
	{
		TypePossibilityList poss = scratchparams
		GetAtomType(atom, poss, funcname, funcret)
		
		simplelist<integer> types = 0, nothing
		EliminateImpossibleType(params.value.Types, poss.Types, types)
		
		params.value.Types = types
		
		if(countnonzero(types) == 0)
		{
			valid = false
		}
		
		params.value.Consumed = true
	}
	else
	{
		if(!EliminateImpossibleParameters(params.next, atom, funcname, funcret))
		{
			valid = false
		}
	}
}


SetOperatorAtomToOverload : list<ExpressionAtom> ref atoms, integer overloadname, integer count
{
	if(count == 0)
	{
		if(!IsOperatorInvoke(atoms.value))
		{
			print("Internal error: operator " ; GetPooledString(GlobalStrings, overloadname) ; " cannot be placed in expression")
			DumpAtom(atoms.value)
			assert(false)
		}
		
		ChangeOperator(atoms.value, overloadname)
	}
	else
	{
		SetOperatorAtomToOverload(atoms.next, overloadname, count - 1)
	}
}

ChangeOperator : OperatorInvokeAtom ref atom, integer overloadname
{
	atom.OperatorName = overloadname
}



EliminateImpossibleType : simplelist<integer> ref possibles, simplelist<integer> ref filter, simplelist<integer> ref out
{
	EliminateImpossibleType(possibles.next, filter, out)
	
	if(possibles.value != 0)
	{
		integer expectedtype = TypeListContains(filter, possibles.value)
		if(expectedtype != 0)
		{
			simpleprepend<integer>(out, expectedtype)
		}
	}
}

EliminateImpossibleType : nothing, simplelist<integer> ref filter, simplelist<integer> ref out



GetAtomType : AtomSentinel       ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x00000002) }	// void magic
GetAtomType : StringHandleAtom   ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x02000000) }
GetAtomType : TypeAnnotationAtom ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000001) }
GetAtomType : integer16          ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000002) }
GetAtomType : boolean            ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000003) }
GetAtomType : real               ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, 0x01000004) }

GetAtomType : integer            ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{
	AddPossibleParameter(possibilities.Types, 0x01000001)
	AddPossibleParameter(possibilities.Types, 0x01000002)			// Allow demotion later
}

GetAtomType : CompoundAtom       ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret { AddPossibleParameter(possibilities.Types, atom.Type)  }

GetAtomType : Statement ref statement, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{	
	simplelist<integer> temp = 0, nothing
	InferenceContext newcontext = funcname, statement.Name, temp, funcret, 0, false
	
	if(TypeInference(statement, newcontext))
	{
		AddPossibleParameter(possibilities.Types, statement.Type)
	}
}

GetAtomType : RefBinding ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret

GetAtomType : ParentheticalExpression ref parenthetical, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{
	simplelist<integer> temp = 0, nothing
	InferenceContext newcontext = funcname, 0, temp, funcret, 0, false
		
	if(TypeInference(parenthetical.Inner, newcontext))
	{
		AddPossibleParameter(possibilities.Types, parenthetical.Inner.Type)
	}
	else
	{
		print("Parenthetical expression failed type inference")
	}
}

GetAtomTypeOperator : OperatorInvokeAtom ref atom, list<InferencePossibility> ref possibilities
{
	AddPossibilityPerOperatorOverload(atom.OperatorName, possibilities)
}

GetAtomType : IdentifierAtom ref atom, TypePossibilityList ref possibilities, integer funcname, boolean funcret
{	
	if(GetPooledString(GlobalStrings, atom.Handle) == "nothing")
	{
		atom.Type = 0x00000004
		AddPossibleParameter(possibilities.Types, 0x00000004)
		return()
	}

	AddPossibleParameter(possibilities.Types, 0x01000000)

	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(funcname, atom.Handle, var)
	if(var.Name != 0)
	{
		AddPossibleParameter(possibilities.Types, var.VarType)
	}
	else
	{
		print(GetPooledString(GlobalStrings, atom.Handle) ; " is not a defined identifier!")
	}
}


IsOperatorInvoke : OperatorInvokeAtom 	   ref nonsentinel -> true

IsOperatorInvoke : AtomSentinel 	   ref sentinel    -> false
IsOperatorInvoke : StringHandleAtom 	   ref nonsentinel -> false
IsOperatorInvoke : IdentifierAtom 	   ref nonsentinel -> false
IsOperatorInvoke : TypeAnnotationAtom 	   ref nonsentinel -> false
IsOperatorInvoke : integer 		   ref nonsentinel -> false
IsOperatorInvoke : integer16 		   ref nonsentinel -> false
IsOperatorInvoke : boolean 		   ref nonsentinel -> false
IsOperatorInvoke : real 		   ref nonsentinel -> false
IsOperatorInvoke : Statement		   ref nonsentinel -> false
IsOperatorInvoke : RefBinding              ref nonsentinel -> false
IsOperatorInvoke : CompoundAtom		   ref nonsentinel -> false
IsOperatorInvoke : ParentheticalExpression ref nonsentinel -> false


IsMemberAccessOperator : OperatorInvokeAtom 	 ref nonsentinel -> boolean ismemberaccess = false
{
	if(GetPooledString(GlobalStrings, nonsentinel.OperatorName) == ".")
	{
		ismemberaccess = true
	}
}

IsMemberAccessOperator : AtomSentinel 	   	 ref sentinel    -> false
IsMemberAccessOperator : StringHandleAtom 	 ref nonsentinel -> false
IsMemberAccessOperator : IdentifierAtom 	 ref nonsentinel -> false
IsMemberAccessOperator : TypeAnnotationAtom 	 ref nonsentinel -> false
IsMemberAccessOperator : integer 		 ref nonsentinel -> false
IsMemberAccessOperator : integer16 		 ref nonsentinel -> false
IsMemberAccessOperator : boolean 		 ref nonsentinel -> false
IsMemberAccessOperator : real 		   	 ref nonsentinel -> false
IsMemberAccessOperator : Statement		 ref nonsentinel -> false
IsMemberAccessOperator : RefBinding              ref nonsentinel -> false
IsMemberAccessOperator : CompoundAtom            ref nonsentinel -> false
IsMemberAccessOperator : ParentheticalExpression ref nonsentinel -> false



MarkAtomAsReference : OperatorInvokeAtom      ref atom -> false
MarkAtomAsReference : AtomSentinel 	      ref atom -> false
MarkAtomAsReference : StringHandleAtom 	      ref atom -> false
MarkAtomAsReference : TypeAnnotationAtom      ref atom -> false
MarkAtomAsReference : integer 		      ref atom -> false
MarkAtomAsReference : integer16               ref atom -> false
MarkAtomAsReference : boolean 		      ref atom -> false
MarkAtomAsReference : real 		      ref atom -> false
MarkAtomAsReference : Statement		      ref atom -> false
MarkAtomAsReference : ParentheticalExpression ref atom -> false

MarkAtomAsReference : RefBinding              ref atom -> true

MarkAtomAsReference : IdentifierAtom          ref atom -> true
{
	atom.IsReference = true
}

MarkAtomAsReference : CompoundAtom            ref atom -> true
{
	atom.Type = MakeReferenceType(atom.Type)
}


AddPossibleParameter : simplelist<integer> ref possibilities, integer paramtype
{
	simpleprepend<integer>(possibilities, paramtype)
	
	if((paramtype & 0x7f000000) == 0x05000000)
	{
		simpleprepend<integer>(possibilities, FindTypeAliasBase(TypeAliases, paramtype))
	}
}

AddBinaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer param2type, integer rettype
{
	assert(functionname != 0)

	simplelist<integer> p1t = param1type, nothing
	simplelist<integer> p2t = param2type, nothing

	TypePossibilityList param1options = p1t, false
	TypePossibilityList param2options = p2t, false

	list<TypePossibilityList> paramtypes = scratchparams, nothing
	prepend<TypePossibilityList>(paramtypes, param2options)
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}



ShuntingYard : list<ExpressionAtom> ref atoms
{
	AtomSentinel sentinel = 0

	list<ExpressionAtom> outputqueue = sentinel, nothing
	list<ExpressionAtom> opstack = sentinel, nothing

	ShuntingYardWalk(atoms, outputqueue, opstack)
	ShuntingYardFlush(outputqueue, opstack)

	atoms = outputqueue
}

ShuntingYardWalk : nothing, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack

ShuntingYardWalk : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	ShuntingYardVisit(atoms.value, outputqueue, opstack)
	ShuntingYardWalk(atoms.next, outputqueue, opstack)
}

ShuntingYardVisit : AtomSentinel            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
ShuntingYardVisit : StringHandleAtom        ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : IdentifierAtom          ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : TypeAnnotationAtom      ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer16               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : boolean                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : real                    ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : Statement               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : RefBinding              ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : ParentheticalExpression ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : CompoundAtom            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }

ShuntingYardVisit : OperatorInvokeAtom ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	integer opprec = GetOperatorPrecedence(atom)
	boolean continueops = true

	while(continueops && (!ExpressionAtomIsSentinel(opstack.value)))
	{
		ExpressionAtom opatom2 = opstack.value
		integer op2prec = GetOperatorPrecedence(opatom2)

		// TODO - this whole section is hacky. Replace with break() calls and >= operator.

		if(false)		// TODO - check for unary operators
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
			elseif(opprec == op2prec)
			{
				continueops = false
			}
		}
		else
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
		}

		if(continueops)
		{
			PlaceAtomInList(outputqueue, opatom2)
			ShuntingYardPopStack(opstack, opstack.next)
		}
	}

	ExpressionAtom wrap = atom
	prepend<ExpressionAtom>(opstack, wrap)
}

ShuntingYardFlush : list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	while(!ExpressionAtomIsSentinel(opstack.value))
	{
		PlaceAtomInList(outputqueue, opstack.value)
		ShuntingYardPopStack(opstack, opstack.next)
	}
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, list<ExpressionAtom> ref tail
{
	opstack = tail
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, nothing
{
	AtomSentinel sentinel = 0
	list<ExpressionAtom> newlist = sentinel, nothing
	opstack = newlist
}


GetOperatorPrecedence : OperatorInvokeAtom ref atom -> integer precedence = 0
{
	string basename = GetPooledString(GlobalStrings, atom.OperatorName)
	if(basename == "==")
	{
		precedence = 0
	}
	elseif(basename == "!=")
	{
		precedence = 0
	}
	elseif(basename == ">")
	{
		precedence = 0
	}
	elseif(basename == ";")
	{
		precedence = 3
	}
	elseif(basename == "+")
	{
		precedence = 5
	}
	elseif(basename == "-")
	{
		precedence = 5
	}
	elseif(basename == "*")
	{
		precedence = 9
	}
	elseif(basename == "/")
	{
		precedence = 9
	}
	elseif(basename == ".")
	{
		precedence = 11
	}
	else
	{
		print("Unknown operator " ; basename)
		assert(false)
	}
}


ConstructVariableFromStatement : Statement ref statement, integer scopename, integer vartype, integer origin
{
	integer varname = ExtractConstructorIdentifier(statement.Parameters)
		
	if(varname != 0)
	{
		StoreVariableInScope(Scopes, scopename, varname, vartype, false, origin)
	}
}

ExtractConstructorIdentifier : ExpressionList ref parameters -> integer varname = ExtractConstructorIdentifier(parameters.Expressions)
ExtractConstructorIdentifier : list<Expression> ref parameters -> integer varname = ExtractIdentifier(parameters.value)
ExtractConstructorIdentifier : nothing -> 0

ExtractIdentifier : Expression ref expression -> integer id = ExtractIdentifier(expression.Atoms.value)

ExtractIdentifier : IdentifierAtom ref atom -> atom.Handle
{
	atom.Type = 0x81000000		// HACK - reference to identifier
}

ExtractIdentifier : AtomSentinel 	    ref sentinel    -> 0
ExtractIdentifier : StringHandleAtom 	    ref nonsentinel -> 0
ExtractIdentifier : OperatorInvokeAtom 	    ref nonsentinel -> 0
ExtractIdentifier : TypeAnnotationAtom 	    ref nonsentinel -> 0
ExtractIdentifier : integer 		    ref nonsentinel -> 0
ExtractIdentifier : integer16 		    ref nonsentinel -> 0
ExtractIdentifier : boolean 		    ref nonsentinel -> 0
ExtractIdentifier : real 		    ref nonsentinel -> 0
ExtractIdentifier : Statement		    ref nonsentinel -> 0
ExtractIdentifier : RefBinding              ref nonsentinel -> 0
ExtractIdentifier : CompoundAtom            ref nonsentinel -> 0
ExtractIdentifier : ParentheticalExpression ref nonsentinel -> 0


PlaceAtomInList : list<ExpressionAtom> ref atoms, ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(atoms.value))
	{
		list<ExpressionAtom> newatoms = atom, nothing
		atoms = newatoms
	}
	else
	{
		AppendAtomToExpression(atoms, atoms.next, atom)
	}
}



IRValidate : -> true



PoolString : string s -> integer handle = FindString(GlobalStrings, s)
{
	if(handle == 0)
	{
		++CurrentStringHandle
		OnCodeGenRegisterString(CurrentStringHandle, s)
		handle = CurrentStringHandle
	}
}



IREnterProgram :
{
}

IRExitProgram :
{
}


IREnterFunction : integer namehandle
{
	OnCodeGenRegisterScope(namehandle, 0)
}

IRExitFunction :
{
	OnCodeGenExitContext()
}

IREnterCodeBlock :
{
	// TODO
}

IRExitCodeBlock :
{
	//OnCodeGenExitContext()
}


IREnterStatement : string funcname, boolean istoplevel
{
	integer namehandle = PoolString(funcname)
	OnCodeGenEnterStatement(namehandle, 0, istoplevel)
}

IRExitStatement :
{
	OnCodeGenExitContext()
}


IREnterExpression :
{
	++IRExpressionDepth		// TODO - this should be a stack so we can have nested statements
}

IRExitExpression :
{
	--IRExpressionDepth

	if(IRExpressionDepth == 0)
	{
		//OnCodeGenShiftParameter()
	}
}


IRAddOperator : string operatorname
{
	OnCodeGenRegisterOperatorInvoke(PoolString(operatorname))
}

IRAddLiteralString : string literal
{
	OnCodeGenRegisterLiteralString(PoolString(literal))
}

IRAddLiteralBoolean : boolean literal
{
	OnCodeGenRegisterLiteralBoolean(literal)
}

IRAddLiteralReal : real literal
{
	OnCodeGenRegisterLiteralReal(literal)
}

IRAddLiteralInteger : integer literal
{
	OnCodeGenRegisterLiteralInteger(literal, 0x01000001)		// We can demote the integer later
}

IRAddLiteralIdentifier : string token
{
	OnCodeGenRegisterAtomIdentifier(PoolString(token), 0)
}



GetPooledString : list<StringTableEntry> ref strings, integer handle -> string pooled = "" [nogc]
{
	if(strings.value.Handle == handle)
	{
		pooled = strings.value.Data
	}
	else
	{
		pooled = GetPooledString(strings.next, handle)
	}
}

GetPooledString : nothing, integer handle -> "" [nogc]
{
	print("String handle not pooled: " ; cast(string, handle))
	assert(false)
}


DumpAtom : AtomSentinel 	   ref sentinel    { print("Sentinel") }
DumpAtom : StringHandleAtom 	   ref nonsentinel { print("String handle " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : IdentifierAtom 	   ref nonsentinel { print("Identifier " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : OperatorInvokeAtom 	   ref nonsentinel { print("Operator " ; cast(string, nonsentinel.OperatorName)) }
DumpAtom : TypeAnnotationAtom 	   ref nonsentinel { print("Type annotation") }
DumpAtom : integer 		   ref nonsentinel { print("integer " ; cast(string, nonsentinel)) }
DumpAtom : integer16 		   ref nonsentinel { print("integer16") }
DumpAtom : boolean 		   ref nonsentinel { print("boolean") }
DumpAtom : real 		   ref nonsentinel { print("real " ; cast(string, nonsentinel)) }
DumpAtom : RefBinding              ref nonsentinel { print("RefBinding") }
DumpAtom : ParentheticalExpression ref nonsentinel { print("Parenthetical") }
DumpAtom : CompoundAtom            ref nonsentinel { print("Compound") }

DumpAtom : Statement		   ref nonsentinel
{
	print("Statement")
	print("BEGIN PARAMS")
	DumpParameterAtoms(nonsentinel.Parameters)
	print("END PARAMS")
}

DumpExpressionAtoms : list<ExpressionAtom> ref atoms
{
	DumpAtom(atoms.value)
	DumpExpressionAtoms(atoms.next)
}

DumpExpressionAtoms : nothing


DumpExpressionList : list<Expression> ref exprs
{
	print("BEGIN EXPR")
	DumpExpressionAtoms(exprs.value.Atoms)
	print("END EXPR")

	DumpExpressionList(exprs.next)
}

DumpExpressionList : nothing


DumpParameterAtoms : ExpressionList ref exprs
{
	DumpExpressionList(exprs.Expressions)
}

DumpParameterAtoms : nothing



AddPossibilityPerOperatorOverload : integer basenamehandle, list<InferencePossibility> ref possibilities
{
	string basename = GetPooledString(GlobalStrings, basenamehandle)
	if(basename == "==")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@integer"),   0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@integer16"), 0x01000002, 0x01000002, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@boolean"),   0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "==@@string"),    0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basename == "!=")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "!=@@integer"), 0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "!=@@boolean"), 0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "!=@@string"),  0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basename == ">")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, ">@@integer"), 0x01000001, 0x01000001, 0x01000003)
	}
	elseif(basename == "+")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "+@@integer"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == "-")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "-@@integer"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == "*")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "*@@integer"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == "/")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, "/@@integer"), 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basename == ";")
	{
		AddBinaryPossibility(possibilities, FindString(GlobalStrings, ";"), 0x02000000, 0x02000000, 0x02000000)
	}
	else
	{
		print("Unrecognized operator")
		assert(false)
	}
}


GetExpectedParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(Functions, funcname, paramindex, paramcount, toplevel, types)
	
	EnumerateOverloadsAndAddParameterTypes(Overloads, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : list<Overload> ref overloads, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(overloads.value.NormalName == funcname)
	{
		FindFunctionAndAddParameterTypes(Functions, overloads.value.MangledName, paramindex, paramcount, toplevel, types)
	}
	
	EnumerateOverloadsAndAddParameterTypes(overloads.next, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types


FindFunctionAndAddParameterTypes : list<FunctionDefinition> ref functions, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(functions.value.Name == funcname)
	{
		if(!functions.value.InferenceDone)
		{
			simplelist<integer> temp = 0, nothing
			InferenceContext context = 0, 0, temp, false, 0, false
			
			TypeInference(functions.value, context)
		}
		
		UnwrapParamsForTypeRetrieval(functions.value.Params, paramindex, paramcount, types)
	}
	else
	{
		FindFunctionAndAddParameterTypes(functions.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindFunctionAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(StructureConstructorExists(Structures, funcname))
	{
		FindConstructorAndAddParameterTypes(Structures, funcname, paramindex, paramcount, toplevel, types)
	}
	else
	{
		FindBuiltinAndAddParameterTypes(funcname, paramindex, paramcount, types)
	}
}

UnwrapParamsForTypeRetrieval : FunctionParams ref params, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveParamType(params.Params, paramindex, types)
	}
}

UnwrapParamsForTypeRetrieval : nothing, integer paramindex, integer paramcount, simplelist<integer> ref types


RetrieveParamType : list<UnresolvedParameter> ref params, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{	
		simpleprepend<integer>(types, params.value.ResolvedType)
		return()
	}
	
	RetrieveParamType(params.next, paramindex - 1, types)
}

RetrieveParamType : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many parameters to call!")
	assert(false)
}


GetFunctionReturnType : list<FunctionDefinition> ref functions, integer funcname -> integer rettype = 0
{
	if(functions.value.Name == funcname)
	{
		if(!functions.value.InferenceDone)
		{
			simplelist<integer> temp = 0, nothing
			InferenceContext context = 0, 0, temp, false, 0, false

			TypeInference(functions.value, context)
		}

		rettype = GetOptionalExpressionType(functions.value.Return)
	}
	else
	{
		rettype = GetFunctionReturnType(functions.next, funcname)
	}
}

GetFunctionReturnType : nothing, integer funcname -> integer rettype = GetPendingTypeMatcherReturnType(PendingTypeMatchers, funcname)


GetOptionalExpressionType : Expression ref expr -> expr.Type
GetOptionalExpressionType : nothing -> 0


FindBuiltinAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	integer ctype = GetTypeByName(funcname)
	if((ctype & 0xff000000) == 0x05000000)
	{
		funcname = GetNameOfType(FindTypeAliasBase(TypeAliases, ctype))
	}

	if((ctype & 0xff000000) == 0x07000000)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				FindSumTypeAndPrependTypesToList(SumTypes, ctype, types)
			}
		}
		return()
	}

	string readablename = GetPooledString(GlobalStrings, funcname)
	if(readablename == "passtest")
	{
		// No parameters
	}
	elseif(readablename == "assert")
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(readablename == "integer")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(readablename == "integer16")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(readablename == "boolean")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(readablename == "real")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(readablename == "string")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(readablename == "buffer")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(readablename == "narrowstring")
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(readablename == "substring@@withlength")
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(readablename == "substring@@nolength")
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
}


simpleprependall<type T> : simplelist<T> ref input, simplelist<T> ref newentries
{
	simpleprepend<T>(input, newentries.value)
	simpleprependall<T>(input, newentries.next)
}

simpleprependall<type T> : simplelist<T> ref input, nothing


FindSumTypeAndPrependTypesToList : list<SumType> ref sumtypes, integer sumtypeid, simplelist<integer> ref types
{
	if(sumtypes.value.Type == sumtypeid)
	{
		simpleprependall<integer>(types, sumtypes.value.Bases)
	}
	else
	{
		FindSumTypeAndPrependTypesToList(sumtypes.next, sumtypeid, types)
	}
}


FindConstructorAndAddParameterTypes : list<StructureDefinition> ref structures, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	integer membercount = CountMembers(structures.value.Members)

	if((structures.value.ConstructorName == funcname) && (paramcount == membercount + 1))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		else
		{
			FindMemberAndAddParameterTypes(structures.value.Members, paramindex - 1, types)
		}
	}
	elseif((structures.value.AnonConstructorName == funcname) && (paramcount == membercount))
	{
		FindMemberAndAddParameterTypes(structures.value.Members, paramindex, types)
	}
	elseif((toplevel) && (structures.value.CopyConstructorName == funcname) && (paramcount == 2))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		elseif(paramindex == 1)
		{
			simpleprepend<integer>(types, structures.value.Type)
		}
	}
	else
	{
		FindConstructorAndAddParameterTypes(structures.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindConstructorAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types


FindMemberAndAddParameterTypes : list<StructureMember> ref members, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{
		AddParameterTypesForMember(members.value, types)
	}
	else
	{
		FindMemberAndAddParameterTypes(members.next, paramindex - 1, types)
	}
}

FindMemberAndAddParameterTypes : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many arguments to constructor")
	assert(false)
}


AddParameterTypesForMember : StructureMemberVariable ref memvar, simplelist<integer> ref types
{
	simpleprepend<integer>(types, memvar.Type)
}

AddParameterTypesForMember : StructureMemberFunctionRef ref memfunc, simplelist<integer> ref types
{
	simpleprepend<integer>(types, 0x09000000)
}


GetConstructorName : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.ConstructorName
	}
	else
	{
		name = GetConstructorName(structures.next, typeid)
	}
}


StructureConstructorExists : list<StructureDefinition> ref structures, integer ctorname -> boolean exists = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		exists = true
	}
	else
	{
		exists = StructureConstructorExists(structures.next, ctorname)
	}
}

StructureConstructorExists : nothing, integer ctorname -> false


CoalesceMemberAccesses : list<ExpressionAtom> ref atoms, integer scopename
{
	while(SearchForMemberAccessStart(atoms, atoms.next, scopename))
	{
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, list<ExpressionAtom> ref current, integer scopename -> boolean found = false
{
	if(IsMemberAccessOperator(current.value))
	{
		CoalesceMemberAccessTriplet(previous, current, current.next, scopename)
		found = true
	}
	else
	{
		found = SearchForMemberAccessStart(current, current.next, scopename)
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, nothing, integer scopename -> false


CoalesceMemberAccessTriplet : list<ExpressionAtom> ref lhs, list<ExpressionAtom> ref op, list<ExpressionAtom> ref rhs, integer scopename
{
	CoalesceMemberAccessAtoms(lhs, lhs.value, rhs.value, scopename)
	lhs.next = rhs.next
}

CoalesceMemberAccessAtoms : list<ExpressionAtom> ref lhslist, ExpressionAtom ref lhs, ExpressionAtom ref rhs, integer scopename
{
	CoalesceMemberAccessAtomsUnwrapped(lhslist, lhs, rhs, scopename)
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, IdentifierAtom ref lhs, IdentifierAtom ref rhs, integer scopename
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInScope(scopename, lhs.Handle, var)
	
	integer lhstypename = GetNameOfType(var.VarType)
	
	integer rhstype = GetStructureMemberType(Structures, lhstypename, rhs.Handle)
	integer rhstypename = GetNameOfType(rhstype)

	RefBinding lhsbinding = lhs.Handle, lhstypename, false, false
	RefBinding rhsbinding = rhs.Handle, rhstypename, false, false

	list<RefBinding> bindings = rhsbinding, nothing
	prepend<RefBinding>(bindings, lhsbinding)
	
	CompoundAtom compound = bindings, rhstype
	ExpressionAtom wrap = compound
	lhslist.value = wrap
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, CompoundAtom ref lhs, IdentifierAtom ref rhs, integer scopename
{
	integer typename = GetNameOfType(lhs.Type)
	
	RefBinding temp = rhs.Handle, typename, false, false
	AppendBinding(lhs.Bindings, lhs.Bindings.next, temp)

	lhs.Type = GetStructureMemberType(Structures, typename, rhs.Handle)
}

AppendBinding : list<RefBinding> ref bindings, list<RefBinding> ref tail, RefBinding ref binding
{
	AppendBinding(tail, tail.next, binding)
}

AppendBinding : list<RefBinding> ref bindings, nothing, RefBinding ref binding
{
	list<RefBinding> newtail = binding, nothing
	bindings.next = newtail
}


FindOrCreateTypeMatcher : integer rawname, integer overloadnamehandle -> integer matcherhandle = 0
{
	string matchername = GetPooledString(GlobalStrings, rawname) ; "@@typematcher"
	matcherhandle = PoolString(matchername)
	
	EnsureMatcherIsPending(PendingTypeMatchers, overloadnamehandle, matcherhandle)
}

EnsureMatcherIsPending : list<PendingTypeMatcher> ref pending, integer overloadname, integer matcher
{
	if(pending.value.OverloadName != overloadname)
	{
		EnsureMatcherIsPending(pending.next, overloadname, matcher)
	}
}

EnsureMatcherIsPending : nothing, integer overloadname, integer matcher
{
	PendingTypeMatcher m = overloadname, matcher
	prepend<PendingTypeMatcher>(PendingTypeMatchers, m)
}


IsPendingTypeMatcher : list<PendingTypeMatcher> ref pending, integer matchername -> boolean exists = false
{
	if(pending.value.MatcherName == matchername)
	{
		exists = true
	}
	else
	{
		exists = IsPendingTypeMatcher(pending.next, matchername)
	}
}

IsPendingTypeMatcher : nothing, integer matchername -> false


GetPendingTypeMatcherReturnType : list<PendingTypeMatcher> ref pending, integer matchername -> integer rettype = 0
{
	if(pending.value.MatcherName == matchername)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = GetFunctionReturnType(Functions, pending.value.OverloadName)
		return()
	}
	
	rettype = GetPendingTypeMatcherReturnType(pending.next, matchername)
}

GetPendingTypeMatcherReturnType : nothing, integer matchername -> integer typeid = GetBuiltInReturnType(matchername)



GetBuiltInReturnType : integer builtinname -> integer returntype = 0
{
	if(StructureConstructorExists(Structures, builtinname))
	{
		returntype = GetStructureByAnonConstructorName(Structures, builtinname)
		return()
	}

	string readablename = GetPooledString(GlobalStrings, builtinname)
	
	if(readablename == "narrowstring")
	{
		returntype = 0x02000001		// buffer type signature
	}
	elseif(readablename == "substring@@withlength")
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(readablename == "substring@@nolength")
	{
		returntype = 0x02000000		// string type signature
	}
}


InsertAnnotationsForTypeMatchedParams : list<FunctionDefinition> ref functions, integer overloadname, OptionalExpressionList ref paramexprs
{
	InsertAnnotationsForTypeMatchedParamsUnwrapper(functions, overloadname, paramexprs)
}

InsertAnnotationsForTypeMatchedParamsUnwrapper : list<FunctionDefinition> ref functions, integer overloadname, ExpressionList ref paramexprs
{
	InsertAnnotationsForTypeMatchedParamsUnwrap(functions, overloadname, paramexprs.Expressions)
}

InsertAnnotationsForTypeMatchedParamsUnwrap : list<FunctionDefinition> ref functions, integer overloadname, list<Expression> ref paramexprs
{
	if(functions.value.Name == overloadname)
	{
		AnnotateTypeMatchedParams(functions.value.Params, paramexprs)
	}
	else
	{
		InsertAnnotationsForTypeMatchedParamsUnwrap(functions.next, overloadname, paramexprs)
	}
}

InsertAnnotationsForTypeMatchedParamsUnwrap : nothing, integer overloadname, list<Expression> ref paramexprs
{
	FindConstructorAndAnnotateTypeMatchedParams(Structures, overloadname, paramexprs)
}

FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, list<Expression> ref paramexprs
{
	if(structures.value.ConstructorName == funcname)
	{
		listnode<Expression> ne = paramexprs.next
		AnnotateTypeMatchedParamsFromConstructor(structures.value.Members, ne)
	}
	else
	{
		FindConstructorAndAnnotateTypeMatchedParams(structures.next, funcname, paramexprs)
	}
}

FindConstructorAndAnnotateTypeMatchedParams : nothing, integer funcname, list<Expression> ref paramexprs
{
	if((GetTypeByName(funcname) & 0x7f000000) == 0x07000000)
	{
		AnnotateNonReferenceParameters(paramexprs.next)
	}
}


AnnotateTypeMatchedParamsFromConstructor : list<StructureMember> ref members, list<Expression> ref paramexprs
{
	integer membertype = GetMemberTypeDecompose(members.value)
	if((membertype & 0x7f000000) == 0x07000000)
	{
		if(paramexprs.value.Type != membertype)
		{
			AddTypeAnnotation(paramexprs.value)
		}
	}
	
	listnode<StructureMember> nm = members.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParamsFromConstructor(nm, ne)
}

AnnotateTypeMatchedParamsFromConstructor : nothing, nothing


AnnotateTypeMatchedParams : FunctionParams ref params, list<Expression> ref paramexprs
{
	AnnotateTypeMatchedParams(params.Params, paramexprs)
}

AnnotateTypeMatchedParams : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	if((params.value.ResolvedType & 0x7f000000) == 0x07000000)
	{
		//if(paramexprs.value.Type != params.value.ResolvedType)
		//{
			AddTypeAnnotation(paramexprs.value)
		//}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParams(np, ne)
}

AnnotateTypeMatchedParams : nothing, nothing

MakeParametersReferences : list<FunctionDefinition> ref functions, integer overloadname, OptionalExpressionList ref exprs
{
	MakeParametersReferencesUnwrap(functions, overloadname, exprs)
}

MakeParametersReferencesUnwrap : list<FunctionDefinition> ref functions, integer overloadname, nothing

MakeParametersReferencesUnwrap : list<FunctionDefinition> ref functions, integer overloadname, ExpressionList ref params
{
	if(functions.value.Name == overloadname)
	{
		WalkFunctionParamsAndSetReferences(functions.value.Params, params)
	}
	else
	{
		MakeParametersReferencesUnwrap(functions.next, overloadname, params)
	}
}

MakeParametersReferencesUnwrap : nothing, integer overloadname, ExpressionList ref params
{
	MakeParametersReferencesForTypeMatcher(PendingTypeMatchers, overloadname, params)
}

MakeParametersReferencesForTypeMatcher : list<PendingTypeMatcher> ref pending, integer matchername, ExpressionList ref params
{
	if(pending.value.MatcherName == matchername)
	{
		MakeParametersReferencesUnwrap(Functions, pending.value.OverloadName, params)
	}
	
	MakeParametersReferencesForTypeMatcher(pending.next, matchername, params)
}

MakeParametersReferencesForTypeMatcher : nothing, integer matchername, ExpressionList ref params
{
	MakeParametersReferencesForConstructor(Structures, matchername, params)
}


MakeParametersReferencesForConstructor : list<StructureDefinition> ref structures, integer constructorname, ExpressionList ref params
{
	if(structures.value.ConstructorName == constructorname)
	{
		MakeParametersReferencesForStructureMembers(structures.value.Members, params.Expressions.next)
	}
	else
	{
		MakeParametersReferencesForConstructor(structures.next, constructorname, params)
	}
}


MakeParametersReferencesForConstructor : nothing, integer constructorname, ExpressionList ref params


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, list<Expression> ref params
{
	if(IsMemberReferenceType(members.value))
	{
		if(!MarkAtomAsReference(params.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	
	MakeParametersReferencesForStructureMembers(members.next, params.next)
}

MakeParametersReferencesForStructureMembers : nothing, nothing



IsMemberReferenceType : StructureMemberVariable ref memvar -> boolean isref = IsReferenceType(memvar.Type)
IsMemberReferenceType : StructureMemberFunctionRef ref memfunc -> false



WalkFunctionParamsAndSetReferences : nothing, ExpressionList ref paramexprs

WalkFunctionParamsAndSetReferences : FunctionParams ref params, ExpressionList ref paramexprs
{
	WalkFunctionParamsAndSetReferencesUnwrapped(params.Params, paramexprs.Expressions)
}


WalkFunctionParamsAndSetReferencesUnwrapped : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	if(IsReferenceType(params.value.ResolvedType))
	{
		if(!MarkAtomAsReference(paramexprs.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	WalkFunctionParamsAndSetReferencesUnwrapped(np, ne)
}

WalkFunctionParamsAndSetReferencesUnwrapped : nothing, nothing


DemoteAtomType : list<ExpressionAtom> ref atoms
{
	PerformDemotion(atoms, atoms.value)
}

PerformDemotion : list<ExpressionAtom> ref atoms, integer ref atom
{
	integer16 newatom = cast(integer16, atom)
	ExpressionAtom wrap = newatom
	atoms.value = wrap
}

PerformDemotion : list<ExpressionAtom> ref atoms, IdentifierAtom ref atom


DumpOverloadList : list<InferencePossibility> ref possibilities
{
	if(possibilities.value.FunctionName != 0)
	{
		print(GetPooledString(GlobalStrings, possibilities.value.FunctionName))
	}
	
	DumpOverloadList(possibilities.next)
}

DumpOverloadList : nothing



FilterOverloadsForTypeDemotion : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false
	
	CheckIfContainsOnlyDemotedOverloads(in, hasdemoted, hassuperior, hasother)
	
	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedOverloads(in, out)
	}
	else
	{
		out = in
	}
}


FilterTypesForDemotion : simplelist<integer> ref in, simplelist<integer> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false
	
	CheckIfContainsOnlyDemotedTypes(in, hasdemoted, hassuperior, hasother)
	
	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedTypes(in, out)
	}
	else
	{
		out = in
	}	
}


CheckIfContainsOnlyDemotedOverloads : list<InferencePossibility> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother
{
	if(in.value.ParameterTypes.value.Types.value == 0x01000001)
	{
		hassuperior = true
	}
	elseif(in.value.ParameterTypes.value.Types.value == 0x01000002)
	{
		hasdemoted = true
	}
	elseif(in.value.ParameterTypes.value.Types.value == 0)
	{
	}
	else
	{
		hasother = true
	}
	
	CheckIfContainsOnlyDemotedOverloads(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedOverloads : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother


StripDemotedOverloads : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value != 0x01000002)
		{
			prepend<InferencePossibility>(out, in.value)
		}
	}
	
	StripDemotedOverloads(in.next, out)
}

StripDemotedOverloads : nothing, list<InferencePossibility> ref out



CheckIfContainsOnlyDemotedTypes : simplelist<integer> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother
{
	if(in.value == 0x01000001)
	{
		hassuperior = true
	}
	elseif(in.value == 0x01000002)
	{
		hasdemoted = true
	}
	elseif(in.value == 0)
	{
	}
	else
	{
		hasother = true
	}
	
	CheckIfContainsOnlyDemotedTypes(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedTypes : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother


StripDemotedTypes : simplelist<integer> ref in, simplelist<integer> ref out
{
	if(in.value != 0)
	{
		if(in.value != 0x01000002)
		{
			simpleprepend<integer>(out, in.value)
		}
	}
	
	StripDemotedTypes(in.next, out)
}

StripDemotedTypes : nothing, simplelist<integer> ref out


InitBuiltInOverloads :
{
	Overload substrlength = PoolString("substring"), PoolString("substring@@withlength")
	prepend<Overload>(Overloads, substrlength)

	Overload substrnolen = PoolString("substring"), PoolString("substring@@nolength")
	prepend<Overload>(Overloads, substrnolen)
}



CheckMemberTypes : list<StructureMember> ref members, simplelist<integer> ref types -> boolean match = true
{
	integer membertype = GetMemberTypeDecompose(members.value)
	integer curtype = types.value

	if(membertype == curtype)
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	elseif(SumTypeHasBase(SumTypes, membertype, MakeNonReferenceType(curtype)))
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	else
	{
		match = false
	}
}

CheckMemberTypes : nothing, nothing -> true

CheckMemberTypes : list<StructureMember> ref members, nothing -> false

CheckMemberTypes : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}


GetStructureByAnonConstructorName : nothing, integer name -> 0

GetStructureByAnonConstructorName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0
{
	if(structures.value.AnonConstructorName == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureByAnonConstructorName(structures.next, name)
	}
}


stringcontains : string haystack, string needle -> boolean contains = false
{
	integer needlelen = length(needle)
	integer haystacklen = length(haystack)
	
	integer index = 0
	while(index < (haystacklen - needlelen))
	{
		if(substring(haystack, index, needlelen) == needle)
		{
			contains = true
			return()
		}
		
		++index
	}
}


PrependFunctionParameter : list<FunctionDefinition> ref functions, integer funcname, integer paramname, integer paramtype
{
	if(functions.value.Name == funcname)
	{
		UnresolvedParameter p = paramname, GetNameOfType(paramtype), paramtype, IsReferenceType(paramtype)
		PrependUnresolvedParameter(functions.value.Params, p)
	}
	else
	{
		PrependFunctionParameter(functions.next, funcname, paramname, paramtype)
	}
}

PrependUnresolvedParameter : FunctionParams ref params, UnresolvedParameter ref p
{
	PrependUnresolvedParameter(params.Params, p)
}

PrependUnresolvedParameter : list<UnresolvedParameter> ref thelist, UnresolvedParameter ref p
{
	prepend<UnresolvedParameter>(thelist, p)
}

PrependUnresolvedParameter : nothing, UnresolvedParameter ref p
{
	print("Cannot set constructor tag on function with no parameters")
	assert(false)
}


//
// Global state (just a hack while we bootstrap!)
//

global
{
	buffer Hack = 8192000
	integer HackSize = 0

	list<StringTableEntry> GlobalStrings = StringTableEntry(0, ""), nothing

	Variable dummyvar = 0, 0, 0, 0
	list<Variable> dummyvarlist = dummyvar, nothing
	Scope dummyscope = 0, 0, dummyvarlist, 0, 0
	list<Scope> Scopes = dummyscope, nothing
	
	Overload dummyoverload = 0, 0
	list<Overload> Overloads = dummyoverload, nothing

	FunctionDefinition dummyfunc = 0, nothing, nothing, false, 0, nothing, false
	list<FunctionDefinition> Functions = dummyfunc, nothing


	simplelist<integer> dummybases = 0, nothing
	SumType dummysumtype = 0, 0, dummybases
	list<SumType> SumTypes = dummysumtype, nothing


	StructureMemberVariable dummymember = 0, 0, 0
	list<StructureMember> dummymembers = dummymember, nothing
	StructureDefinition dummystruct = 0, 0, 0, 0, 0, dummymembers
	list<StructureDefinition> Structures = dummystruct, nothing


	// TODO - convert to an enumeration
	integer STACK_TYPE_GLOBAL = 0
	integer STACK_TYPE_FUNCTION = 1
	integer STACK_TYPE_CODEBLOCK = 2
	integer STACK_TYPE_STATEMENT = 3
	integer STACK_TYPE_ASSIGNMENT = 4
	integer STACK_TYPE_TYPEMATCH = 5
	integer STACK_TYPE_SUBSTATEMENT = 6
	integer STACK_TYPE_FUNCRET = 7
	integer STACK_TYPE_ENTITY_PARAM = 8
	integer STACK_TYPE_ENTITY_CODE = 9
	integer STACK_TYPE_CHAIN = 10
	integer STACK_TYPE_PARENTHETICAL = 11

	ContextStackEntry GlobalStackEntry = STACK_TYPE_GLOBAL, 0
	list<ContextStackEntry> ContextStack = GlobalStackEntry, nothing

	AtomSentinel dummysentinel = 0
	list<ExpressionAtom> dummyatomlist = dummysentinel, nothing
	Expression dummyexpression = dummyatomlist, 0
	list<Expression> ScratchExpressions = dummyexpression, nothing
	Statement dummystatement = 0, nothing, 0, false
	list<Statement> SubStatements = dummystatement, nothing

	Parameter dummyparam = 0, 0
	list<Parameter> dummyparamlist = dummyparam, nothing
	FunctionSignature dummysignature = 0, dummyparamlist, 0
	list<FunctionSignature> dummysignaturelist = dummysignature, nothing
	TypeMatcher dummytypematch = 0, dummysignaturelist
	list<TypeMatcher> TypeMatchers = dummytypematch, nothing

	Entity dummyentity = 0, 0, nothing, nothing
	list<Entity> EntityStack = dummyentity, nothing


	list<string> dummytagparams = "", nothing
	FunctionTag dummytag = 0, "", dummytagparams
	list<FunctionTag> FunctionTags = dummytag, nothing

	integer EmittingFunctionName = 0

	list<OptionalCodeBlock> CurrentCodeBlockStack = nothing, nothing

	list<CodeBlockEntry> dummyblockentries = dummystatement, nothing
	CodeBlock GlobalCodeBlock = dummyblockentries
	integer GlobalCodeBlockName = 0

	list<Entity> chaincontents = dummyentity, nothing
	OptionalEntityList chaincontentswrap = chaincontents
	EntityChain dummychain = chaincontentswrap
	list<EntityChain> ChainStack = dummychain, nothing


	simplelist<integer> AutoGeneratedFunctionNames = 0, nothing
	simplelist<integer> CustomConstructors = 0, nothing

	TypeAlias dummyalias = 0, 0, 0
	list<TypeAlias> TypeAliases = dummyalias, nothing
	
	TypeAlias dummyweak = 0, 0, 0
	list<TypeAlias> TypeWeakAliases = dummyweak, nothing

	list<FunctionSignature> FunctionSignatures = dummysignature, nothing

	boolean InFuncRetHack = false

	integer CurrentStringHandle = 0

	simplelist<integer> scratchpossibletypes = 0, nothing
	TypePossibilityList scratchreturns = scratchpossibletypes, false
	TypePossibilityList scratchparams = scratchpossibletypes, false
	list<TypePossibilityList> scratchparampossibles = scratchparams, nothing
	InferencePossibility scratchpossibility = 0, scratchparampossibles, scratchreturns

	integer IRExpressionDepth = 0
	
	PendingTypeMatcher dummypending = 0, 0
	list<PendingTypeMatcher> PendingTypeMatchers = dummypending, nothing

	simplelist<string> TokenStream = "", nothing

	integer CHARACTER_CLASS_WHITE = 0
	integer CHARACTER_CLASS_IDENTIFIER = 1
	integer CHARACTER_CLASS_PUNCTUATION = 2
	integer CHARACTER_CLASS_COMMENT = 3
	integer CHARACTER_CLASS_PUNCTUATION_COMPOUND = 4
	integer CHARACTER_CLASS_STRING_LITERAL = 5
	integer CHARACTER_CLASS_LITERAL = 6
	
	integer GlobalStructureCounter = 0x03000000
	integer GlobalWeakAliasCounter = 0x04000000
	integer GlobalAliasCounter = 0x05000000
	integer GlobalSumTypeCounter = 0x07000000
}


