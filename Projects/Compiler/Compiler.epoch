//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//

CloseHandle : integer handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]
CreateFile : string filename, integer access, integer sharemode, integer attributes, integer creation, integer flags, integer template -> integer ret = 0 [external("Kernel32.dll", "CreateFileW", "stdcall")]
CreateFileMapping : integer filehandle, integer attributes, integer protection, integer maxsizehigh, integer maxsizelow, integer name -> integer ret = 0 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
MapViewOfFile : integer handle, integer access, integer offsethigh, integer offsetlow, integer bytestomap -> integer ptr = 0 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]
UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]
GetFileSize : integer handle, integer ignored -> integer size = 0 [external("Kernel32.dll", "GetFileSize", "stdcall")]
SetCurrentDirectory : string path -> boolean success = false [external("Kernel32.dll", "SetCurrentDirectoryW", "stdcall")]

timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime", "stdcall")]

ExecuteByteCodeBuffer : buffer ref code, integer len [external("EpochRuntime.dll", "ExecuteByteCodeDeferred", "stdcall")]


entrypoint :
{
	print("Epoch Language Project")
	print("Command line compiler and tools interface")
	print("")

	if(cmdlineisvalid() && (cmdlinegetcount() > 1))
	{
		boolean makeproject = false

		string filename = cmdlineget(1)
		if((length(filename) > 5) && (substring(filename, length(filename) - 5) == ".eprj"))
		{
			makeproject = true
		}
		else
		{
			print("Executing: " ; filename)
			print("")
		}

		PrepareStringTable()
		InitBuiltInOverloads()

		if(makeproject)
		{
			ChangeToPath(filename)
			CompileProject(filename)
		}
		else
		{
			if(CompileFile(filename))
			{
				ExecuteByteCodeBuffer(Hack, HackSize)		
			}
		}
	}
	else
	{
		print("Please specify a program to execute!")
	}
}


ChangeToPath : string filename
{
	if(!stringcontains(filename, "\"))
	{
		return()
	}
	
	integer pos = length(filename) - 1
	while(charat(filename, pos) != "\")
	{
		--pos
	}
	
	string path = substring(filename, 0, pos)
	SetCurrentDirectory(path)
}


CompileProject : string filename
{
	string outputfilename = "project.exe"

	integer len = 0
	string contents = ReadFile(filename, len)

	if(len == 0)
	{
		return()
	}

	string sectionline = ExtractLine(contents)
	if(sectionline != "[source]")
	{
		print("Malformed project file!")
		return()
	}

	boolean parseok = true
	boolean haslines = true
	while(haslines)
	{
		string line = ExtractLine(contents)
		if(line == "")
		{
			haslines = false
		}
		else
		{
			print(line)
			if(!ParseFile(line))
			{
				parseok = false
			}
		}
	}
	
	if(!parseok)
	{
		return()
	}

	sectionline = ExtractLine(contents)
	if(sectionline != "[output]")
	{
		print("Malformed project file!")
		return()
	}

	haslines = true
	while(haslines)
	{
		string line = ExtractLine(contents)
		if(line == "")
		{
			haslines = false
		}
		else
		{
			string directive = ""
			string parameter = ""
			SplitProjectDirective(line, directive, parameter)
			
			if(directive == "output-file")
			{
				outputfilename = parameter
			}
			else
			{
				print("Unrecognized [output] directive!")
				return()
			}
		}
	}

	print("Performing semantic analysis...")
	boolean irok = IRProcess()
	if(!irok)
	{
		return()
	}

	print("Generating code...")
	OnCodeGenProcessProgram()
	
	print("Writing executable file...")
	MakeExe(outputfilename)
}


SplitProjectDirective : string line, string ref directive, string ref parameter
{
	integer pos = 0
	while(charat(line, pos) != " ")
	{
		++pos
	}
	
	directive = substring(line, 0, pos)
	parameter = substring(line, pos + 1)
}


ParseFile : string filename -> boolean success = false
{
	integer len = 0
	string contents = ReadFile(filename, len)

	if(len == 0)
	{
		return()
	}
	
	success = Parse(contents, len)
}


CompileFile : string filename -> boolean success = false
{
	integer len = 0
	string contents = ReadFile(filename, len)

	if(len == 0)
	{
		return()
	}

	integer startparsems = timeGetTime()
	boolean parseok = Parse(contents, len)
	integer durationparsems = timeGetTime() - startparsems

	print("Parsing completed in " ; cast(string, durationparsems) ; " milliseconds")
	if(!parseok)
	{
		return()
	}

	integer startprocessms = timeGetTime()
	boolean irok = IRProcess()
	integer durationprocessms = timeGetTime() - startprocessms

	print("Semantic analysis completed in " ; cast(string, durationprocessms) ; " milliseconds")
	if(!irok)
	{
		return()
	}

	integer startcodegenms = timeGetTime()
	OnCodeGenProcessProgram()
	integer durationcodegenms = timeGetTime() - startcodegenms

	print("Code generation completed in " ; cast(string, durationcodegenms) ; " milliseconds")
	print("")

	success = true
}


ExtractLine : string ref contents -> string line = ""
{
	if(length(contents) == 0)
	{
		return()
	}

	integer pos = 0
	while(charat(contents, pos) != unescape("\r"))
	{
		++pos
	}
		
	line = substring(contents, 0, pos)
	
	pos += 2
	contents = substring(contents, pos)
}


ReadFile : string filename, integer ref len -> string contents = ""
{
	integer INVALID_HANDLE_VALUE = 0xffffffff
	integer FILE_SHARE_READ = 0x01
	integer OPEN_EXISTING = 3
	integer GENERIC_READ = 0x80000000

	integer filehandle = CreateFile(filename, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0)
	if(filehandle != INVALID_HANDLE_VALUE)
	{
		integer PAGE_READONLY = 0x02

		len = GetFileSize(filehandle, 0)

		if(len > 0)
		{
			integer mappinghandle = CreateFileMapping(filehandle, 0, PAGE_READONLY, 0, 0, 0)
			if(mappinghandle != 0)
			{
				integer FILE_MAP_READ = 0x04
				integer ptr = MapViewOfFile(mappinghandle, FILE_MAP_READ, 0, 0, len)

				if(ptr != 0)
				{
					contents = widenfromptr(ptr, len)
				}
				CloseHandle(mappinghandle)
			}
			else
			{
				print("Failed to map file!")
			}
		}
		else
		{
			contents = ""
		}
		CloseHandle(filehandle)
	}
	else
	{
		print("Couldn't open that file!")
	}
}



// TODO - replace with better option
charat : string in, integer index -> string c = substring(in, index, 1) [nogc]



TypeListContains : simplelist<integer> ref thelist, integer value -> integer ret = 0 [nogc]
{
	integer listval = thelist.value
	if((listval & 0x7f000000) == 0x05000000)
	{
		listval = FindTypeAliasBase(TypeAliases, listval)
	}

	if(listval == value)
	{
		ret = listval
		return()
	}
	elseif(MakeNonReferenceType(listval) == value)
	{
		ret = listval
		return()
	}
	elseif(listval == MakeNonReferenceType(value))
	{
		ret = listval
		return()
	}

	if((value & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(value) == MakeNonReferenceType(listval))
		{
			ret = value
			return()
		}

		if(SumTypeHasBase(SumTypes, MakeNonReferenceType(value), MakeNonReferenceType(listval)))
		{
			ret = value
			return()
		}
	}

	if((listval & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(value) == MakeNonReferenceType(listval))
		{
			ret = value
			return()
		}

		if(SumTypeHasBase(SumTypes, listval, MakeNonReferenceType(value)))
		{
			ret = value
			return()
		}
	}

	ret = TypeListContains(thelist.next, value)
}

TypeListContains : nothing, integer value -> 0



//
// Callback invoked when the code generation process can begin
//

OnCodeGenProcessProgram :
{
	GenerateTypeMatcherMappings(Functions)
	GeneratePendingTypeMatchers(PendingTypeMatchers)

	CodeGenEmitStrings(GlobalStrings)
	CodeGenEmitSumTypes(SumTypes)
	CodeGenRearrangeStructures(Structures)
	CodeGenEmitStructures(Structures)
	CodeGenEmitFunctionSignatures(FunctionSignatures)

	if(GlobalCodeBlockName != 0)
	{
		CodeGenEmitSpecificScope(GlobalScope.Wrapped)
	}

	CodeGenEmitScopes(Scopes)
	CodeGenEmitFunctionTags(FunctionTags)
	CodeGenEmitGlobalBlockPrologue(GlobalCodeBlock)
	CodeGenEmitFunctions(Functions)
	CodeGenEmitGlobalBlockEpilogue(GlobalCodeBlock)
	CodeGenEmitTypeMatchers(TypeMatchers)
	CodeGenEmitPatternMatchers(PendingPatternMatchers)
	CodeGenEmitConstructors(Structures)
}

OnCodeGenRegisterString : integer handle, string data [nogc]
{
	StringTableEntry entry = handle, data
	prepend<StringTableEntry>(GlobalStrings, entry)

	PlaceDataInTrie(GlobalStringTrie, data, handle)

	if(handle > CurrentStringHandle)
	{
		CurrentStringHandle = handle
	}
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer typenamehandle, boolean isref, boolean templated [nogc]
{
	integer refnum = 0
	if(isref)
	{
		refnum = 0x80000000
	}

	StructureMemberVariable member = membername, refnum, typenamehandle, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		member.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettypename [nogc]
{
	list<Parameter> p = dummyparam, nothing
	FunctionSignature signature = name, p, rettypename
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype
{
	Parameter param = 1, paramtype
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, simplelist<integer> ref typenames
{
	OnCodeGenRegisterStructureMemFuncSigParamList(structurename, structuretype, membername, typenames.next)

	if(typenames.value != 0)
	{
		OnCodeGenRegisterStructureMemFuncSigParam(structurename, structuretype, membername, typenames.value)
	}
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, nothing



FindStructureAndAddMember : list<StructureDefinition> ref structures, integer structurename, integer structuretype, StructureMember ref member [nogc]
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMember(structures.value.Members, structures.value.Members.next, member)
		structures.value.MemberCount = structures.value.MemberCount + 1
	}
	else
	{
		FindStructureAndAddMember(structures.next, structurename, structuretype, member)
	}
}

FindStructureAndAddMember : nothing, integer structurename, integer structuretype, StructureMember ref member [nogc]
{
	list<StructureMember> members = member, nothing
	StructureDefinition def = structurename, structuretype, 0, 0, 0, members, 1, GetPooledString(GlobalStrings, structurename), false

	prepend<StructureDefinition>(Structures, def)
	InsertIntoBinaryTree<StructureDefinition>(StructuresWhichExist, structurename, def)
}

AppendStructureMember : list<StructureMember> ref members, list<StructureMember> ref tail, StructureMember ref member [nogc]
{
	AppendStructureMember(tail, tail.next, member)
}

AppendStructureMember : list<StructureMember> ref members, nothing, StructureMember ref member [nogc]
{
	list<StructureMember> newtail = member, nothing
	members.next = newtail
}


FindStructureAndAddMemberParam : list<StructureDefinition> ref structures, integer structurename, integer structuretype, integer membername, Parameter ref param
{
	if(structures.value.Name == structurename)
	{
		AppendStructureMemberParam(structures.value.Members, membername, param)
	}
	else
	{
		FindStructureAndAddMemberParam(structures.next, structurename, structuretype, membername, param)
	}
}

AppendStructureMemberParam : list<StructureMember> ref members, integer membername, Parameter ref param
{
	boolean match = CheckMemberForAddingParam(members.value, membername, param)
	if(!match)
	{
		AppendStructureMemberParam(members.next, membername, param)
	}
}

CheckMemberForAddingParam : StructureMemberVariable ref member, integer membername, Parameter ref param -> false

CheckMemberForAddingParam : StructureMemberFunctionRef ref member, integer membername, Parameter ref param -> boolean ret = false
{
	if(member.Name == membername)
	{
		AppendParameter(member.Signature.Parameters, param)
		ret = true
	}
}



OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname [nogc]
{
	FindStructureAndSetConstructors(structurename, constructorname, anonname, copyname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, constructorname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, anonname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, copyname)
}

FindStructureAndSetConstructors : integer structurename, integer constructorname, integer anonname, integer copyname [nogc]
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, structurename, wrap)
	assert(found)

	SetConstructors(wrap, constructorname, anonname, copyname)
}

SetConstructors : StructureDefinition ref struct, integer constructorname, integer anonname, integer copyname [nogc]
{
	struct.ConstructorName = constructorname
	struct.AnonConstructorName = anonname
	struct.CopyConstructorName = copyname
}


FindSumTypeAndAddBase : list<SumType> ref sumtypes, integer sumtypename, integer sumtypeid, integer basetypeid, boolean templated [nogc]
{
	if(sumtypes.value.Type == sumtypeid)
	{
		SumTypeBase base = basetypeid, nothing

		if(templated)
		{
			PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
			TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
			base.TemplateArgs = arglist

			PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
		}

		prepend<SumTypeBase>(sumtypes.value.Bases, base)
	}
	else
	{
		FindSumTypeAndAddBase(sumtypes.next, sumtypename, sumtypeid, basetypeid, templated)
	}
}

FindSumTypeAndAddBase : nothing, integer sumtypename, integer sumtypeid, integer basetypeid, boolean templated [nogc]
{
	SumTypeBase base = basetypeid, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		TemplateArgumentList arglist = ScratchTemplateArgumentStack.value
		base.TemplateArgs = arglist

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	list<SumTypeBase> bases = base, nothing
	SumType st = sumtypename, sumtypeid, bases, false
	prepend<SumType>(SumTypes, st)
	InsertIntoBinaryTree<SumType>(SumTypesWhichExist, sumtypename, st)
}


SetUpSumTypeTemplate : list<SumType> ref sumtypes, integer sumtypeid
{
	if(sumtypes.value.Type == sumtypeid)
	{
		sumtypes.value.IsTemplate = true
		CreateSumTypeTemplateAndAttachParams(sumtypes.value.Name, TemplateParameterQueue)

		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
	else
	{
		SetUpSumTypeTemplate(sumtypes.next, sumtypeid)
	}
}

SetUpSumTypeTemplate : nothing, integer sumtypeid
{
	print("Sum type not found!")
	assert(false)
}


OnCodeGenRegisterScope : integer scopename, integer parentname
{
	list<Variable> v = dummyvar, nothing
	Scope scope = scopename, parentname, v, 0, 0
	prepend<Scope>(Scopes, scope)
}

StoreVariableInSingleScope : Scope ref scope, integer varname, integer vartype, boolean isref, integer origin
{
	integer size = 4		// TODO - actual variable sizes

	if((vartype & 0x7f000000) == 0x07000000)		// Sum type family signature
	{
		size = 8
	}
	elseif(vartype == 0x01000003)
	{
		size = 1
	}

	integer offset = -1
	if(origin == 1)			// VARIABLE_ORIGIN_PARAMETER
	{
		if(isref)
		{
			size = 8
		}

		offset = scope.ParamOffset
		scope.ParamOffset = scope.ParamOffset + size
	}
	else
	{
		offset = scope.LocalOffset
		scope.LocalOffset = scope.LocalOffset + size
	}

	Variable var = varname, vartype, origin, offset
	append(scope.Variables, var)
}

OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
}


RegisterOverloadForFunction : string rawnamestr, integer rawname -> integer mangledname = rawname
{
	ContextNode<FunctionDefinition> funcwrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, rawname, funcwrap)
	if(found)
	{
		integer existingcount = CountOverloadsForContext(funcwrap, rawname)

		if(existingcount > 0)
		{
			mangledname = PoolString(rawnamestr ; "@overload@" ; cast(string, existingcount))
		}

		Overload overload = rawname, mangledname, nothing
		AddOverloadToFunc(funcwrap, overload)
	}
}


FindFunctionAndAddOverload : Overload ref overload
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, overload.NormalName, wrap)
	if(found)
	{
		AddOverloadToFunc(wrap, overload)
	}
}

AddOverloadToFunc : FunctionDefinition ref func, Overload ref overload
{
	prepend<Overload>(func.Overloads, overload)
}


CountOverloadsForContext : FunctionDefinition ref func, integer rawname -> integer count = 0
{
	count = CountOverloads(func.Overloads, rawname)
}


CountOverloads : list<Overload> ref overloads, integer rawname -> integer count = 0
{
	if(rawname == overloads.value.NormalName)
	{
		++count
	}

	count += CountOverloads(overloads.next, rawname)
}

CountOverloads : nothing, integer rawname -> 0


AttachContextToOverload : list<Overload> ref overloads, integer mangledname, FunctionDefinition ref func
{
	if(overloads.value.MangledName == mangledname)
	{
		overloads.value.Implementation = func
	}
	else
	{
		AttachContextToOverload(overloads.next, mangledname, func)
	}
}


OnCodeGenRegisterFunction : integer funcname, integer rawfuncname, string rawfuncnamestr, boolean istemplate
{
	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = rawfuncname, funcname, nothing, nothing, nothing, dummyoverloadlist, scopewrap, rawfuncnamestr, 0, false, istemplate, false
	prepend<FunctionDefinition>(Functions, func)
	InsertIntoBinaryTree<FunctionDefinition>(FunctionsWhichExist, funcname, func)

	// TODO - this is a weird bug. For some reason we don't init the field correctly in the above constructor
	if(istemplate)
	{
		func.IsTemplate = true
	}

	if(funcname != rawfuncname)
	{	
		ContextNode<FunctionDefinition> wrap = nothing
		if(SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, rawfuncname, wrap))
		{
			AttachContextToFunction(wrap, funcname, func)
		}
	}
	
	Overload selfoverload = rawfuncname, funcname, func
	prepend<Overload>(func.Overloads, selfoverload)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	if(istemplate)
	{
		CreateFunctionTemplateAndAttachParams(funcname, TemplateParameterQueue)

		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
}


AttachContextToFunction : FunctionDefinition ref funcraw, integer mangledfuncname, FunctionDefinition ref func
{
	AttachContextToOverload(funcraw.Overloads, mangledfuncname, func)
}


IRRegisterFunctionParam : integer paramname, integer paramtypename, boolean isref, boolean templated
{
	UnresolvedParameter p = paramname, paramtypename, 0, isref, nothing, nothing

	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		p.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, FunctionParams ref params, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(params.Params, params.Params.next, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	FunctionParams fp = newlist
	OptionalParameters params = fp
	func.Params = params
}


AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, list<UnresolvedParameter> ref tail, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(tail, tail.next, p)
}

AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	thelist.next = newlist
}


OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d

	Functions.value.AnonymousReturn = anonymous
	InFuncRetHack = true
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	PopContext(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
		InFuncRetHack = false
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		assertmsg(CodeBlockDepth(CurrentCodeBlockStack) == 1, "Code block depth is invalid")
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		AppendEntityToChain(ChainStack, entity)
		PopEntityStack(EntityStack, EntityStack.next)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		CodeBlockEntry cbe = ChainStack.value
		AppendEntryToCurrentCodeBlock(cbe)
		PopChain(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		ExpressionOrPrePostOp epp = ScratchExpressions.value
		ParentheticalExpression parenthetical = epp
		ExpressionAtom atom = parenthetical
		PopExpression(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}

PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	print("No contexts available")
	assert(false)
}

PopExpression : list<Expression> ref thelist, list<Expression> ref next
{
	thelist = next
}

PopExpression : list<Expression> ref thelist, nothing



PopCodeBlock : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref next
{
	stack = next
}

PopCodeBlock : list<OptionalCodeBlock> ref stack, nothing
{
	list<OptionalCodeBlock> newlist = nothing, nothing
	stack = newlist
}


PopEntityStack : list<Entity> ref stack, list<Entity> ref next
{
	stack = next
}

PopEntityStack : list<Entity> ref stack, nothing


PopChain : list<EntityChain> ref stack, list<EntityChain> ref next
{
	stack = next
}

PopChain : list<EntityChain> ref stack, nothing



PopCurrentStatementAndAppendToScratchExpression : list<Expression> ref expressions, list<Expression> ref tail
{
	ExpressionAtom atom = SubStatements.value

	expressions = tail

	PlaceAtomInScratchExpression(atom)
	PopSubStatement(SubStatements, SubStatements.next)
}

SetReturnExpression : FunctionDefinition ref funcdef, Expression ref expr
{
	funcdef.Return = expr

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

SetGlobalCodeBlock : CodeBlock ref block
{
	GlobalCodeBlock = block
}

SetGlobalCodeBlock : nothing


PopSubStatement : list<Statement> ref statements, list<Statement> ref tail
{
	statements = tail
}

OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	list<FunctionSignature> dsl = dummysignature, nothing
	TypeMatcher matcher = matchername, dsl
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


PlaceAtomInScratchExpression : ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(ScratchExpressions.value.Atoms.value))
	{
		list<ExpressionAtom> atoms = atom, nothing
		Expression newexpr = atoms, 0
		ScratchExpressions.value = newexpr
	}
	else
	{
		AppendAtomToExpression(ScratchExpressions.value.Atoms, ScratchExpressions.value.Atoms.next, atom)
	}
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0xff000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(TypeAliases, literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifierReference : integer idhandle
{
	IdentifierAtom id = idhandle, 0, true, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterTypeAnnotation : integer annotationtype
{
	TypeAnnotationAtom taa = annotationtype
	ExpressionAtom atom = taa
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}


ExpressionAtomIsSentinel : AtomSentinel 	   ref sentinel    -> true [nogc]
ExpressionAtomIsSentinel : StringHandleAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : IdentifierAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : integer 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : integer16 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : boolean 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : real 		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : Statement		   ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : RefBinding              ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : CompoundAtom            ref nonsentinel -> false [nogc]
ExpressionAtomIsSentinel : ParentheticalExpression ref nonsentinel -> false [nogc]



AppendAtomToExpression : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, ExpressionAtom ref atom
{
	AppendAtomToExpression(tail, tail.next, atom)
}

AppendAtomToExpression : list<ExpressionAtom> ref atoms, nothing, ExpressionAtom ref atom
{
	list<ExpressionAtom> newatoms = atom, nothing
	atoms.next = newatoms
}


OnCodeGenEnterStatement : integer statementname, integer statementtype, boolean toplevel, boolean hastemplateargs
{
	Statement statement = statementname, nothing, statementtype, nothing, toplevel, false

	if(hastemplateargs)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		statement.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	OnCodeGenEmplaceStatement(statement)
}

OnCodeGenEmplaceStatement : Statement ref statement
{
	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
		LastTopLevelStatementHack.Wrapped = statement
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statement.Name
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}

OnCodeGenEnterAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}


OnCodeGenChainAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}


OnCodeGenEnterAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}



OnCodeGenChainAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}

OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}



AppendEntryToCurrentAssignmentChain : Assignment ref a
{
	AppendEntryToCurrentAssignmentChainWorker(CurrentCodeBlockStack, a)
}

AppendEntryToCurrentAssignmentChain : AssignmentCompound ref a
{
	AppendEntryToCurrentAssignmentChainWorker(CurrentCodeBlockStack, a)
}

AppendEntryToCurrentAssignmentChainWorker : list<OptionalCodeBlock> ref blockstack, Assignment ref a
{
	AppendEntryToAssignmentChain(blockstack, blockstack.next, a)
}

AppendEntryToCurrentAssignmentChainWorker : list<OptionalCodeBlock> ref blockstack, AssignmentCompound ref a
{
	AppendEntryToAssignmentChain(blockstack, blockstack.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref tail, Assignment ref a
{
	AppendEntryToAssignmentChain(tail, tail.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, nothing, Assignment ref a
{
	GetTailAssignmentAndChain(stack.value, a)
}


AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref tail, AssignmentCompound ref a
{
	AppendEntryToAssignmentChain(tail, tail.next, a)
}

AppendEntryToAssignmentChain : list<OptionalCodeBlock> ref stack, nothing, AssignmentCompound ref a
{
	GetTailAssignmentAndChain(stack.value, a)
}


GetTailAssignmentAndChain : CodeBlock ref codeblock, Assignment ref a
{
	FindTailAssignmentAndChain(codeblock.Entries, codeblock.Entries.next, a)
}

GetTailAssignmentAndChain : CodeBlock ref codeblock, AssignmentCompound ref a
{
	FindTailAssignmentAndChain(codeblock.Entries, codeblock.Entries.next, a)
}


FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, Assignment ref a
{
	FindTailAssignmentAndChain(tail, tail.next, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, nothing, Assignment ref a
{
	ChainAssignment(entries.value, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, AssignmentCompound ref a
{
	FindTailAssignmentAndChain(tail, tail.next, a)
}

FindTailAssignmentAndChain : list<CodeBlockEntry> ref entries, nothing, AssignmentCompound ref a
{
	ChainAssignment(entries.value, a)
}

ChainAssignment : Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

ChainAssignment : AssignmentCompound ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}


ChainAssignment : Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

ChainAssignment : AssignmentCompound ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}


AddAssignmentToChain : Assignment ref tomodify, Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : Assignment ref tomodify, Expression ref expr, Assignment ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Assignment ref a, Assignment ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Expression ref expr, Assignment ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : Assignment ref tomodify, Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : Assignment ref tomodify, Expression ref expr, AssignmentCompound ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Assignment ref a, AssignmentCompound ref newtail
{
	AddAssignmentToChain(a, a.RHS, newtail)
}

AddAssignmentToChain : AssignmentCompound ref tomodify, Expression ref expr, AssignmentCompound ref newtail
{
	ExpressionOrAssignment wrap = newtail
	tomodify.RHS = wrap
}


AppendEntryToCurrentCodeBlock : CodeBlockEntry ref cbe
{
	AppendEntryToCurrentCodeBlockWorker(CurrentCodeBlockStack, cbe)
}

AppendEntryToCurrentCodeBlockWorker : list<OptionalCodeBlock> ref blockstack, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(blockstack, blockstack.value, entry)
}

AppendEntryToCurrentCodeBlockWorker : nothing, CodeBlockEntry ref entry
{
	print("No code block is being processed")
	assert(false)
}


FindCurrentFunctionAndAppendCompoundMember : integer membername
{
	FindLastAssignmentAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}

FindCurrentFunctionAndChainCompoundMember : integer membername
{
	FindLastAssignmentAndChainCompoundMemberHelper(CurrentCodeBlockStack.value, membername)
}


FindLastAssignmentAndAppendCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(code.Entries, code.Entries.next, membername)
}

FindLastAssignmentAndChainCompoundMemberHelper : CodeBlock ref code, integer membername
{
	FindLastAssignmentAndChainCompoundMember(code.Entries, code.Entries.next, membername)
}



AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, CodeBlock ref code, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(code.Entries, entry)
}

AppendEntryToCodeBlock : list<OptionalCodeBlock> ref stack, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> stmtlist = entry, nothing
	CodeBlock block = stmtlist
	OptionalCodeBlock blockwrap = block
	stack.value = blockwrap
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, CodeBlockEntry ref entry
{
	AppendEntryToCodeBlock(entries, entries.next, entry)
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, nothing, CodeBlockEntry ref entry
{
	list<CodeBlockEntry> newlist = entry, nothing
	entries.next = newlist
}

AppendEntryToCodeBlock : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, CodeBlockEntry ref value
{
	AppendEntryToCodeBlock(tail, tail.next, value)
}


FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}


FindLastAssignmentAndChainCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastAssignmentAndChainCompoundMember(tail, tail.next, membername)
}

FindLastAssignmentAndChainCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	ChainCompoundMemberHelper(entries.value, membername)
}


ChainCompoundMemberHelper : Assignment ref a, integer membername
{
	ChainCompoundMember(a, a.RHS, membername)
}

ChainCompoundMemberHelper : AssignmentCompound ref a, integer membername
{
	ChainCompoundMember(a, a.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, Assignment ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : AssignmentCompound ref tomodify, Assignment ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, AssignmentCompound ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : AssignmentCompound ref tomodify, AssignmentCompound ref rhs, integer membername
{
	ChainCompoundMember(rhs, rhs.RHS, membername)
}

ChainCompoundMember : Assignment ref tomodify, Expression ref rhs, integer membername
{
	print("Fatal error - parser tried to associate a member with a non-compound assignment")
	assert(false)
}

ChainCompoundMember : AssignmentCompound ref tomodify, Expression ref rhs, integer membername
{
	AppendCompoundMemberHelper(tomodify, membername)
}


AppendCompoundMemberHelper : AssignmentCompound ref a, integer membername [nogc]
{
	AppendCompoundMember(a.LHS, a.LHS.next, membername)
}

AppendCompoundMemberHelper : PreOpStatement ref s, integer membername [nogc]
{
	AppendCompoundMember(s.Operand, s.Operand.next, membername)
}

AppendCompoundMemberHelper : PostOpStatement ref s, integer membername [nogc]
{
	AppendCompoundMember(s.Operand, s.Operand.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, simplelist<integer> ref tail, integer membername [nogc]
{
	AppendCompoundMember(tail, tail.next, membername)
}

AppendCompoundMember : simplelist<integer> ref members, nothing, integer membername [nogc]
{
	simplelist<integer> newtail = membername, nothing
	members.next = newtail
}



FindCurrentStatementAndAppendExpression : Expression ref expression
{
	FindLastStatementInBlockAndAppendExpression(CurrentCodeBlockStack.value, expression)
}

FindCurrentStatementAndAppendExpression : nothing


FindCurrentAssignmentAndSetExpression : Expression ref expression
{
	FindLastAssignmentInBlockAndSetExpression(CurrentCodeBlockStack.value, expression)
}



FindLastStatementInBlockAndAppendExpression : CodeBlock ref codeblock, Expression ref expression
{
	AppendExpressionToStatement(LastTopLevelStatementHack.Wrapped, expression)
}

FindLastStatementInBlockAndAppendExpression : nothing, Expression ref expression
{
	print("Not processing an active code block!")
	assert(false)
}


AppendExpressionToStatement : Statement ref statement, Expression ref expression
{
	AppendExpressionToStatementParams(statement, statement.Parameters, expression)
}

AppendExpressionToStatementParams : Statement ref statement, ExpressionList ref parameters, Expression ref expression
{
	AppendExpression(parameters.Expressions, parameters.Expressions.next, expression)
}

AppendExpressionToStatementParams : Statement ref statement, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	ExpressionList params = newlist
	statement.Parameters = params
}

AppendExpression : list<Expression> ref expressions, list<Expression> ref tail, Expression ref expression
{
	AppendExpression(tail, tail.next, expression)
}

AppendExpression : list<Expression> ref expressions, nothing, Expression ref expression
{
	list<Expression> newlist = expression, nothing
	expressions.next = newlist
}


FindLastAssignmentInBlockAndSetExpression : CodeBlock ref codeblock, Expression ref expression
{
	FindLastAssignmentAndSetExpression(codeblock.Entries, codeblock.Entries.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, list<CodeBlockEntry> ref tail, Expression ref expression
{
	FindLastAssignmentAndSetExpression(tail, tail.next, expression)
}

FindLastAssignmentAndSetExpression : list<CodeBlockEntry> ref codeblockentries, nothing, Expression ref expression
{
	SetAssignmentExpression(codeblockentries.value, expression)
}

SetAssignmentExpression : Assignment ref assignment, Expression ref expression
{
	FollowChainAndSetExpression(assignment, assignment.RHS, expression)
}

SetAssignmentExpression : AssignmentCompound ref assignment, Expression ref expression
{
	FollowChainAndSetExpression(assignment, assignment.RHS, expression)
}


FollowChainAndSetExpression : Assignment ref assignment, Assignment ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : Assignment ref assignment, AssignmentCompound ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : AssignmentCompound ref assignment, Assignment ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : AssignmentCompound ref assignment, AssignmentCompound ref rhs, Expression ref expression
{
	FollowChainAndSetExpression(rhs, rhs.RHS, expression)
}

FollowChainAndSetExpression : Assignment ref tomodify, Expression ref rhs, Expression ref newrhs
{
	ExpressionOrAssignment wrap = newrhs
	tomodify.RHS = wrap
}

FollowChainAndSetExpression : AssignmentCompound ref tomodify, Expression ref rhs, Expression ref newrhs
{
	ExpressionOrAssignment wrap = newrhs
	tomodify.RHS = wrap
}



SetFunctionCodeBlock : FunctionDefinition ref funcdef, OptionalCodeBlock ref optblock
{
	SetFunctionCodeBlockWorker(funcdef, optblock)
}

SetFunctionCodeBlock : nothing, OptionalCodeBlock ref optblock
{
	print("No function in flight")
	assert(false)
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, CodeBlock ref block
{
	funcdef.Code = block
}

SetFunctionCodeBlockWorker : FunctionDefinition ref funcdef, nothing



CodeGenEmitStrings : list<StringTableEntry> ref table
{
	listnode<StringTableEntry> cur = table
	while(HasSTEntry(cur))
	{
		if(GetSTHandle(cur) != 0)
		{
			OnBytecodePoolString(GetSTHandle(cur), GetSTData(cur))
		}

		cur = GetSTNext(cur)
	}
}

HasSTEntry : list<StringTableEntry> ref table -> true
HasSTEntry : nothing -> false

GetSTHandle : list<StringTableEntry> ref table -> integer handle = table.value.Handle
GetSTData : list<StringTableEntry> ref table -> string data = table.value.Data
GetSTNext : list<StringTableEntry> ref table -> listnode<StringTableEntry> ret = table.next

CodeGenEmitStructures : list<StructureDefinition> ref structures
{
	CodeGenEmitStructures(structures.next)

	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		OnBytecodeDefineStructure(structures.value.Type, structures.value.MemberCount)
		CodeGenEmitMembers(structures.value.Members)
	}
}

CodeGenEmitStructures : nothing

CodeGenEmitMembers : list<StructureMember> ref members
{
	CodeGenEmitMember(members.value)
	CodeGenEmitMembers(members.next)
}

CodeGenEmitMembers : nothing

CodeGenEmitMember : StructureMemberVariable ref memvar
{
	OnBytecodeStructureMember(memvar.Name, memvar.Type)
}

CodeGenEmitMember : StructureMemberFunctionRef ref member
{
	OnBytecodeStructureMember(member.Name, GetMemberTypeDecompose(member))
}



CodeGenEmitScopes : list<Scope> ref scopes
{
	CodeGenEmitScopes(scopes.next)

	if((scopes.value.Name != 0) && (scopes.value.Name != GlobalCodeBlockName))
	{
		integer parentname = scopes.value.ParentName
		if((parentname == 0) && (scopes.value.Name != GlobalCodeBlockName))
		{
			parentname = GlobalCodeBlockName
		}

		integer varcount = CountScopeVariables(scopes.value)
		OnBytecodeLexicalScope(scopes.value.Name, parentname, varcount)
		CodeGenEmitVariables(scopes.value.Variables, scopes.value.Name)
	}
}

CodeGenEmitScopes : nothing


CodeGenEmitSpecificScope : Scope ref scope
{
	integer varcount = CountScopeVariables(scope)
	OnBytecodeLexicalScope(scope.Name, 0, varcount)
	CodeGenEmitVariables(scope.Variables, 0)
}


CountScopeVariables : Scope ref scope -> integer count = 0 [nogc]
{
	CountScopeVariables(scope.Variables, count)
}

CountScopeVariables : list<Variable> ref variables, integer ref count [nogc]
{
	if(variables.value.Name != 0)
	{
		++count
	}

	CountScopeVariables(variables.next, count)
}

CountScopeVariables : nothing, integer ref count [nogc]


CodeGenEmitVariables : list<Variable> ref vars, integer funcname
{
	if(vars.value.Name != 0)
	{
		integer basetype = vars.value.VarType
		while((basetype & 0x7f000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(TypeAliases, basetype)
		}

		if(vars.value.Origin == 2)
		{
			if(listcontains(CustomConstructors, funcname))
			{
				OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, 0)
			}
			else
			{
				OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, vars.value.Origin)
			}
		}
		else
		{
			OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, vars.value.Origin)
		}
	}

	CodeGenEmitVariables(vars.next, funcname)
}

CodeGenEmitVariables : nothing, integer funcname



CodeGenEmitFunctions : list<FunctionDefinition> ref table
{
	if(!table.value.IsTemplate)
	{
		if(table.value.Name != 0)
		{
			FindScopeAndSetContext(table.value)

			EmittingFunctionName = table.value.Name
			OnBytecodeEnterFunction(table.value.Name)
			CodeGenEmitFunctionReturn(table.value.Return)

			if(table.value.InvokeTag != 0)
			{
				OnBytecodeInvoke(table.value.InvokeTag)
			}

			CodeGenEmitCodeBlock(table.value.Code)
			if(listcontains(CustomConstructors, table.value.Name))
			{
				OnBytecodePushVarValueNoCopy(FindReturnVariableName())
				OnBytecodeBindReference(0, 0)			// TODO - kind of a hack
				OnBytecodeAssign()
			}
			else
			{
				if(table.value.AnonymousReturn)
				{
					CodeGenEmitReturnRegisterAnonymous(table.value.Return)
				}
				else
				{
					CodeGenEmitReturnRegister(table.value.Return)
				}
			}
			OnBytecodeExitFunction()
		}
	}

	CodeGenEmitFunctions(table.next)
}

CodeGenEmitFunctions : nothing


FindScopeAndSetContext : FunctionDefinition ref func [nogc]
{
	EmittingScope.Wrapped = func.AttachedScope.Wrapped
}


CodeGenEmitFunctionReturn : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitFunctionReturn : nothing


CodeGenEmitReturnRegister : Expression ref expr
{
	integer index = FindReturnVariableIndex()
	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegister : nothing


CodeGenEmitReturnRegisterAnonymous : Expression ref expr
{
	integer index = FindReturnVariableIndex()

	OnBytecodeBindReference(0, index)
	OnBytecodeAssign()

	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegisterAnonymous : nothing



CodeGenEmitCodeBlock : CodeBlock ref block
{
	CodeGenEmitCodeBlockEntries(block.Entries)
}

CodeGenEmitCodeBlock : nothing


CodeGenEmitCodeBlockEntries : list<CodeBlockEntry> ref entries
{
	CodeGenEmitSingleCodeBlockEntry(entries.value)
	CodeGenEmitCodeBlockEntries(entries.next)
}

CodeGenEmitCodeBlockEntries : nothing


CodeGenEmitSingleCodeBlockEntry : Statement ref s
{
	boolean constructssumtype = false
	if((s.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtype = true
	}

	boolean constructorcall = StructureConstructorExists(Structures, s.Name)

	CodeGenEmitExpressionList(s.Parameters, constructssumtype, constructorcall)

	if(FunctionIsAutoGenOrHasIR(s.Name))
	{
		OnBytecodeInvokeOffset(s.Name)
	}
	elseif(SumTypeExists(s.Name))
	{
		OnBytecodeConstructSumType()
	}
	else
	{
		integer vartype = GetVariableTypeFromScope(EmittingScope.Wrapped, s.Name)
		if((vartype != 0) && ((vartype & 0x7f000000) == 0x09000000))
		{
			OnBytecodeInvokeIndirect(s.Name)
		}
		else
		{
			OnBytecodeInvoke(s.Name)
		}
	}
}

CodeGenEmitAssignmentRHS : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitAssignmentRHS : Assignment ref a
{
	CodeGenEmitAssignmentRHS(a.RHS)

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}

	CodeGenEmitBindingsForVariable(a.LHSName)
	OnBytecodeReadReference()
}

CodeGenEmitSingleCodeBlockEntry : Assignment ref a
{
	boolean sideeffects = false

	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForVariable(a.LHSName)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)

	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}

CodeGenEmitSingleCodeBlockEntry : AssignmentCompound ref a
{
	boolean sideeffects = false
	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForOperand(a.LHS)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)

	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHS.value, frames)
	OnBytecodeBindReference(frames, index)

	integer typeid = MakeNonReferenceType(FindVariableType(a.LHS.value))

	integer structurename = GetNameOfStructureByType(typeid)
	BindAssignmentMembers(a.LHS.next, structurename)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}


CodeGenEmitBindingsForOperand : simplelist<integer> ref operand
{
	integer frames = 0
	integer index = FindVariable(operand.value, frames)
	OnBytecodeBindReference(frames, index)

	integer structurename = GetNameOfStructureByType(FindVariableType(operand.value))
	BindAssignmentMembers(operand.next, structurename)
}

CodeGenEmitBindingsForVariable : integer operand
{
	integer frames = 0
	integer index = FindVariable(operand, frames)
	OnBytecodeBindReference(frames, index)
}


CodeGenEmitSingleCodeBlockEntry : PreOpStatement ref preop
{
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(preop.Operator)
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeAssign()
}

CodeGenEmitSingleCodeBlockEntry : PostOpStatement ref postop
{
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(postop.Operator)
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeAssign()
}



CodeGenEmitSingleCodeBlockEntry : EntityChain ref chain
{
	OnBytecodeBeginChain()
	CodeGenEmitEntityChain(chain.Entries)
	OnBytecodeEndChain()
}


CodeGenEmitEntityChain : EntityList ref entities
{
	CodeGenEmitEntityList(entities.ActualList)
}

CodeGenEmitEntityList : list<Entity> ref thelist
{
	if(thelist.value.Tag != 0)
	{
		CodeGenEmitExpression(thelist.value.Param, false, false)
		OnBytecodeEnterEntity(thelist.value.Tag, 0)
		CodeGenEmitCodeBlock(thelist.value.Code)
		OnBytecodeExitEntity()
	}

	CodeGenEmitEntityList(thelist.next)
}

CodeGenEmitEntityList : nothing


BindAssignmentMembers : simplelist<integer> ref lhsmembers, integer structurename
{
	integer membertype = 0
	integer memberoffset = 0
	GetStructureMemberTypeAndOffset(structurename, lhsmembers.value, membertype, memberoffset)

	OnBytecodeBindStructReference(membertype, memberoffset)

	// Recurse
	assertmsg(membertype != 0, "Member has no type!")
	BindAssignmentMembers(lhsmembers.next, GetNameOfType(membertype))
}

BindAssignmentMembers : nothing, integer structurename


ComputeCompoundAssignmentLHSType : AssignmentCompound ref assignment, Scope ref scope -> integer typeid = 0
{
	integer rootname = assignment.LHS.value

	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(scope, rootname, var)

	if(var.Name == 0)
	{
		print("Assignment has bogus LHS")
		assert(false)
	}

	assertmsg(var.VarType != 0, "Variable has no type!")

	integer vartypename = GetNameOfType(var.VarType)
	typeid = ComputeCompoundAssignmentLHSTypeMembers(assignment.LHS.next, vartypename)
}

ComputeCompoundAssignmentLHSTypeMembers : simplelist<integer> ref lhsmembers, integer structurename -> integer typeid = 0
{
	integer membertype = GetStructureMemberType(structurename, lhsmembers.value)
	assertmsg(membertype != 0, "Member in compound assignment has no type!")
	typeid = ComputeCompoundAssignmentLHSTypeMembers(lhsmembers.next, GetNameOfType(membertype))
}

ComputeCompoundAssignmentLHSTypeMembers : nothing, integer structurename -> integer typeid = GetTypeByName(structurename)




CodeGenEmitExpressionList : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpressionList : ExpressionList ref expressions, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionList(expressions.Expressions, constructssumtype, constructorcall)
}

CodeGenEmitExpressionList : list<Expression> ref expressions, boolean constructssumtype, boolean constructorcall
{
	boolean constructssumtypetemp = constructssumtype
	if((expressions.value.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtypetemp = true
	}

	CodeGenEmitExpressionAtoms(expressions.value.Atoms, constructssumtypetemp, constructorcall)
	CodeGenEmitExpressionList(expressions.next, constructssumtype, constructorcall)
}

CodeGenEmitExpression : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpression : Expression ref expr, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionAtoms(expr.Atoms, constructssumtype, constructorcall)
}

CodeGenEmitExpressionAtoms : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean constructorcall
{
	boolean needsref = false
	CodeGenEmitExpressionAtomsWorker(atoms, constructssumtype, needsref, constructorcall)
	if(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

CodeGenEmitExpressionAtomsWorker : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean ref needsref, boolean constructorcall
{
	boolean thisneedsref = CodeGenCheckAtomForReadRef(atoms.value)
	if(thisneedsref)
	{
		needsref = true
	}
	elseif(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
		needsref = false
	}

	CodeGenEmitSingleAtom(atoms.value, constructorcall)
	CodeGenEmitExpressionAtomsWorker(atoms.next, constructssumtype, needsref, constructorcall)
}

CodeGenEmitExpressionAtomsWorker : nothing, boolean constructssumtype, boolean ref needsref, boolean constructorcall


CodeGenCheckAtomForReadRef : RefBinding ref atom -> !atom.IsReference [nogc]
CodeGenCheckAtomForReadRef : CompoundAtom ref atom -> false [nogc]

CodeGenCheckAtomForReadRef : integer ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : integer16 ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : boolean ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : real ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : IdentifierAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : StringHandleAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : OperatorInvokeAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : TypeAnnotationAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : Statement ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : ParentheticalExpression ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : AtomSentinel ref atom -> false [nogc]




CodeGenEmitSingleAtom : integer ref literalinteger, boolean constructor
{
	OnBytecodePushLiteralInteger(literalinteger)
}

CodeGenEmitSingleAtom : integer16 ref literalinteger16, boolean constructor
{
	OnBytecodePushLiteralInteger16(literalinteger16)
}

CodeGenEmitSingleAtom : boolean ref literalboolean, boolean constructor
{
	OnBytecodePushBoolean(literalboolean)
}

CodeGenEmitSingleAtom : real ref literalreal, boolean constructor
{
	OnBytecodePushLiteralReal(literalreal)
}

CodeGenEmitSingleAtom : StringHandleAtom ref atom, boolean constructor
{
	OnBytecodePushLiteralString(atom.Handle)
}

CodeGenEmitSingleAtom : OperatorInvokeAtom ref atom, boolean constructor
{
	OnBytecodeInvoke(atom.OperatorName)
}

CodeGenEmitSingleAtom : IdentifierAtom ref idatom, boolean constructor
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		OnBytecodePushLiteralInteger(0)
	}
	else
	{
		if(idatom.IsFunction)
		{
			OnBytecodePushLiteralFunction(idatom.Handle)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			OnBytecodePushLiteralString(idatom.Handle)
		}
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if((!constructor) && (!idatom.IsReference))
				{
					OnBytecodePushLiteralString(idatom.Handle)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				OnBytecodePushLiteralFunction(idatom.Handle)
			}
			else
			{
				if(idatom.IsReference)
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)

					if(frames == 0)
					{
						OnBytecodePushVarValue(idatom.Handle, idatom.Type)
					}
					elseif(IsReferenceType(idatom.Type))
					{
						OnBytecodeBindReference(frames, index)
					}
					else
					{
						Variable var = 0, 0, 0, 0
						FindVariableDataInSingleScope(GlobalScope.Wrapped, idatom.Handle, var)

						if(var.Name == 0)
						{
							print("Code generation error - missing local variable " ; GetPooledString(GlobalStrings, idatom.Handle) ; " in scope " ; GetPooledString(GlobalStrings, EmittingFunctionName))
							assert(false)
						}
						OnBytecodePushLocal(frames, var.Offset)
					}
				}
			}
		}
	}
}

CodeGenEmitSingleAtom : TypeAnnotationAtom ref atom, boolean constructor
{
	OnBytecodePushTypeAnnotation(MakeNonReferenceType(atom.Type))
}

CodeGenEmitSingleAtom : Statement ref atom, boolean constructor
{
	CodeGenEmitSingleCodeBlockEntry(atom)
}

CodeGenEmitSingleAtom : RefBinding ref atom, boolean constructor
{
	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(atom.StructureName, atom.Identifier, memtype, memoffset)

	OnBytecodeBindStructReference(memtype, memoffset)
}

CodeGenEmitSingleAtom : ParentheticalExpression ref expr, boolean constructor
{
	CodeGenDecomposeParenthetical(expr.Inner)
}

CodeGenDecomposeParenthetical : Expression ref expr
{
	CodeGenEmitExpression(expr, false, false)
}

CodeGenDecomposeParenthetical : PreOpStatement ref statement
{
	CodeGenEmitSingleCodeBlockEntry(statement)
	CodeGenEmitBindingsForOperand(statement.Operand)
	OnBytecodeReadReference()
}

CodeGenDecomposeParenthetical : PostOpStatement ref statement
{
	CodeGenEmitBindingsForOperand(statement.Operand)
	OnBytecodeReadReference()
	CodeGenEmitSingleCodeBlockEntry(statement)
}

CodeGenEmitSingleAtom : CompoundAtom ref atom, boolean constructor
{
	integer frames = 0
	integer index = FindVariable(atom.Bindings.value.Identifier, frames)
	OnBytecodeBindReference(frames, index)

	EmitCompoundBindings(atom.Bindings, atom.Bindings.next)

	if(!IsReferenceType(atom.Type))
	{
		if((atom.Type & 0x7f000000) == 0x07000000)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

EmitCompoundBindings : list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(EmittingScope.Wrapped, bindings.value.Identifier, var)

	assertmsg(var.VarType != 0, "Compound bindings reference bogus variable")
	integer lhstypename = GetNameOfType(var.VarType)

	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(lhstypename, tail.value.Identifier, memtype, memoffset)

	OnBytecodeBindStructReference(memtype, memoffset)

	EmitCompoundSubsequentBindings(tail.next)
}

EmitCompoundSubsequentBindings : nothing

EmitCompoundSubsequentBindings : list<RefBinding> ref bindings
{
	CodeGenEmitSingleAtom(bindings.value, false)
	EmitCompoundSubsequentBindings(bindings.next)
}


CodeGenEmitSingleAtom : AtomSentinel ref sentinel, boolean constructor


GetNameOfStructureByType : integer typeid -> integer name = 0
{
	name = GetNameOfStructureByType(Structures, typeid)
}

GetNameOfStructureByType : list<StructureDefinition> ref structures, integer typeid -> integer name = 0
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.Name
	}
	else
	{
		name = GetNameOfStructureByType(structures.next, typeid)
	}
}

GetNameOfStructureByType : nothing, integer typeid -> integer name = 0


GetStructureMemberTypeAndOffset : integer structurename, integer membername, integer ref memtype, integer ref memoffset
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, structurename, wrap)
	assert(found)

	memtype = 0
	memoffset = 0
	GetMemberTypeAndOffset(wrap, membername, memtype, memoffset)
}

GetStructureMemberType : integer structurename, integer membername -> integer rtype = 0
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, structurename, wrap)
	if(found)
	{
		rtype = GetMemberType(wrap, membername)
		
		if(rtype == 0)
		{
			print(GetPooledString(GlobalStrings, structurename))
		}
	}
	else
	{
		print("Bogus structure")
		assert(false)
	}
}


GetMemberType : StructureDefinition ref struct, integer membername -> integer ty = GetMemberType(struct.Members, membername)


GetMemberType : list<StructureMember> ref members, integer membername -> integer rtype = 0
{
	if(GetMemberName(members.value) == membername)
	{
		rtype = GetMemberTypeDecompose(members.value)
		assertmsg(rtype != 0, "Member has no type; cannot return from GetMemberType")
	}
	else
	{
		rtype = GetMemberType(members.next, membername)
	}
}

GetMemberType : nothing, integer membername -> integer rtype = 0
{
	print("Bogus structure member!")
	print(GetPooledString(GlobalStrings, membername))
}


GetMemberTypeAndOffset : StructureDefinition ref struct, integer membername, integer ref memtype, integer ref memoffset
{
	GetMemberTypeAndOffset(struct.Members, membername, memtype, memoffset)
}


GetMemberTypeAndOffset : list<StructureMember> ref members, integer membername, integer ref memtype, integer ref memoffset
{
	integer thisname = GetMemberName(members.value)
	if(thisname == membername)
	{
		memtype = GetMemberTypeDecompose(members.value)
	}
	else
	{
		if(thisname != 0)
		{
			memoffset += GetMemberSize(members.value)
		}
		GetMemberTypeAndOffset(members.next, membername, memtype, memoffset)
	}
}

GetMemberTypeAndOffset : nothing, integer membername, integer ref memtype, integer ref memoffset
{
	print("Bogus structure member!")
	assert(false)
}


GetMemberTypeDecompose : StructureMemberVariable ref memvar -> integer rtype = memvar.Type [nogc]

GetMemberTypeDecompose : StructureMemberFunctionRef ref member -> integer rtype = FindOrCreateFunctionSignatureType(member.Signature) [nogc]


GetMemberName : StructureMemberVariable ref memvar -> integer name = memvar.Name [nogc]

GetMemberName : StructureMemberFunctionRef ref member -> integer name = member.Name [nogc]


GetMemberSize : StructureMemberVariable ref memvar -> integer r = GetTypeSize(memvar.Type) [nogc]

GetMemberSize : StructureMemberFunctionRef ref member -> 4 [nogc]



CodeGenEmitSumTypes : list<SumType> ref sumtypes
{
	if((sumtypes.value.Type != 0) && (!sumtypes.value.IsTemplate))
	{
		OnBytecodeEmitByte(0x1f)			// SumTypeDef instruction
		OnBytecodeEmitInteger(sumtypes.value.Type)
		OnBytecodeEmitInteger(CountSumTypeBases(sumtypes.value.Bases))
		CodeGenEmitSumTypeBase(sumtypes.value.Bases)
	}

	CodeGenEmitSumTypes(sumtypes.next)
}

CodeGenEmitSumTypes : nothing

CountSumTypeBases : list<SumTypeBase> ref bases -> integer count = 0 [nogc]
{
	count = CountSumTypeBases(bases.next)

	if(bases.value.Name != 0)
	{
		++count
	}
}

CountSumTypeBases : nothing -> integer count = 0 [nogc]

CodeGenEmitSumTypeBase : list<SumTypeBase> ref bases [nogc]
{
	CodeGenEmitSumTypeBase(bases.next)

	if(bases.value.Name != 0)
	{
		OnBytecodeEmitInteger(bases.value.Name)
	}
}

CodeGenEmitSumTypeBase : nothing [nogc]


SumTypeExists : integer typename -> boolean exists = SearchBinaryTree<SumType>(SumTypesWhichExist, typename) [nogc]


FindSumTypeName : integer typeid -> integer name = FindSumTypeName(SumTypes, typeid) [nogc]

FindSumTypeName : list<SumType> ref sumtypes, integer typeid -> integer name = 0 [nogc]
{
	if(sumtypes.value.Type == typeid)
	{
		name = sumtypes.value.Name
	}
	else
	{
		name = FindSumTypeName(sumtypes.next, typeid)
	}
}

FindSumTypeName : nothing, integer typeid -> 0 [nogc]


SumTypeHasBase : list<SumType> ref sumtypes, integer sumtypeid, integer basetypeid -> boolean hasbase = false [nogc]
{
	if(basetypeid == 0)
	{
		return()
	}

	if(sumtypeid == 0)
	{
		return()
	}

	if(sumtypes.value.Type == sumtypeid)
	{
		hasbase = CheckBaseTypes(sumtypes.value.Bases, basetypeid)
	}
	else
	{
		hasbase = SumTypeHasBase(sumtypes.next, sumtypeid, basetypeid)
	}
}

SumTypeHasBase : nothing, integer sumtypeid, integer basetypeid -> false [nogc]


CheckBaseTypes : list<SumTypeBase> ref bases, integer basetypeid -> boolean hasbase = false [nogc]
{
	if(bases.value.Name == basetypeid)
	{
		hasbase = true
	}
	else
	{
		hasbase = CheckBaseTypes(bases.next, basetypeid)
	}
}

CheckBaseTypes : nothing, integer basetypeid -> false [nogc]




FunctionIsAutoGenOrHasIR : integer funcname -> boolean ret = false
{
	if(IsRecognizedBuiltIn(funcname))
	{
		return()
	}

	if(SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, funcname))
	{
		ret = true
	}
	elseif(FunctionIsAutoGen(AutoGeneratedFunctionNames, funcname))
	{
		ret = true
	}
	elseif(TypeMatcherExists(TypeMatchers, funcname))
	{
		ret = true
	}
	elseif(PatternMatcherExists(PendingPatternMatchers, funcname))
	{
		ret = true
	}
}

FunctionIsAutoGen : simplelist<integer> ref genlist, integer target -> boolean ret = false [nogc]
{
	if(genlist.value == target)
	{
		ret = true
	}
	else
	{
		ret = FunctionIsAutoGen(genlist.next, target)
	}
}

FunctionIsAutoGen : nothing, integer target -> boolean ret = false [nogc]



TypeMatcherExists : list<TypeMatcher> ref matchers, integer matchername -> boolean ret = false [nogc]
{
	if(matchers.value.Name == matchername)
	{
		ret = true
	}
	else
	{
		ret = TypeMatcherExists(matchers.next, matchername)
	}
}

TypeMatcherExists : nothing, integer matchername -> boolean ret = false [nogc]


GetExistingTypeMatcher : list<TypeMatcher> ref matchers, integer matchername, ContextNode<TypeMatcher> ref out -> boolean ret = false [nogc]
{
	if(matchers.value.Name == matchername)
	{
		ContextNode<TypeMatcher> outwrap = matchers.value
		out = outwrap
		ret = true
	}
	else
	{
		ret = GetExistingTypeMatcher(matchers.next, matchername, out)
	}
}

GetExistingTypeMatcher : nothing, integer matchername, ContextNode<TypeMatcher> ref out -> boolean ret = false [nogc]



FindVariable : integer name, integer ref frames -> integer index = 0
{
	FindVariableInSingleScope(EmittingScope.Wrapped, name, index)

	if(index < 0)
	{
		index = 0
		FindVariableInSingleScope(GlobalScope.Wrapped, name, index)
		frames = -1
	}
}


FindVariableInSingleScope : Scope ref scope, integer varname, integer ref index
{
	FindVariableInSingleScope(scope.Variables, varname, index)
}

FindVariableInSingleScope : list<Variable> ref vars, integer varname, integer ref index
{
	if(vars.value.Name != varname)
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindVariableInSingleScope(vars.next, varname, index)
	}
}

FindVariableInSingleScope : nothing, integer varname, integer ref index
{
	index = -1
}


FindReturnVariableIndex : -> integer index = 0
{
	FindReturnVariableInSingleScope(EmittingScope.Wrapped, index)
}

FindReturnVariableName: -> integer name = 0
{
	FindReturnVariableNameInSingleScope(EmittingScope.Wrapped, name)
}

FindReturnVariableInSingleScope : Scope ref scope, integer ref index
{
	FindReturnVariableInSingleScope(scope.Variables, index)
}

FindReturnVariableInSingleScope : list<Variable> ref vars, integer ref index
{
	if(vars.value.Origin != 2)		// VARIABLE_ORIGIN_RETURN
	{
		if(vars.value.Name != 0)
		{
			++index
		}

		FindReturnVariableInSingleScope(vars.next, index)
	}
}

FindReturnVariableInSingleScope : nothing, integer ref index
{
	index = -1
}

FindReturnVariableNameInSingleScope : Scope ref scope, integer ref name
{
	FindReturnVariableNameInSingleScope(scope.Variables, name)
}

FindReturnVariableNameInSingleScope : list<Variable> ref vars, integer ref name
{
	if(vars.value.Origin == 2)		// VARIABLE_ORIGIN_RETURN
	{
		name = vars.value.Name
	}
	else
	{
		FindReturnVariableNameInSingleScope(vars.next, name)
	}
}

FindReturnVariableNameInSingleScope : nothing, integer ref name
{
	name = 0
}



FindVariableType : integer varname -> integer rettype = 0
{
	rettype = GetVariableTypeFromScope(EmittingScope.Wrapped, varname)
	if(rettype == 0)
	{
		rettype = GetVariableTypeFromScope(GlobalScope.Wrapped, varname)
	}
}

FindVariableDataInSingleScope : Scope ref scope, integer varname, Variable ref outvar -> boolean found = false [nogc]
{
	found = FindVariableDataInSingleScope(scope.Variables, varname, outvar)
	if(!found)
	{
		if(scope.Name != GlobalCodeBlockName)
		{
			found = FindVariableDataInSingleScope(GlobalScope.Wrapped, varname, outvar)
		}
	}
}

FindVariableDataInSingleScope : list<Variable> ref vars, integer varname, Variable ref outvar -> boolean found = false [nogc]
{
	if(vars.value.Name == varname)
	{
		outvar = vars.value
		found = true
		return()
	}

	found = FindVariableDataInSingleScope(vars.next, varname, outvar)
}

FindVariableDataInSingleScope : nothing, integer varname, Variable ref outvar -> boolean found = false [nogc]


GetVariableTypeFromScope : Scope ref scope, integer varname -> integer vartype = 0 [nogc]
{
	vartype = GetVariableTypeFromScope(scope.Variables, varname)
	if(vartype == 0)
	{
		if(scope.Name != GlobalCodeBlockName)
		{
			vartype = GetVariableTypeFromScope(GlobalScope.Wrapped, varname)
		}
	}
}

GetVariableTypeFromScope : list<Variable> ref vars, integer varname -> integer vartype = 0 [nogc]
{
	if(vars.value.Name == varname)
	{
		vartype = vars.value.VarType
	}
	else
	{
		vartype = GetVariableTypeFromScope(vars.next, varname)
	}
}

GetVariableTypeFromScope : nothing, integer varname -> 0 [nogc]


CodeGenEmitTypeMatchers : list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{
		OnBytecodeLexicalScope(matchers.value.Name, 0, 0)
		OnBytecodeEnterTypeResolver(matchers.value.Name)
		CodeGenEmitTypeMatcherOverloads(matchers.value.Overloads)
		OnBytecodeExitTypeResolver()
	}

	CodeGenEmitTypeMatchers(matchers.next)
}

CodeGenEmitTypeMatchers : nothing


FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, list<FunctionSignature> ref signatures, integer overloadname, Parameter ref p
{
	if(signatures.value.Name == overloadname)
	{
		AppendParameter(signatures.value.Parameters, p)
	}
	else
	{
		FindTMOverloadAndAppendParameter(originallist, signatures.next, overloadname, p)
	}
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, nothing, integer overloadname, Parameter ref p
{
	list<Parameter> paramlist = p, nothing
	FunctionSignature sig = overloadname, paramlist, 0
	prepend<FunctionSignature>(originallist, sig)
}

AppendParameter : list<Parameter> ref params, Parameter ref p
{
	AppendParameterRecurse(params, params.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, list<Parameter> ref tail, Parameter ref p
{
	AppendParameterRecurse(tail, tail.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, nothing, Parameter ref p
{
	list<Parameter> newlist = p, nothing
	params.next = newlist
}


CodeGenEmitTypeMatcherOverloads : list<FunctionSignature> ref signatures
{
	CodeGenEmitTypeMatcherOverloads(signatures.next)

	if(signatures.value.Name != 0)
	{
		OnBytecodeEmitByte(0x20)				// TypeMatch instruction
		OnBytecodeEmitInteger(signatures.value.Name)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(CountParameters(signatures.value.Parameters))

		CodeGenEmitTypeMatcherParams(signatures.value.Parameters)
	}
}

CodeGenEmitTypeMatcherOverloads : nothing


CountParameters : list<Parameter> ref params -> integer count = 0 [nogc]
{
	count = CountParameters(params.next)

	if(params.value.Type != 0)
	{
		++count
	}
}

CountParameters : nothing -> integer count = 0 [nogc]


CodeGenEmitTypeMatcherParams : list<Parameter> ref params [nogc]
{
	CodeGenEmitTypeMatcherParams(params.next)

	if(params.value.Name != 0)
	{
		integer refflag = 0
		if(IsReferenceType(params.value.Type))
		{
			refflag = 1
		}

		OnBytecodeEmitByte(refflag)
		OnBytecodeEmitInteger(MakeNonReferenceType(params.value.Type))
	}
}

CodeGenEmitTypeMatcherParams : nothing [nogc]


FindFunctionAndSetInvokeTag : list<FunctionDefinition> ref functions, integer funcname, integer invoketarget [nogc]
{
	if(functions.value.Name == funcname)
	{
		functions.value.InvokeTag = invoketarget
	}
	else
	{
		FindFunctionAndSetInvokeTag(functions.next, funcname, invoketarget)
	}
}

FindFunctionAndSetInvokeTag : nothing, integer funcname, integer invoketarget [nogc]
{
	print("Cannot tag non-existent function")
	assert(false)
}

OnCodeGenRegisterFunctionTag : integer funcname, string tagname, integer rawfuncname
{
	list<string> dtp = "", nothing
	FunctionTag tag = funcname, tagname, dtp
	prepend<FunctionTag>(FunctionTags, tag)

	if(tagname == "constructor")
	{
		simpleprepend<integer>(CustomConstructors, funcname)

		integer baseconstructorname = PoolString(GetPooledString(GlobalStrings, rawfuncname) ; "@@constructor")

		Overload overload = baseconstructorname, funcname, nothing
		prepend<Overload>(AutoGenOverloads, overload)
		FindFunctionAndAddOverload(overload)

		PrependFunctionParameter(Functions, funcname, PoolString("@id"), 0x81000000)		// reference to identifier type signature
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParam(FunctionTags.value.Parameters, FunctionTags.value.Parameters.next, param)
}

AppendFunctionTagParam : list<string> ref params, list<string> ref tail, string param
{
	AppendFunctionTagParam(tail, tail.next, param)
}

AppendFunctionTagParam : list<string> ref params, nothing, string param
{
	list<string> newlist = param, nothing
	params.next = newlist
}


CodeGenEmitFunctionTags : list<FunctionTag> ref tags
{
	if(tags.value.FunctionName != 0)
	{
		if(tags.value.TagName != "")
		{
			OnBytecodeEmitByte(0x1a)
			OnBytecodeEmitInteger(tags.value.FunctionName)
			OnBytecodeEmitInteger(CountTagParams(tags.value.Parameters))
			OnBytecodeEmitString(tags.value.TagName)

			CodeGenEmitFunctionTagParams(tags.value.Parameters)
		}
	}
	CodeGenEmitFunctionTags(tags.next)
}

CodeGenEmitFunctionTags : nothing



CodeGenEmitFunctionTagParams : list<string> ref params [nogc]
{
	if(params.value != "")
	{
		OnBytecodeEmitString(params.value)
	}

	CodeGenEmitFunctionTagParams(params.next)
}

CodeGenEmitFunctionTagParams : nothing [nogc]


CountTagParams : list<string> ref params -> integer count = 0 [nogc]
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0 [nogc]


CodeGenEmitConstructors : list<StructureDefinition> ref structures
{
	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		EmitCtorTag(structures.value.ConstructorName)
		EmitCtorTag(structures.value.AnonConstructorName)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCtorTag(structures.value.CopyConstructorName)
		}

		EmitConstructor(structures.value)
		EmitAnonConstructor(structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCopyConstructor(structures.value)
		}
	}

	CodeGenEmitConstructors(structures.next)
}

CodeGenEmitConstructors : nothing

EmitCtorTag : integer funcname
{
	OnBytecodeEmitByte(0x1a)
	OnBytecodeEmitInteger(funcname)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitString("@@autogen@constructor")
}


EmitConstructor : StructureDefinition ref def
{
	integer idhandle = PooledStringHandleForIdentifier

	OnBytecodeLexicalScope(def.ConstructorName, 0, def.MemberCount + 1)
	OnBytecodeLexicalScopeEntry(idhandle, 0x81000000, 1)
	EmitScopeEntriesForMembers(def.Members)

	OnBytecodeEnterFunction(def.ConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, idhandle)

	OnBytecodeExitFunction()
}

EmitAnonConstructor : StructureDefinition ref def
{
	integer membercount = def.MemberCount
	OnBytecodeLexicalScope(def.AnonConstructorName, 0, membercount + 1)
	EmitScopeEntriesForMembers(def.Members)
	OnBytecodeLexicalScopeEntry(def.AnonConstructorName, def.Type, 2)

	OnBytecodeEnterFunction(def.AnonConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, membercount)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, def.AnonConstructorName)

	OnBytecodeSetReturnRegister(membercount)
	OnBytecodeExitFunction()
}

EmitCopyConstructor : StructureDefinition ref def
{
	OnBytecodeLexicalScope(def.CopyConstructorName, 0, 2)
	OnBytecodeLexicalScopeEntry(PooledStringHandleForIdentifier, 0x81000000, 1)
	OnBytecodeLexicalScopeEntry(def.Name, def.Type, 1)

	OnBytecodeEnterFunction(def.CopyConstructorName)
	OnBytecodePushVarValueNoCopy(def.Name)
	OnBytecodeCopyStructure()
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()
	OnBytecodeExitFunction()
}


EmitScopeEntriesForMembers : list<StructureMember> ref members
{
	EmitScopeEntryForMember(members.value)
	EmitScopeEntriesForMembers(members.next)
}

EmitScopeEntriesForMembers : nothing


EmitScopeEntryForMember : StructureMemberVariable ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, memvar.Type, 1)
	}
}

EmitScopeEntryForMember : StructureMemberFunctionRef ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, GetMemberTypeDecompose(memvar), 1)
	}
}



EmitMemberDataCopies : list<StructureMember> ref members, integer idhandle
{
	EmitMemberDataCopy(members.value, idhandle)
	EmitMemberDataCopies(members.next, idhandle)
}

EmitMemberDataCopies : nothing, integer idhandle

EmitMemberDataCopy : StructureMemberVariable ref memvar, integer idhandle
{
	if(memvar.Name != 0)
	{
		OnBytecodePushVarValue(memvar.Name, memvar.Type)
		OnBytecodeCopyToStructure(idhandle, memvar.Name)
	}
}

EmitMemberDataCopy : StructureMemberFunctionRef ref member, integer idhandle
{
	if(member.Name != 0)
	{
		OnBytecodePushVarValue(member.Name, 0x09000000)
		OnBytecodeCopyToStructure(idhandle, member.Name)
	}
}


GetNameOfType : integer typeid -> integer name = 0
{
	typeid = MakeNonReferenceType(typeid)
	if(typeid == 0x01000001)
	{
		name = PooledStringHandleForInteger
	}
	elseif(typeid == 0x01000002)
	{
		name = PooledStringHandleForInteger16
	}
	elseif(typeid == 0x01000003)
	{
		name = PooledStringHandleForBoolean
	}
	elseif(typeid == 0x01000004)
	{
		name = PooledStringHandleForReal
	}
	elseif(typeid == 0x02000000)
	{
		name = PooledStringHandleForString
	}
	elseif(typeid == 0x02000001)
	{
		name = PooledStringHandleForBuffer
	}
	elseif(typeid == 0x00000004)
	{
		name = PooledStringHandleForNothing
	}
	elseif(typeid == 0x01000000)
	{
		name = PooledStringHandleForIdentifier
	}
	elseif(IsStructureType(typeid))
	{
		name = GetNameOfStructureByType(typeid)
	}
	elseif((typeid & 0xff000000) == 0x07000000)
	{
		name = FindSumTypeName(typeid)
	}
	elseif((typeid & 0x7f000000) == 0x09000000)
	{
		name = PoolString("{function} " ; cast(string, typeid))
	}
	else
	{
		print("Unknown type " ; cast(string, typeid))
		assert(false)
	}
}

GetTypeByName : integer name -> integer typeid = 0 [nogc]
{
	if(name == 0)
	{
		return()
	}

	integer unaliasedname = UnaliasType(TypeWeakAliases, name)
	while(unaliasedname != name)
	{
		name = unaliasedname
		unaliasedname = UnaliasType(TypeWeakAliases, name)
	}
	name = unaliasedname

	if(name == PooledStringHandleForIdentifier)
	{
		typeid = 0x01000000
	}
	elseif(name == PooledStringHandleForInteger)
	{
		typeid = 0x01000001
	}
	elseif(name == PooledStringHandleForInteger16)
	{
		typeid = 0x01000002
	}
	elseif(name == PooledStringHandleForBoolean)
	{
		typeid = 0x01000003
	}
	elseif(name == PooledStringHandleForReal)
	{
		typeid = 0x01000004
	}
	elseif(name == PooledStringHandleForString)
	{
		typeid = 0x02000000
	}
	elseif(name == PooledStringHandleForNothing)
	{
		typeid = 0x00000004
	}
	elseif(name == PooledStringHandleForBuffer)
	{
		typeid = 0x02000001
	}
	else
	{
		integer structuretype = GetStructureTypeByName(name)
		if(structuretype != 0)
		{
			typeid = structuretype
			return()
		}

		integer sumtype = FindSumTypeByName(name)
		if(sumtype != 0)
		{
			typeid = sumtype
			return()
		}

		integer strongaliastype = FindTypeAliasByName(TypeAliases, name)
		if(strongaliastype != 0)
		{
			typeid = strongaliastype
			return()
		}
	}
}


FindSumTypeByName : integer name -> integer typeid = 0 [nogc]
{
	ContextNode<SumType> wrap = nothing
	if(SearchBinaryTreeForPayload<SumType>(SumTypesWhichExist, name, wrap))
	{
		typeid = GrabSumTypeID(wrap)
	}
}

GrabSumTypeID : SumType ref st -> integer typeid = st.Type [nogc]


UnaliasType : list<TypeAlias> ref aliases, integer namehandle -> integer unaliasedname = 0 [nogc]
{
	if(aliases.value.AliasNameHandle == namehandle)
	{
		unaliasedname = aliases.value.BaseNameHandle
	}
	else
	{
		unaliasedname = UnaliasType(aliases.next, namehandle)
	}
}

UnaliasType : nothing, integer namehandle -> integer unaliasedname = namehandle [nogc]



GetStructureTypeByName : integer name -> integer typeid = 0 [nogc]
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, name, wrap)

	if(found)
	{
		typeid = UnwrapStructureType(wrap)
	}
}

UnwrapStructureType : StructureDefinition ref struct -> integer ty = struct.Type [nogc]



// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	simplelist<integer> processed = 0, nothing
	boolean changed = CodeGenRearrangeStructuresRecurse(thelist, processed)

	if(changed)
	{
		CodeGenRearrangeStructures(thelist)
	}
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref thelist, simplelist<integer> ref processed -> boolean changed = false
{
	if((thelist.value.Name != 0) && (!thelist.value.IsTemplate))
	{
		simplelist<integer> dependencies = 0, nothing
		ParseStructDependencies(thelist.value.Members, dependencies)

		if(MissingDependency(dependencies, processed))
		{
			SwapDown(thelist, thelist.next)
			changed = true
		}

		simpleprepend<integer>(processed, thelist.value.Type)
	}

	if(!changed)
	{
		CodeGenRearrangeStructuresRecurse(thelist.next, processed)
	}
}

CodeGenRearrangeStructuresRecurse : nothing, simplelist<integer> ref processed -> false


SwapDown : list<StructureDefinition> ref thelist, list<StructureDefinition> ref tail
{
	StructureDefinition temp = tail.value
	tail.value = thelist.value
	thelist.value = temp
}

SwapDown : list<StructureDefinition> ref thelist, nothing



ParseStructDependencies : list<StructureMember> ref members, simplelist<integer> ref out
{
	integer dependency = GetMemberDependency(members.value)
	if(dependency != 0)
	{
		simpleprepend<integer>(out, dependency)
	}

	ParseStructDependencies(members.next, out)
}

ParseStructDependencies : nothing, simplelist<integer> ref out


GetMemberDependency : StructureMemberVariable ref var -> integer dep = 0
{
	if(var.Name != 0)
	{
		if(IsStructureType(var.Type))
		{
			dep = var.Type
		}
	}
}

GetMemberDependency : StructureMemberFunctionRef ref member -> 0


MissingDependency : simplelist<integer> ref dependencies, simplelist<integer> ref processed -> boolean missing = true
{
	// TODO - clean up this horrible code
	if(dependencies.value != 0)
	{
		if(listcontains(processed, dependencies.value))
		{
			missing = false
		}
		else
		{
			missing = MissingDependency(dependencies.next, processed)
		}
	}
	else
	{
		missing = MissingDependency(dependencies.next, processed)
	}
}

MissingDependency : nothing, simplelist<integer> ref processed -> boolean missing = false


OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityStack.value.Param = ScratchExpressions.value

	OptionalCodeBlock block = nothing
	prepend<OptionalCodeBlock>(CurrentCodeBlockStack, block)
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


AppendEntityToChain : list<EntityChain> ref chainstack, Entity ref e
{
	AppendEntityToChainUnwrap(chainstack.value.Entries, e)
}

AppendEntityToChainUnwrap : EntityList ref entitylist, Entity ref e
{
	AppendEntityToChainWorker(entitylist.ActualList, entitylist.ActualList.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, list<Entity> ref tail, Entity ref e
{
	AppendEntityToChainWorker(tail, tail.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, nothing, Entity ref e
{
	list<Entity> newtail = e, nothing
	chain.next = newtail
}


FindTypeAliasBase : list<TypeAlias> ref aliases, integer aliastype -> integer basetype = 0 [nogc]
{
	if(aliases.value.TypeID == aliastype)
	{
		basetype = GetTypeByName(aliases.value.BaseNameHandle)
	}
	else
	{
		basetype = FindTypeAliasBase(aliases.next, aliastype)
	}
}

FindTypeAliasBase : nothing, integer aliastype -> integer basetype = 0 [nogc]


FindTypeAliasByName : list<TypeAlias> ref aliases, integer aliasname -> integer aliastype = 0 [nogc]
{
	if(aliases.value.AliasNameHandle == aliasname)
	{
		aliastype = aliases.value.TypeID
	}
	else
	{
		aliastype = FindTypeAliasByName(aliases.next, aliasname)
	}
}

FindTypeAliasByName : nothing, integer aliasname -> 0 [nogc]


OnCodeGenRegisterAlias : integer aliastype, integer aliasname, integer base
{
	TypeAlias newalias = aliastype, aliasname, base
	prepend<TypeAlias>(TypeAliases, newalias)
}

OnCodeGenRegisterWeakAlias : integer aliastype, integer aliasname, integer basename
{
	TypeAlias newalias = aliastype, aliasname, basename
	prepend<TypeAlias>(TypeWeakAliases, newalias)
}


OnCodeGenRegisterFunctionSig : integer sigtype, integer rettypename
{
	list<Parameter> d = dummyparam, nothing
	FunctionSignature sig = sigtype, d, rettypename
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype
{
	Parameter param = 1, paramtype
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigParamList : simplelist<integer> ref paramtypenames
{
	OnCodeGenRegisterFunctionSigParamList(paramtypenames.next)

	if(paramtypenames.value != 0)
	{
		integer paramtype = GetTypeByName(paramtypenames.value)
		if(paramtype == 0)
		{
			paramtype = paramtypenames.value
		}

		OnCodeGenRegisterFunctionSigParam(paramtype)		// TODO - defer higher order function parameter type resolution until type inference
	}
}

OnCodeGenRegisterFunctionSigParamList : nothing


CodeGenEmitFunctionSignatures : list<FunctionSignature> ref thelist
{
	if(thelist.value.Name != 0)
	{
		integer rettype = GetTypeByName(thelist.value.ReturnTypeName)
		if(rettype == 0)
		{
			rettype = 0x00000002		// void
		}

		OnBytecodeEmitFunctionSignature(thelist.value.Name, rettype, CountParameters(thelist.value.Parameters))
		CodeGenEmitFunctionSigParams(thelist.value.Parameters)
	}
	CodeGenEmitFunctionSignatures(thelist.next)
}

CodeGenEmitFunctionSignatures : nothing


CodeGenEmitFunctionSigParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		OnBytecodeEmitFunctionSigParam(params.value.Type)
	}
	CodeGenEmitFunctionSigParams(params.next)
}

CodeGenEmitFunctionSigParams : nothing


OnCodeGenRegisterParenthetical :
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, d)
}


OnCodeGenPreparePreOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist, 0

	PreOpOnDeck = preop
}

OnCodeGenPreparePreOpCompoundOperand : integer operand
{
	AppendCompoundMemberHelper(PreOpOnDeck, operand)
}

OnCodeGenCompletePreOpStatement : boolean substatement
{
	if(substatement)
	{
		ExpressionOrPrePostOp wrap = PreOpOnDeck
		ParentheticalExpression parenthetical = wrap
		ExpressionAtom atom = parenthetical
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		CodeBlockEntry cbe = PreOpOnDeck
		AppendEntryToCurrentCodeBlock(cbe)
	}
}

OnCodeGenAddPreOpCompoundOperand : integer operand
{
	FindLastPreOpAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, operand)
}

FindLastPreOpAndAppendCompoundMemberHelper : CodeBlock ref codeblock, integer operand
{
	FindLastPreOpAndAppendCompoundMember(codeblock.Entries, codeblock.Entries.next, operand)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastPreOpAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist, 0
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}


GetLargestSumTypeBaseSize : integer typeid -> integer size = FindSumTypeAndGetBaseMaxSize(SumTypes, typeid) [nogc]

FindSumTypeAndGetBaseMaxSize : list<SumType> ref sumtypes, integer typeid -> integer size = 0 [nogc]
{
	if(sumtypes.value.Type == typeid)
	{
		GetBaseMaxSize(sumtypes.value.Bases, size)
	}
	else
	{
		size = FindSumTypeAndGetBaseMaxSize(sumtypes.next, typeid)
	}
}

FindSumTypeAndGetBaseMaxSize : nothing, integer typeid -> 0 [nogc]


GetBaseMaxSize : list<SumTypeBase> ref basetypes, integer ref outsize [nogc]
{
	integer typename = basetypes.value.Name
	if(typename != 0)
	{
		integer thissize = GetTypeSize(typename)
		if(thissize > outsize)
		{
			outsize = thissize
		}
	}

	GetBaseMaxSize(basetypes.next, outsize)
}

GetBaseMaxSize : nothing, integer ref outsize [nogc]


OnCodeGenShiftParameter :
{
	if(InFuncRetHack)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}
	elseif(PeekContext(ContextStack, 1) != STACK_TYPE_SUBSTATEMENT)
	{
		FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
	}
	else
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

PeekContext : list<ContextStackEntry> ref stack, integer depth -> integer peek = STACK_TYPE_GLOBAL
{
	if(depth == 0)
	{
		peek = stack.value.EntryType
	}
	else
	{
		peek = PeekContext(stack.next, depth - 1)
	}
}


CodeGenEmitGlobalBlockPrologue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		EmittingScope.Wrapped = GlobalScope.Wrapped

		OnBytecodeEnterEntity(4, GlobalCodeBlockName)
		CodeGenEmitCodeBlock(block)
		OnBytecodeInvokeOffset(FindHandleInTrie(GlobalStringTrie, "entrypoint"))
		OnBytecodeHalt()
	}
}

CodeGenEmitGlobalBlockEpilogue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeExitEntity()
	}
}


IsStructureType : integer typeid -> boolean ret = false [nogc]
{
	if((typeid & 0x7f000000) == 0x03000000)
	{
		ret = true
	}
	elseif((typeid & 0x7f000000) == 0x08000000)
	{
		ret = true
	}
}

IsReferenceType : integer typeid -> boolean ret = false [nogc]
{
	if((typeid & 0x80000000) != 0)
	{
		ret = true
	}
}

MakeReferenceType : integer typeid -> integer reftypeid = typeid [nogc]
{
	if(!IsReferenceType(typeid))
	{
		reftypeid = typeid + 0x80000000
	}
}

MakeNonReferenceType : integer typeid -> (typeid & 0x7fffffff) [nogc]


append_recurse : list<Variable> ref thelist, nothing, Variable ref value [nogc]
{
	list<Variable> newlist = value, nothing
	thelist.next = newlist
}

append_recurse : list<Variable> ref thelist, list<Variable> ref tail, Variable ref value [nogc]
{
	append_recurse(tail, tail.next, value)
}


append : list<Variable> ref thelist, Variable ref value [nogc]
{
	append_recurse(thelist, thelist.next, value)
}



CodeBlockDepth : list<OptionalCodeBlock> ref stack -> integer count = 0 [nogc]
{
	count = CodeBlockDepth(stack.next) + 1
}

CodeBlockDepth : nothing -> 0 [nogc]



IRProcess : -> boolean success = true
{
	prepend<StructureDefinition>(Structures, dummystruct)		// TODO - why does this need to be here?

	if(!IRTypeInference())
	{
		success = false
		return()
	}
}


GeneratePendingTypeMatchers : list<PendingTypeMatcher> ref pendingmatchers
{
	GeneratePendingTypeMatcher(pendingmatchers.value)
	GeneratePendingTypeMatchers(pendingmatchers.next)
}

GeneratePendingTypeMatchers : nothing

GeneratePendingTypeMatcher : PendingTypeMatcher ref matcher
{
	if(matcher.OverloadName == 0)
	{
		return()
	}

	ContextNode<TypeMatcher> matchwrap = nothing
	if(!GetExistingTypeMatcher(TypeMatchers, matcher.MatcherName, matchwrap))
	{
		OnCodeGenEnterTypeMatcher(matcher.MatcherName)
		OnCodeGenExitContext()
		matchwrap = TypeMatchers.value
	}

	ContextNode<FunctionDefinition> wrap = nothing
	SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, matcher.OverloadName, wrap)

	WalkParametersForTypeMatcherContext(wrap, matchwrap)
}

WalkParametersForTypeMatcherContext : FunctionDefinition ref func, TypeMatcher ref matcher
{
	WalkParametersForTypeMatcher(func.Params, matcher, func.Name)
}


WalkParametersForTypeMatcher : FunctionParams ref params, TypeMatcher ref matcher, integer overloadname
{
	WalkParametersForTypeMatcherUnwrapped(params.Params, matcher, overloadname)
}


WalkParametersForTypeMatcherUnwrapped : list<UnresolvedParameter> ref params, TypeMatcher ref matcher, integer overloadname
{
	if(params.value.NameHandle != 0)
	{
		Parameter p = params.value.NameHandle, params.value.ResolvedType
		FindTMOverloadAndAppendParameter(matcher.Overloads, matcher.Overloads, overloadname, p)
	}

	WalkParametersForTypeMatcherUnwrapped(params.next, matcher, overloadname)
}

WalkParametersForTypeMatcherUnwrapped : nothing, TypeMatcher ref matcher, integer overloadname



DumpTypeList : simplelist<integer> ref types
{
	if(types.value != 0)
	{
		string refflag = ""
		if(IsReferenceType(types.value))
		{
			refflag = " ref"
		}

		print(" Potential type: " ; GetPooledString(GlobalStrings, GetNameOfType(types.value)) ; refflag)
	}

	DumpTypeList(types.next)
}

DumpTypeList : nothing


structure InferenceContext :
	integer ScopeName,
	integer StatementName,
	simplelist<integer> ref ExpectedTypes,
	boolean FunctionReturn,
	integer NumParameters,
	boolean TopLevelStatement,
	boolean Parenthetical,
	ContextWrapper<Scope> ScopeRef,
	ContextWrapper<FunctionDefinition> FuncRef

structure TypePossibilityList :
	simplelist<integer> ref Types,
	boolean Consumed

structure InferencePossibility :
	integer FunctionName,
	list<TypePossibilityList> ref ParameterTypes,
	TypePossibilityList ref ReturnType

structure ExpressionInferenceStackEntry :
	list<InferencePossibility> ref PossibilityList


IRTypeInference : -> boolean success = true
{
	if(!TypeInference(SumTypes, DummyContextForFunctions))
	{
		success = false
	}

	if(!TypeInference(Structures, DummyContextForFunctions))
	{
		success = false
	}

	if(GlobalCodeBlockName != 0)
	{
		ContextWrapper<FunctionDefinition> funcwrap = nothing
		InferenceContext globalcontext = GlobalCodeBlockName, 0, globalemptyintlist, false, 0, false, false, GlobalScope, funcwrap
		if(!TypeInference(GlobalCodeBlock, globalcontext))
		{
			success = false
		}
	}

	if(!TypeInference(Functions, DummyContextForFunctions))
	{
		success = false
	}
}

TypeInference : nothing, InferenceContext ref context -> true


TypeInference : list<SumType> ref sumtypes, InferenceContext ref context -> boolean success = true
{
	if(sumtypes.value.Type != 0)
	{
		if(!sumtypes.value.IsTemplate)
		{
			if(!ResolveSumTypeBases(sumtypes.value.Bases))
			{
				success = false
			}
		}
	}

	if(!TypeInference(sumtypes.next, context))
	{
		success = false
	}
}

ResolveSumTypeBases : list<SumTypeBase> ref bases -> boolean success = true
{
	if(bases.value.Name != 0)
	{
		integer resolvedtype = ResolveSingleBase(bases.value, bases.value.TemplateArgs)

		if(resolvedtype == 0)
		{
			print("Sum type has unknown base type")
			success = false
		}

		bases.value.Name = resolvedtype
	}

	if(!ResolveSumTypeBases(bases.next))
	{
		success = false
	}
}

ResolveSumTypeBases : nothing -> true

ResolveSingleBase : SumTypeBase ref base, nothing -> integer ret = GetTypeByName(base.Name)
ResolveSingleBase : SumTypeBase ref base, TemplateArgumentList ref args -> integer ret = GetTypeByName(InstantiateStructureTemplate(base.Name, args))


TypeInference : list<StructureDefinition> ref structures, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(structures.value, context))
	{
		success = false
	}

	if(!TypeInference(structures.next, context))
	{
		success = false
	}
}

TypeInference : StructureDefinition ref structuredef, InferenceContext ref context -> boolean success = true
{
	if(structuredef.Name == 0)
	{
		return()
	}

	if(structuredef.IsTemplate)
	{
		return()
	}

	if(!TypeInference(structuredef.Members, context))
	{
		success = false
	}

	integer ctorname = PoolStringFast(structuredef.ReadableName ; "@@constructor")
	integer anonname = PoolStringFast(structuredef.ReadableName ; "@@anonconstructor")
	integer copyname = PoolStringFast(structuredef.ReadableName ; "@@copyconstructor")
	OnCodeGenRegisterConstructors(structuredef.Name, ctorname, anonname, copyname)

	Overload selfoverload = structuredef.Name, ctorname, nothing
	prepend<Overload>(AutoGenOverloads, selfoverload)

	Overload anonoverload = ctorname, anonname, nothing
	prepend<Overload>(AutoGenOverloads, anonoverload)

	Overload copyoverload = ctorname, copyname, nothing
	prepend<Overload>(AutoGenOverloads, copyoverload)
}


TypeInference : list<StructureMember> ref members, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(members.value, context))
	{
		success = false
	}

	if(!TypeInference(members.next, context))
	{
		success = false
	}
}

TypeInference : StructureMemberVariable ref memvar, InferenceContext ref context -> boolean success = true
{
	if(memvar.Name == 0)
	{
		return()
	}

	integer pretype = memvar.Type
	memvar.Type = GetTypeByName(InstantiateStructureTemplate(memvar.TypeNameHandle, memvar.TemplateArgs))
	if(memvar.Type == 0)
	{
		memvar.Type = GetTypeByName(memvar.TypeNameHandle)
	}

	if(memvar.Type == 0)
	{
		print("Type not recognized: " ; GetPooledString(GlobalStrings, memvar.TypeNameHandle))
		success = false
	}
	else
	{
		memvar.Type = memvar.Type + pretype			// Hack to accept reference marker
	}
}

TypeInference : StructureMemberFunctionRef ref memfunc, InferenceContext ref context -> boolean success = true
{
	ResolveSignatureTypes(memfunc.Signature)
}


TypeInference : list<FunctionDefinition> ref functions, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(functions.value, context))
	{
		success = false
	}

	if(!TypeInference(functions.next, context))
	{
		success = false
	}
}


TypeInference : FunctionDefinition ref func, InferenceContext ref context -> boolean success = true
{
	if(func.IsTemplate)
	{
		return()
	}

	if(func.InferenceDone)
	{
		return()
	}

	func.InferenceDone = true

	ContextWrapper<Scope> scopewrap = func.AttachedScope.Wrapped
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext innercontext = func.Name, 0, globalemptyintlist, false, 0, false, false, scopewrap, funcwrap


	if(!TypeInference(func.Params, innercontext))
	{
		print("Parameters to function failed type inference")
		success = false
	}

	
	InferenceContext retcontext = func.Name, 0, globalemptyintlist, true, 0, false, false, innercontext.ScopeRef, funcwrap
	if(!TypeInference(func.Return, retcontext))
	{
		print("Function return expression failed type inference")
		success = false
	}

	integer rettype = GetOptionalExpressionType(func.Return)
	if((rettype != 0) && (rettype != 0x00000002))	// void magic
	{
		if(func.AnonymousReturn)
		{
			StoreVariableInSingleScope(innercontext.ScopeRef.Wrapped, PooledStringHandleForAnonymousRet, rettype, false, 2)
		}
	}

	if(!TypeInference(func.Code, innercontext))
	{
		print(GetPooledString(GlobalStrings, func.Name) ; "() - Function code body failed type inference")
		success = false
	}
}

TypeInference : FunctionParams ref params, InferenceContext ref context -> boolean success = TypeInference(params.Params, context)

TypeInference : list<UnresolvedParameter> ref params, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(params.value, context))
	{
		success = false
	}

	if(!TypeInference(params.next, context))
	{
		success = false
	}
}

TypeInference : UnresolvedParameter ref param, InferenceContext ref context -> boolean success = true
{
	if((param.ResolvedType & 0x7f000000) == 0x09000000)
	{
		StoreVariableInSingleScope(context.ScopeRef.Wrapped, param.NameHandle, param.ResolvedType, false, 1)
		return()
	}

	integer patternmatchtype = GetOptionalExpressionType(param.PatternMatchValue)
	if(patternmatchtype != 0)
	{
		param.ResolvedType = patternmatchtype
		return()
	}

	param.TypeNameHandle = MangleTemplateNameByHandle(param.TypeNameHandle, param.TemplateArgs)

	param.ResolvedType = GetTypeByName(param.TypeNameHandle)
	if(param.ResolvedType == 0)
	{
		print("Unknown parameter type: " ; GetPooledString(GlobalStrings, param.TypeNameHandle))
		success = false
	}
	else
	{
		if(param.HasRefTag)
		{
			param.ResolvedType = param.ResolvedType + 0x80000000
		}

		StoreVariableInSingleScope(context.ScopeRef.Wrapped, param.NameHandle, param.ResolvedType, false, 1)
	}
}

TypeInference : CodeBlock ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.Entries, context))
	{
		success = false
	}
}

TypeInference : list<CodeBlockEntry> ref code, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(code.value, context))
	{
		success = false
	}

	if(!TypeInference(code.next, context))
	{
		success = false
	}
}


TypeInference : PreOpStatement ref statement, InferenceContext ref context -> boolean success = true
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Operand.value, var)

	if(var.Name == 0)
	{
		print("Cannot operate on variable, it doesn't exist!")
		assert(false)
	}

	integer operandtype = MakeNonReferenceType(var.VarType)

	if(countnonzero(statement.Operand) > 1)
	{
		assertmsg(operandtype != 0, "Pre-operation statement has no type")
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}

	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype		// TODO - maybe don't assume that the operator returns the same type as it takes?
}


TypeInference : PostOpStatement ref statement, InferenceContext ref context -> boolean success = true
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Operand.value, var)

	if(var.Name == 0)
	{
		print("Cannot operate on variable, it doesn't exist!")
		assert(false)
	}

	integer operandtype = MakeNonReferenceType(var.VarType)

	if(countnonzero(statement.Operand) > 1)
	{
		assertmsg(operandtype != 0, "Post-operation statement has no type")
		operandtype = ComputeCompoundAssignmentLHSTypeMembers(statement.Operand.next, GetNameOfType(operandtype))
	}

	statement.Operator = FindPrePostOperatorOverload(statement.Operator, operandtype)
	statement.Type = operandtype
}


TypeInference : Statement ref statement, InferenceContext ref context -> boolean success = true
{
	if(statement.InferenceDone)
	{
		return()
	}

	statement.InferenceDone = true

	integer originalname = statement.Name
	statement.Name = InstantiateTemplateFast(statement.Name, statement.TemplateArgs)

	integer paramcount = CountExpressions(statement.Parameters)

	integer vartype = GetTypeByName(statement.Name)
	if(vartype != 0)
	{
		integer origin = 0
		if(context.FunctionReturn)
		{
			origin = 2
			SetFunctionReturnType(context.FuncRef.Wrapped, context.ScopeName, vartype)
		}

		while((vartype & 0x7f000000) == 0x05000000)
		{
			vartype = FindTypeAliasBase(TypeAliases, vartype)
		}

		if(IsStructureType(vartype))
		{
			statement.Name = GetConstructorName(Structures, vartype)
		}
		else
		{
			assertmsg(vartype != 0, "Assumption failure in statement type inference")
			statement.Name = GetNameOfType(vartype)
		}

		if(statement.TopLevel)
		{
			ConstructVariableFromStatement(statement, context.ScopeRef.Wrapped, vartype, origin)
		}
	}

	InferenceContext newcontext = context.ScopeName, statement.Name, context.ExpectedTypes, false, paramcount, statement.TopLevel, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(statement.Parameters, newcontext))
	{
		success = false
		print("Type inference failed for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
	}


	ContextNode<FunctionDefinition> contextfunc = nothing
	ContextNode<PendingTypeMatcher> contextmatch = nothing
	boolean isuserfunc = false


	if(statement.Name == PooledStringHandleForCast)
	{
		statement.Name = GetCastOverload(statement.Parameters)

		if(statement.Name == 0)
		{
			success = false
			print("Invalid cast()")
		}
	}
	else
	{
		if(IsRecognizedBuiltIn(statement.Name))
		{
			isuserfunc = false
		}
		else
		{
			isuserfunc = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, statement.Name, contextfunc)
		}

		simplelist<integer> paramtypes = 0, nothing
		AccumulateParameterTypes(paramtypes, statement.Parameters)

		integer overloadname = 0

		if(isuserfunc)
		{
			overloadname = FindOverloadWithParameterTypesFast(contextfunc, statement.Name, paramtypes)
		}
		else
		{
			overloadname = FindOverloadWithParameterTypes(AutoGenOverloads, statement.Name, paramtypes)
		}

		if(overloadname != 0)
		{
			statement.Name = overloadname

			if(IsRecognizedBuiltIn(statement.Name))
			{
				isuserfunc = false
			}
			else
			{
				isuserfunc = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, statement.Name, contextfunc)
			}
		}
		else
		{
			Variable var = 0, 0, 0, 0
			FindVariableDataInSingleScope(context.ScopeRef.Wrapped, statement.Name, var)

			if((var.Name != 0) && ((var.VarType & 0x7f000000) == 0x09000000))
			{
				// TODO - type checking on higher order functions

				statement.Type = GetSignatureReturnType(FunctionSignatures, var.VarType)
				return()
			}		
		
			success = false
			print("No matching overload for call to " ; GetPooledString(GlobalStrings, statement.Name) ; "()")
		}
	}

	if(context.FunctionReturn)
	{
		statement.Type = vartype
	}
	else
	{
		if(isuserfunc)
		{
			statement.Type = InferFunctionReturnType(contextfunc)
		}
		else
		{
			statement.Type = GetPendingTypeMatcherReturnType(statement.Name, contextmatch)
		}
	}

	if(isuserfunc)
	{
		WalkFunctionParamsAndSetReferencesShim(contextfunc, statement.Parameters)
	}
	else
	{
		MakeParametersReferencesForTypeMatcher(statement.Name, statement.Parameters)
	}

	if(vartype != 0)
	{
		if(isuserfunc)
		{
			AnnotateTypeMatchedParamsForWrapper(contextfunc, statement.Parameters)
		}
		else
		{
			FindConstructorAndAnnotateTypeMatchedParams(Structures, statement.Name, statement.Parameters)
		}
	}
	elseif(ContextHasTypeMatcher(contextmatch))
	{
		AnnotateAllParameters(statement.Parameters, originalname, 0, paramcount, statement.TopLevel)
	}
}


ContextHasTypeMatcher : PendingTypeMatcher ref matcher -> true [nogc]
ContextHasTypeMatcher : nothing -> false [nogc]


FindOverloadWithParameterTypesFast : FunctionDefinition ref func, integer rawname, simplelist<integer> ref paramtypes -> integer overloadname = rawname
{
	overloadname = FindOverloadWithParameterTypes(func.Overloads, rawname, paramtypes)
}


AnnotateTypeMatchedParamsForWrapper : FunctionDefinition ref func, OptionalExpressionList ref exprs
{
	AnnotateTypeMatchedParamsForWrapperUnwrap(func, exprs)
}

AnnotateTypeMatchedParamsForWrapperUnwrap : FunctionDefinition ref func, ExpressionList ref exprs
{
	AnnotateTypeMatchedParams(func.Params, exprs.Expressions)
}

AnnotateTypeMatchedParamsForWrapperUnwrap : FunctionDefinition ref func, nothing


CountExpressions : nothing -> 0 [nogc]

CountExpressions : ExpressionList ref exprs -> integer count = CountExpressions(exprs.Expressions) [nogc]

CountExpressions : list<Expression> ref exprs -> integer count = 1 [nogc]
{
	count += CountExpressions(exprs.next)
}


DumpAllOverloadParameters : list<Overload> ref overloads, integer rawname
{
	if(overloads.value.NormalName == rawname)
	{
		DumpFunctionParameters(Functions, overloads.value.MangledName)
	}

	DumpAllOverloadParameters(overloads.next, rawname)
}

DumpAllOverloadParameters : nothing, integer rawname


DumpFunctionParameters : list<FunctionDefinition> ref functions, integer funcname
{
	if(functions.value.Name == funcname)
	{
		print(GetPooledString(GlobalStrings, funcname))
		DumpUnresolvedParameters(functions.value.Params)
	}
	else
	{
		DumpFunctionParameters(functions.next, funcname)
	}
}

DumpFunctionParameters : nothing, integer funcname


AnnotateAllParameters : ExpressionList ref exprs, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	AnnotateAllParameters(exprs.Expressions, statementname, paramindex, paramcount, toplevel)
}

AnnotateAllParameters : list<Expression> ref params, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	elseif(IsRefBind(params.value.Atoms.value))
	{
		TypeAnnotationAtom atom = 5
		ExpressionAtom wrap = atom
		AppendAtomToExpression(params.value.Atoms, params.value.Atoms.next, wrap)
	}

	AnnotateAllParameters(params.next, statementname, paramindex + 1, paramcount, toplevel)
}

AnnotateAllParameters : nothing, integer statementname, integer paramindex, integer paramcount, boolean toplevel


AnyTypeIsReferenceType : simplelist<integer> ref types -> boolean isref = false [nogc]
{
	if(IsReferenceType(types.value))
	{
		isref = true
	}
	else
	{
		isref = AnyTypeIsReferenceType(types.next)
	}
}

AnyTypeIsReferenceType : nothing -> false [nogc]


AnnotateNonReferenceParameters : ExpressionList ref exprs [nogc]
{
	AnnotateNonReferenceParameters(exprs.Expressions)
}

AnnotateNonReferenceParameters : list<Expression> ref params [nogc]
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	AnnotateNonReferenceParameters(params.next)
}

AnnotateNonReferenceParameters : nothing [nogc]



AddTypeAnnotation : nothing [nogc]

AddTypeAnnotation : list<Expression> ref params [nogc]
{
	AddTypeAnnotation(params.value)
}

AddTypeAnnotation : Expression ref expr [nogc]
{
	integer typeid = expr.Type
	TypeAnnotationAtom atom = typeid
	ExpressionAtom wrap = atom
	AppendAtomToExpression(expr.Atoms, expr.Atoms.next, wrap)
}


AccumulateParameterTypes : simplelist<integer> ref types, OptionalExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrap(types, exprs)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, ExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.Expressions, types)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, nothing [nogc]

AccumulateParameterTypesUnwrapped : list<Expression> ref exprs, simplelist<integer> ref types [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.next, types)
	simpleprepend<integer>(types, exprs.value.Type)
}

AccumulateParameterTypesUnwrapped : nothing, simplelist<integer> ref types [nogc]


FindOverloadWithParameterTypes : list<Overload> ref overloads, integer rawname, simplelist<integer> ref types -> integer overloadname = rawname
{
	if(overloads.value.NormalName == rawname)
	{
		if(!IsFunctionTemplate(overloads.value.Implementation))
		{
			if(FunctionWrapperMatchesParameterTypes(overloads.value.Implementation, overloads.value.MangledName, types))
			{
				integer matchername = CheckForNeededPatternMatcher(PendingPatternMatchers, rawname)
				if(matchername != 0)
				{
					overloadname = matchername
				}
				else
				{
					overloadname = overloads.value.MangledName
				}
				return()
			}
			elseif(countnonzero(types) == GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName))
			{
				if(CheckForNeededTypeMatcher(types))
				{
					overloadname = FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName, overloads.value.Implementation)
					FindOverloadWithParameterTypes(overloads.next, rawname, types)
					return()
				}
			}
		}
	}

	overloadname = FindOverloadWithParameterTypes(overloads.next, rawname, types)
}

GetFunctionWrapperParameterCount : FunctionDefinition ref func, integer mangledname -> integer count = 0
{
	count = CountUnresolvedParameters(func.Params)
}

GetFunctionWrapperParameterCount : nothing, integer mangledname -> integer count = 0
{
	count = GetFunctionParameterCount(mangledname)
}


PopulateAllOverloadTypeMatchers : list<Overload> ref overloads, integer rawname, integer paramcount
{
	if(paramcount == GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName))
	{
		if(!IsFunctionTemplateFast(overloads.value.MangledName))
		{
			FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName, overloads.value.Implementation)
		}
	}

	PopulateAllOverloadTypeMatchers(overloads.next, rawname, paramcount)
}

PopulateAllOverloadTypeMatchers : nothing, integer rawname, integer paramcount


IsFunctionTemplate : FunctionDefinition ref func -> boolean istemplate = func.IsTemplate [nogc]
IsFunctionTemplate : nothing -> false [nogc]


IsFunctionTemplateFast : integer name -> boolean istemplate = false [nogc]
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, name, wrap)
	if(!found)
	{
		assert(false)
	}

	istemplate = IsFunctionTemplate(wrap)
}


GenerateTypeMatcherMappings : list<FunctionDefinition> ref functions
{
	if(functions.value.Name != 0)
	{
		if(!functions.value.IsTemplate)
		{
			integer rawname = functions.value.RawName
			integer paramcount = CountUnresolvedParameters(functions.value.Params)

			if(AnyPendingTypeMatcherPointsToAnyOverload(functions.value.Overloads, rawname, paramcount))
			{
				PopulateAllOverloadTypeMatchers(functions.value.Overloads, rawname, paramcount)
			}
		}
	}

	GenerateTypeMatcherMappings(functions.next)
}

GenerateTypeMatcherMappings : nothing


AnyPendingTypeMatcherPointsToAnyOverload : list<Overload> ref overloads, integer rawname, integer paramcount -> boolean ret = false
{
	if(GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName) == paramcount)
	{
		if(SearchBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloads.value.MangledName))
		{
			ret = true
			return()
		}
	}

	ret = AnyPendingTypeMatcherPointsToAnyOverload(overloads.next, rawname, paramcount)
}

AnyPendingTypeMatcherPointsToAnyOverload : nothing, integer rawname, integer paramcount -> boolean ret = false



GetFunctionParameterCount : integer funcname -> integer count = -1 [nogc]
{
	if(funcname == PooledStringHandleForSubstringWithLength)
	{
		count = 3
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		count = 2
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		count = 2
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		count = 1
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		count = 3
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		count = 4
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		count = 4
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		count = 3
	}
}

CountUnresolvedParameters : FunctionParams ref params -> integer count = CountUnresolvedParametersUnwrapped(params.Params) [nogc]
CountUnresolvedParameters : nothing -> 0 [nogc]

CountUnresolvedParametersUnwrapped : list<UnresolvedParameter> ref params -> integer count = 0 [nogc]
{
	if(params.value.NameHandle != 0)
	{
		++count
	}
	elseif(GetOptionalExpressionType(params.value.PatternMatchValue) != 0)
	{
		++count
	}

	count += CountUnresolvedParametersUnwrapped(params.next)
}

CountUnresolvedParametersUnwrapped : nothing -> 0 [nogc]


CheckForNeededTypeMatcher : simplelist<integer> ref types -> boolean needsmatcher = false
{
	if((types.value & 0x7f000000) == 0x07000000)
	{
		needsmatcher = true
	}
	else
	{
		needsmatcher = CheckForNeededTypeMatcher(types.next)
	}
}

CheckForNeededTypeMatcher : nothing -> false


FindOverloadWithParameterTypes : nothing, integer rawname, simplelist<integer> ref types -> integer overloadname = 0
{
	if(rawname == PooledStringHandleForSubstring)
	{
		integer withlen = PooledStringHandleForSubstringWithLength
		integer nolen = PooledStringHandleForSubstringNoLength

		if(FunctionMatchesParameterTypes(nothing, withlen, types))
		{
			overloadname = withlen
		}
		elseif(FunctionMatchesParameterTypes(nothing, nolen, types))
		{
			overloadname = nolen
		}
	}
	elseif(rawname == PooledStringHandleForWriteBuffer)
	{
		integer normal = PooledStringHandleForWriteBuffer
		integer withstr = PooledStringHandleForWriteBufferString
		integer multiple = PooledStringHandleForWriteBufferMultiple
		integer withreal = PooledStringHandleForWriteBufferReal

		if(FunctionMatchesParameterTypes(nothing, normal, types))
		{
			overloadname = normal
		}
		elseif(FunctionMatchesParameterTypes(nothing, withstr, types))
		{
			overloadname = withstr
		}
		elseif(FunctionMatchesParameterTypes(nothing, multiple, types))
		{
			overloadname = multiple
		}
		elseif(FunctionMatchesParameterTypes(nothing, withreal, types))
		{
			overloadname = withreal
		}
	}
	elseif(IsRecognizedBuiltIn(rawname))
	{
		overloadname = rawname
	}
	else
	{
		boolean matchesctor = false
		if(ConstructorMatchesParameterTypes(Structures, rawname, types, matchesctor))
		{
			overloadname = rawname
		}
		else
		{	// TODO - this is a sloppy hack to work around the fact that operators don't short circuit properly yet
			if(!matchesctor)
			{
				if(!SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, rawname))
				{
					overloadname = rawname
				}
			}
		}
	}
}


FunctionWrapperMatchesParameterTypes : FunctionDefinition ref func, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = CheckParameterTypesForMatch(func.Params, types)
}

FunctionWrapperMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = FunctionMatchesParameterTypes(Functions, funcname, types)
}


FunctionMatchesParameterTypes : list<FunctionDefinition> ref functions, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, funcname, wrap)
	if(found)
	{
		match = CheckParameterTypesForMatch(wrap, types)
	}
	else
	{
		match = FunctionMatchesParameterTypes(nothing, funcname, types)
	}
}

FunctionMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	if(funcname == PooledStringHandleForSubstringWithLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		simplelist<integer> ptypes = 0x01000004, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		simplelist<integer> ptypes = 0x02000000, nothing
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	else
	{
		boolean ignored = false
		match = ConstructorMatchesParameterTypes(Structures, funcname, types, ignored)
	}
}


ConstructorMatchesParameterTypes : list<StructureDefinition> ref structures, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> boolean match = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}

		match = CheckMemberTypes(structures.value.Members, types.next)
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		matchesctor = true
		match = CheckMemberTypes(structures.value.Members, types)
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}

		match = CheckCopyType(types.next, structures.value.Type)
	}
	else
	{
		match = ConstructorMatchesParameterTypes(structures.next, ctorname, types, matchesctor)
	}
}

ConstructorMatchesParameterTypes : nothing, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> false


CheckCopyType : simplelist<integer> ref a, integer b -> boolean match = (a.value == b)


CheckParameterTypesForMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	integer count = countnonzero(types)
	if(count == 0)
	{
		match = true
	}
	elseif(count == 1)
	{
		if(types.value == 0x00000002)		// void type signature
		{
			match = true
		}
	}
}

CheckParameterTypesForMatch : FunctionDefinition ref func, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(func.Params, types)
CheckParameterTypesForMatch : FunctionParams ref params, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(params.Params, types)


CheckParameterTypesForMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	if(!ResolvedTypesMatch(params, types))
	{
		match = false
	}
}

CheckParameterTypesForMatch : simplelist<integer> ref atypes, simplelist<integer> ref btypes -> boolean match = TypesMatch(atypes, btypes)


DumpUnresolvedParameters : list<UnresolvedParameter> ref params
{
	print(GetPooledString(GlobalStrings, GetNameOfType(params.value.ResolvedType)))
	DumpUnresolvedParameters(params.next)
}

DumpUnresolvedParameters : nothing


TypesMatch : simplelist<integer> ref a, simplelist<integer> ref b -> boolean match = true
{
	if(a.value != b.value)
	{
		match = false
	}
	else
	{
		match = TypesMatch(a.next, b.next)
	}
}

TypesMatch : nothing, nothing -> true

TypesMatch : nothing, simplelist<integer> ref b -> boolean match = (b.value == 0)
TypesMatch : simplelist<integer> ref a, nothing -> boolean match = (a.value == 0)



ResolvedTypesMatch : nothing, nothing -> true

ResolvedTypesMatch : list<UnresolvedParameter> ref params, nothing -> false
ResolvedTypesMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}

ResolvedTypesMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	integer resolved = params.value.ResolvedType
	while((resolved & 0x7f000000) == 0x05000000)
	{
		resolved = FindTypeAliasBase(TypeAliases, resolved)
	}

	integer expected = types.value
	while((expected & 0x7f000000) == 0x0500000)
	{
		expected = FindTypeAliasBase(TypeAliases, expected)
	}

	if(resolved != expected)
	{
		match = false
		return()
	}


	listnode<UnresolvedParameter> n = params.next
	simplelistnode<integer> nt = types.next
	match = ResolvedTypesMatch(n, nt)			// TODO - this is some kind of compiler bug... or maybe a runtime bug?!
}


GetAssignmentRHSType : Expression ref expr -> integer rettype = expr.Type
GetAssignmentRHSType : Assignment ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)
GetAssignmentRHSType : AssignmentCompound ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)


TypeInference : Assignment ref assignment, InferenceContext ref context -> boolean success = true
{
	integer vartype = GetVariableTypeFromScope(context.ScopeRef.Wrapped, assignment.LHSName)
	if(vartype == 0)
	{
		success = false
		print("Assignment to non-existent variable " ; GetPooledString(GlobalStrings, assignment.LHSName))
		return()
	}

	simplelist<integer> temp = vartype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}

	assignment.LHSType = vartype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?

		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}

	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : AssignmentCompound ref assignment, InferenceContext ref context -> boolean success = true
{
	integer lhstype = ComputeCompoundAssignmentLHSType(assignment, context.ScopeRef.Wrapped)

	simplelist<integer> temp = lhstype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}

	assignment.LHSType = lhstype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?

		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}

	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : EntityChain ref chain, InferenceContext ref context -> boolean success = TypeInference(chain.Entries, context)

TypeInference : EntityList ref entities, InferenceContext ref context -> boolean success = TypeInference(entities.ActualList, context)

TypeInference : list<Entity> ref entities, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(entities.value, context))
	{
		success = false
	}

	if(!TypeInference(entities.next, context))
	{
		success = false
	}
}

TypeInference : Entity ref entity, InferenceContext ref context -> boolean success = true
{
	simplelist<integer> temp = 0x01000003, nothing			// TODO - don't assume all entities take a boolean!
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(entity.Param, newcontext))
	{
		success = false
	}

	if(!TypeInference(entity.Code, context))
	{
		success = false
	}
}


TypeInference : ExpressionList ref parameters, InferenceContext ref context -> boolean success = true
{
	boolean hasallparams = false

	if((context.NumParameters > 0) && (!IsRecognizedBuiltIn(context.StatementName)))
	{
		ParameterTypeList dummyparaminfo = globalemptyintlist
		list<ParameterTypeList> paramtypeinfo = dummyparaminfo, nothing

		integer i = 1
		while(i < context.NumParameters)
		{
			ParameterTypeList dummyparaminfo2 = globalemptyintlist
			prepend<ParameterTypeList>(paramtypeinfo, dummyparaminfo2)

			++i
		}

		hasallparams = GatherAllPossibleParamTypes(context.StatementName, context.NumParameters, context.TopLevelStatement, paramtypeinfo)
	}

	if(!TypeInferenceExpressionList(parameters.Expressions, context, 0, hasallparams, paramtypeinfo))
	{
		success = false
	}
}


GatherAllPossibleParamTypes : integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	ContextNode<FunctionDefinition> wrap = nothing
	found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, funcname, wrap)
	if(found)
	{
		InferAllFunctionParameterTypes(wrap, numparams, toplevel, outinfo)
		EnumerateOverloadsAndAddAllParameterTypes(wrap, numparams, toplevel, outinfo)
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(Structures, funcname, numparams, toplevel, outinfo)
	}
}

GatherAllPossibleParamTypesForConstructor : list<StructureDefinition> ref structures, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	if(structures.value.ConstructorName == funcname)
	{
		integer membercount = structures.value.MemberCount
		if(numparams == (membercount + 1))
		{
			simpleprepend<integer>(outinfo.value.Types, 0x01000000)		// Identifier type signature
			ExtractAllMemberTypes(structures.value.Members, outinfo.next)
			found = true
		}

		if(numparams == membercount)
		{
			ExtractAllMemberTypes(structures.value.Members, outinfo)
			found = true
		}

		if(numparams == 2)
		{
			AddTypeToParamTypeList(outinfo, 0x01000000)			// Identifier type signature
			AddTypeToParamTypeList(outinfo.next, structures.value.Type)
			found = true
		}
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(structures.next, funcname, numparams, toplevel, outinfo)
	}
}

GatherAllPossibleParamTypesForConstructor : nothing, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> false


AddTypeToParamTypeList : list<ParameterTypeList> ref outinfo, integer ty
{
	simpleprepend<integer>(outinfo.value.Types, ty)
}

ExtractAllMemberTypes : list<StructureMember> ref members, list<ParameterTypeList> ref outinfo
{
	simpleprepend<integer>(outinfo.value.Types, GetMemberTypeDecompose(members.value))
	ExtractAllMemberTypes(members.next, outinfo.next)
}

ExtractAllMemberTypes : nothing, nothing


EnumerateOverloadsAndAddAllParameterTypes : FunctionDefinition ref func, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	EnumerateOverloadsAndAddAllParameterTypes(func.Overloads, numparams, toplevel, outinfo)
}

EnumerateOverloadsAndAddAllParameterTypes : list<Overload> ref overloads, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	AddAllParameterTypesForOverloadImplementation(overloads.value.Implementation, overloads.value.MangledName, numparams, toplevel, outinfo)
	EnumerateOverloadsAndAddAllParameterTypes(overloads.next, numparams, toplevel, outinfo)
}

EnumerateOverloadsAndAddAllParameterTypes : nothing, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo


AddAllParameterTypesForOverloadImplementation : FunctionDefinition ref function, integer mangledname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	InferAllFunctionParameterTypes(function, numparams, toplevel, outinfo)
}

AddAllParameterTypesForOverloadImplementation : nothing, integer mangledname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo


InferAllFunctionParameterTypes : FunctionDefinition ref function, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}

	UnwrapAllParamsForTypeRetrieval(function.Params, numparams, outinfo)
}


UnwrapAllParamsForTypeRetrieval : FunctionParams ref params, integer paramcount, list<ParameterTypeList> ref outinfo
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveAllParamTypes(params.Params, outinfo)
	}
}

UnwrapAllParamsForTypeRetrieval : nothing, integer paramcount, list<ParameterTypeList> ref outinfo


RetrieveAllParamTypes : list<UnresolvedParameter> ref params, list<ParameterTypeList> ref outinfo [nogc]
{
	simpleprepend<integer>(outinfo.value.Types, params.value.ResolvedType)
	RetrieveAllParamTypes(params.next, outinfo.next)
}

RetrieveAllParamTypes : nothing, nothing [nogc]


GrabTypeListAtIndex : list<ParameterTypeList> ref paraminfo, integer paramindex, simplelist<integer> ref out [nogc]
{
	if(paramindex == 0)
	{
		out = paraminfo.value.Types
		return()
	}

	GrabTypeListAtIndex(paraminfo.next, paramindex - 1, out)
}


TypeInferenceExpressionList : list<Expression> ref parameters, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true
{
	simplelist<integer> temp = 0, nothing

	if(hasallparams)
	{
		GrabTypeListAtIndex(paraminfo, paramindex, temp)
	}
	else
	{
		GetExpectedParameterTypes(context.StatementName, paramindex, context.NumParameters, context.TopLevelStatement, temp)
	}

	InferenceContext newcontext = context.ScopeName, context.StatementName, temp, context.FunctionReturn, context.NumParameters, context.TopLevelStatement, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(parameters.value, newcontext))
	{
		print("Parameter " ; cast(string, paramindex) ; " failed type inference!")
		success = false
	}
	else
	{
		context.StatementName = newcontext.StatementName
	}

	if(!TypeInferenceExpressionList(parameters.next, context, paramindex + 1, hasallparams, paraminfo))
	{
		success = false
	}
}

TypeInferenceExpressionList : nothing, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true


countatoms : list<ExpressionAtom> ref atoms -> integer count = 1 + countatoms(atoms.next)
countatoms : nothing -> 0


TypeInference : Expression ref expression, InferenceContext ref context -> boolean success = true
{
	if(expression.Type != 0)
	{
		return()
	}

	if(ExpressionAtomIsSentinel(expression.Atoms.value))
	{
		expression.Type = 0x00000002
		return()
	}

	if(countatoms(expression.Atoms) > 1)
	{
		CoalesceMemberAccesses(expression.Atoms, context.ScopeRef.Wrapped)
		ShuntingYard(expression.Atoms)
		
		InferencePossibility temp = 0, scratchparampossibles, scratchreturns
		list<InferencePossibility> possibilities = temp, nothing
		ExpressionInferenceStackEntry stackentry = possibilities
		list<ExpressionInferenceStackEntry> stack = stackentry, nothing

		integer counter = 0

		WalkAtomsForType(expression.Atoms, expression.Atoms.next, stack, counter, context)

		integer possibilitycount = CountPossibilities(stack.value.PossibilityList)
		if(possibilitycount == 1)
		{
			if((!context.FunctionReturn) && (context.StatementName != 0))
			{
				simplelist<integer> types = 0, nothing
				integer typecount = EliminateImpossibleType(stack.value.PossibilityList.value.ReturnType.Types, context.ExpectedTypes, types)

				if(typecount == 1)
				{
					assertmsg(types.value != 0, "Inferred a non-type!")
					expression.Type = types.value
				}
				elseif(typecount > 1)
				{
					print("Multiple types possible:")
					DumpTypeList(types)
				}
				else
				{
					// TODO - demotion logic here is MESSY
					if((countnonzero(stack.value.PossibilityList.value.ReturnType.Types) == 1) && (countnonzero(context.ExpectedTypes) == 1) && (stack.value.PossibilityList.value.ReturnType.Types.value == 0x01000001) && (context.ExpectedTypes.value == 0x01000002))
					{
						expression.Type = 0x01000002
					}
					else
					{
						print("All types ruled out")
						DumpTypeList(stack.value.PossibilityList.value.ReturnType.Types)
						print("Expected types are")
						DumpTypeList(context.ExpectedTypes)
					}
				}
			}
			else
			{
				simplelist<integer> possibletypes = 0, nothing
				FilterTypesForDemotion(stack.value.PossibilityList.value.ReturnType.Types, possibletypes)

				integer typecount = countnonzero(possibletypes)
				if(typecount == 1)
				{
					expression.Type = possibletypes.value
					assertmsg(expression.Type != 0, "Ruled out all types but a non-type!")
				}
				elseif(context.FunctionReturn)
				{
					print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
					DumpTypeList(possibletypes)
				}
				else
				{
					print("Expression has " ; cast(string, typecount) ; " types possible")
					DumpTypeList(possibletypes)
				}
			}
		}
		else
		{
			// TODO - error context!
			if(possibilitycount > 0)
			{
				print("Multiple overloads possible:")
				DumpOverloadList(stack.value.PossibilityList)
			}
			else
			{
				print("No types possible in this expression:")
				DumpExpressionAtoms(expression.Atoms)
				print("End expression")
			}
		}
	}
	else
	{
		simplelist<integer> possibletypes = 0, nothing
		TypePossibilityList poss = possibletypes, false
		GetAtomType(expression.Atoms.value, poss, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		if((!context.FunctionReturn) && (context.StatementName != 0))
		{
			simplelist<integer> types = 0, nothing
			integer typecount = EliminateImpossibleType(poss.Types, context.ExpectedTypes, types)

			if(typecount == 1)
			{
				expression.Type = types.value
			}
			elseif(typecount > 1)
			{
				print("Multiple types possible:")
				DumpTypeList(types)
			}
			else
			{
				print("Can't figure out type of expression atom!")
				success = false
			}
		}
		else
		{
			simplelist<integer> filtered = 0, nothing
			FilterTypesForDemotion(poss.Types, filtered)

			integer typecount = countnonzero(filtered)
			if(typecount == 1)
			{
				expression.Type = filtered.value
				assertmsg(expression.Type != 0, "Ruled out all types but a non-type!")
			}
			elseif(context.FunctionReturn)
			{
				print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
				DumpTypeList(filtered)
			}
			else
			{
				print("Expression has " ; cast(string, typecount) ; " types possible")
				DumpTypeList(filtered)
			}
		}
	}

	if(expression.Type == 0)
	{
		success = false
	}
	elseif(expression.Type == 0x01000002)
	{
		DemoteAtomType(expression.Atoms)
	}
	elseif((expression.Type & 0x7f000000) == 0x09000000)
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
	elseif(IsStructureType(expression.Type))
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
}


CountPossibilities : list<InferencePossibility> ref thelist -> integer count = 0 [nogc]
{
	if(thelist.value.FunctionName != 0)
	{
		++count
	}

	count += CountPossibilities(thelist.next)
}

CountPossibilities : nothing -> 0 [nogc]


countnonzero : simplelist<integer> ref thelist -> integer count = 0 [nogc]
{
	if(thelist.value != 0)
	{
		++count
	}

	count += countnonzero(thelist.next)
}

countnonzero : nothing -> 0 [nogc]


SetAtomType : IdentifierAtom ref atom, integer typeid [nogc]
{
	atom.Type = typeid
}

SetAtomType : CompoundAtom ref atom, integer typeid [nogc]
{
	atom.Type = typeid
}

SetAtomType : Statement ref atom, integer typeid [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	boolean didrightdemote = WalkAtomsForType(tail, tail.next, stack, counter, context)
	boolean unarycompensate = false

	if(IsOperatorInvoke(tail.value))
	{
		if(IsUnaryOperator(tail.value))
		{
			SetOperatorAtomToOverload(tail, stack.value.PossibilityList.value.FunctionName, 0)
			unarycompensate = true
		}
	}

	if(IsOperatorInvoke(atoms.value))
	{
		if(counter > 0)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter + 1)
			--counter
		}

		list<InferencePossibility> possibleoperators = scratchpossibility, nothing
		GetAtomTypeOperator(atoms.value, possibleoperators)

		ExpressionInferenceStackEntry entry = possibleoperators
		prepend<ExpressionInferenceStackEntry>(stack, entry)
	}
	else
	{
		list<InferencePossibility> out = scratchpossibility, nothing
		EliminateImpossibleParametersForAllOverloads(stack.value.PossibilityList, out, atoms.value, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		if(counter == 1)
		{
			list<InferencePossibility> filtered = scratchpossibility, nothing
			FilterOverloadsForTypeDemotion(out, filtered)
			stack.value.PossibilityList = filtered
		}
		else
		{
			stack.value.PossibilityList = out
		}

		if(CountPossibilities(stack.value.PossibilityList) == 1)
		{
			if(listcontains(stack.value.PossibilityList.value.ParameterTypes.value.Types, 0x01000002))
			{
				DemoteAtomType(atoms)
				demotedtoright = true

				if((!didrightdemote) && (!IsOperatorInvoke(tail.value)))
				{
					DemoteAtomType(tail)
				}
			}
		}
		elseif(didrightdemote)
		{
			DemoteAtomType(atoms)
		}

		++counter
		if(counter > 1)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter)
			++counter
		}

		if(AllOptionsConsumed(stack.value.PossibilityList.value.ParameterTypes))
		{
			stack.value.PossibilityList.value.ReturnType.Consumed = true
			CopyReturnTypeToParamTypes(stack, stack.next)
		}
	}

	if(unarycompensate)
	{
		++counter
	}
}


CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail
{
	AddPossibleParamTypeForAllOverloads(tail.value.PossibilityList, stack.value.PossibilityList.value.ReturnType)
	PopExpressionInferenceStack(stack, tail)
}

CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, nothing



AddPossibleParamTypeForAllOverloads : list<InferencePossibility> ref possibilities, TypePossibilityList ref paramtypes
{
	prepend<TypePossibilityList>(possibilities.value.ParameterTypes, paramtypes)

	AddPossibleParamTypeForAllOverloads(possibilities.next, paramtypes)
}

AddPossibleParamTypeForAllOverloads : nothing, TypePossibilityList ref paramtypes


AllOptionsConsumed : list<TypePossibilityList> ref options -> boolean allconsumed = true [nogc]
{
	if(!options.value.Consumed)
	{
		if(countnonzero(options.value.Types) > 0)
		{
			allconsumed = false
		}
		else
		{
			allconsumed = AllOptionsConsumed(options.next)
		}
	}
	else
	{
		allconsumed = AllOptionsConsumed(options.next)
	}
}

AllOptionsConsumed : nothing -> true [nogc]


PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail [nogc]
{
	stack = tail
}

PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, nothing [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, nothing, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	if(IsOperatorInvoke(atoms.value))
	{
		GetAtomTypeOperator(atoms.value, stack.value.PossibilityList)
	}
	else
	{
		TypePossibilityList poss = scratchpossibletypes, false
		InferencePossibility newpossibility = -1, scratchparampossibles, poss
		GetAtomType(atoms.value, newpossibility.ReturnType, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		prepend<InferencePossibility>(stack.value.PossibilityList, newpossibility)
	}
}


EliminateImpossibleParametersForAllOverloads : list<InferencePossibility> ref possibilities, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(possibilities.value.FunctionName != 0)
	{
		if(EliminateImpossibleParameters(possibilities.value.ParameterTypes, atom, scope, func, funcret, parenthetical))
		{
			prepend<InferencePossibility>(out, possibilities.value)
		}
	}

	EliminateImpossibleParametersForAllOverloads(possibilities.next, out, atom, scope, func, funcret, parenthetical)
}

EliminateImpossibleParametersForAllOverloads : nothing, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical


EliminateImpossibleParameters : list<TypePossibilityList> ref params, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> boolean valid = true
{
	if(!params.value.Consumed)
	{
		TypePossibilityList poss = scratchpossibletypes, false
		GetAtomType(atom, poss, scope, func, funcret, parenthetical)

		simplelist<integer> types = 0, nothing
		integer typecount = EliminateImpossibleType(params.value.Types, poss.Types, types)

		if(typecount == 0)
		{
			valid = false
		}

		params.value.Types = types
		params.value.Consumed = true
	}
	else
	{
		if(!EliminateImpossibleParameters(params.next, atom, scope, func, funcret, parenthetical))
		{
			valid = false
		}
	}
}


EliminateImpossibleParameters : nothing, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> true


SetOperatorAtomToOverload : list<ExpressionAtom> ref atoms, integer overloadname, integer count [nogc]
{
	if(count == 0)
	{
		ChangeOperator(atoms.value, overloadname)
	}
	else
	{
		SetOperatorAtomToOverload(atoms.next, overloadname, count - 1)
	}
}

ChangeOperator : OperatorInvokeAtom ref atom, integer overloadname [nogc]
{
	atom.OperatorName = overloadname
}



EliminateImpossibleType : simplelist<integer> ref possibles, simplelist<integer> ref filter, simplelist<integer> ref out -> integer count = 0 [nogc]
{
	count = EliminateImpossibleType(possibles.next, filter, out)

	if(possibles.value != 0)
	{
		integer expectedtype = TypeListContains(filter, possibles.value)
		if(expectedtype != 0)
		{
			count = count + 1
			simpleprepend<integer>(out, expectedtype)
		}
	}
}

EliminateImpossibleType : nothing, simplelist<integer> ref filter, simplelist<integer> ref out -> 0 [nogc]


GetAtomType : AtomSentinel       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x00000002) }	// void magic
GetAtomType : StringHandleAtom   ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x02000000) }
GetAtomType : TypeAnnotationAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000001) }
GetAtomType : integer16          ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000002) }
GetAtomType : boolean            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000003) }
GetAtomType : real               ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000004) }

GetAtomType : integer            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	AddPossibleParameter(possibilities.Types, 0x01000001)
	AddPossibleParameter(possibilities.Types, 0x01000002)			// Allow demotion later
}

GetAtomType : CompoundAtom       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, atom.Type)  }

GetAtomType : Statement ref statement, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	ContextWrapper<Scope> scopewrap = scope
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext newcontext = scope.Name, statement.Name, globalemptyintlist, funcret, 0, false, false, scopewrap, funcwrap

	if(TypeInference(statement, newcontext))
	{
		AddPossibleParameter(possibilities.Types, statement.Type)
	}
}

GetAtomType : RefBinding ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical

GetAtomType : ParentheticalExpression ref parenthetical, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean isinparenthetical
{
	ContextWrapper<Scope> scopewrap = scope
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext newcontext = scope.Name, 0, globalemptyintlist, funcret, 0, false, true, scopewrap, funcwrap

	if(TypeInference(parenthetical.Inner, newcontext))
	{
		AddPossibleParameter(possibilities.Types, GetParentheticalType(parenthetical.Inner))
	}
	else
	{
		print("Parenthetical expression failed type inference")
	}
}

GetParentheticalType : PreOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : PostOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : Expression ref expr -> integer rettype = expr.Type [nogc]

GetAtomTypeOperator : OperatorInvokeAtom ref atom, list<InferencePossibility> ref possibilities
{
	AddPossibilityPerOperatorOverload(atom.OperatorName, possibilities)
}

GetAtomType : IdentifierAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(atom.Handle == PooledStringHandleForNothing)
	{
		atom.Type = 0x00000004
		AddPossibleParameter(possibilities.Types, 0x00000004)
		return()
	}

	if((!parenthetical) && (!funcret))
	{
		AddPossibleParameter(possibilities.Types, 0x01000000)
	}

	integer nametype = GetTypeByName(atom.Handle)
	if(nametype != 0)
	{
		if(IsStructureType(nametype))
		{
			if(FunctionIsAutoGenOrHasIR(atom.Handle))
			{
				atom.IsFunction = true
			}
		}

		return()
	}


	integer vartype = GetVariableTypeFromScope(scope, atom.Handle)
	if(vartype != 0)
	{
		AddPossibleParameter(possibilities.Types, vartype)
		if((vartype & 0x7f000000) == 0x09000000)
		{
			atom.IsFunction = true
		}
	}
	else
	{
		if(SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, atom.Handle))
		{
			atom.IsFunction = true

			// TODO - overload resolution on higher order function name
			integer sigtype = FindFunctionAndGetSignatureType(Functions, atom.Handle)
			AddPossibleParameter(possibilities.Types, sigtype)
		}
		else
		{
			integer sigtype = FindBuiltinAndGetSignatureType(atom.Handle)
			if(sigtype != 0)
			{
				AddPossibleParameter(possibilities.Types, sigtype)
			}
			else
			{
				print(GetPooledString(GlobalStrings, atom.Handle) ; " is not a defined identifier!")
			}
		}
	}
}


IsOperatorInvoke : OperatorInvokeAtom 	   ref nonsentinel -> true [nogc]

IsOperatorInvoke : AtomSentinel 	   ref sentinel    -> false [nogc]
IsOperatorInvoke : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : IdentifierAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : integer 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : integer16 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : boolean 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : real 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : Statement		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : RefBinding              ref nonsentinel -> false [nogc]
IsOperatorInvoke : CompoundAtom		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : ParentheticalExpression ref nonsentinel -> false [nogc]


IsRefBind : IdentifierAtom ref atom -> atom.IsReference [nogc]
IsRefBind : RefBinding ref atom -> true [nogc]
IsRefBind : CompoundAtom		   ref nonsentinel -> boolean ret = true [nogc]
{
	if(!IsReferenceType(nonsentinel.Type))
	{
		ret = false
	}
}

IsRefBind : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
IsRefBind : AtomSentinel 	   ref sentinel    -> false [nogc]
IsRefBind : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsRefBind : integer 		   ref nonsentinel -> false [nogc]
IsRefBind : integer16 		   ref nonsentinel -> false [nogc]
IsRefBind : boolean 		   ref nonsentinel -> false [nogc]
IsRefBind : real 		   ref nonsentinel -> false [nogc]
IsRefBind : Statement		   ref nonsentinel -> false [nogc]
IsRefBind : ParentheticalExpression ref nonsentinel -> false [nogc]
IsRefBind : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]


IsTypeAnnotationAtom : TypeAnnotationAtom 	   ref nonsentinel -> true [nogc]

IsTypeAnnotationAtom : AtomSentinel 	   ref sentinel    -> false [nogc]
IsTypeAnnotationAtom : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : IdentifierAtom 	   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : integer 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : integer16 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : boolean 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : real 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : Statement		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : RefBinding              ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : CompoundAtom		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : ParentheticalExpression ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]



IsMemberAccessOperator : OperatorInvokeAtom 	 ref nonsentinel -> boolean ismemberaccess = false [nogc]
{
	if(nonsentinel.OperatorName == PooledStringHandleForMemberAccess)
	{
		ismemberaccess = true
	}
}

IsMemberAccessOperator : AtomSentinel 	   	 ref sentinel    -> false [nogc]
IsMemberAccessOperator : StringHandleAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : IdentifierAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : TypeAnnotationAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : integer 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : integer16 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : boolean 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : real 		   	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : Statement		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : RefBinding              ref nonsentinel -> false [nogc]
IsMemberAccessOperator : CompoundAtom            ref nonsentinel -> false [nogc]
IsMemberAccessOperator : ParentheticalExpression ref nonsentinel -> false [nogc]



MarkAtomAsReference : OperatorInvokeAtom      ref atom -> false [nogc]
MarkAtomAsReference : AtomSentinel 	      ref atom -> false [nogc]
MarkAtomAsReference : StringHandleAtom 	      ref atom -> false [nogc]
MarkAtomAsReference : TypeAnnotationAtom      ref atom -> false [nogc]
MarkAtomAsReference : integer 		      ref atom -> false [nogc]
MarkAtomAsReference : integer16               ref atom -> false [nogc]
MarkAtomAsReference : boolean 		      ref atom -> false [nogc]
MarkAtomAsReference : real 		      ref atom -> false [nogc]
MarkAtomAsReference : Statement		      ref atom -> false [nogc]
MarkAtomAsReference : ParentheticalExpression ref atom -> false [nogc]

MarkAtomAsReference : RefBinding              ref atom -> true [nogc]

MarkAtomAsReference : IdentifierAtom          ref atom -> true [nogc]
{
	atom.IsReference = true
}

MarkAtomAsReference : CompoundAtom            ref atom -> true [nogc]
{
	atom.Type = MakeReferenceType(atom.Type)
}


AddPossibleParameter : simplelist<integer> ref possibilities, integer paramtype [nogc]
{
	simpleprepend<integer>(possibilities, paramtype)

	if((paramtype & 0x7f000000) == 0x05000000)
	{
		simpleprepend<integer>(possibilities, FindTypeAliasBase(TypeAliases, paramtype))
	}
}

AddBinaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer param2type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing
	simplelist<integer> p2t = param2type, nothing

	TypePossibilityList param1options = p1t, false
	TypePossibilityList param2options = p2t, false

	list<TypePossibilityList> paramtypes = param2options, nothing
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}

AddUnaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing

	TypePossibilityList param1options = p1t, false

	list<TypePossibilityList> paramtypes = param1options, nothing

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}


ShuntingYard : list<ExpressionAtom> ref atoms
{
	AtomSentinel sentinel = 0

	list<ExpressionAtom> outputqueue = sentinel, nothing
	list<ExpressionAtom> opstack = sentinel, nothing

	ShuntingYardWalk(atoms, outputqueue, opstack)
	ShuntingYardFlush(outputqueue, opstack)

	atoms = outputqueue
}

ShuntingYardWalk : nothing, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack

ShuntingYardWalk : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	ShuntingYardVisit(atoms.value, outputqueue, opstack)
	ShuntingYardWalk(atoms.next, outputqueue, opstack)
}

ShuntingYardVisit : AtomSentinel            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
ShuntingYardVisit : StringHandleAtom        ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : IdentifierAtom          ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : TypeAnnotationAtom      ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer16               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : boolean                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : real                    ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : Statement               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : RefBinding              ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : ParentheticalExpression ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : CompoundAtom            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }

ShuntingYardVisit : OperatorInvokeAtom ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	integer opprec = GetOperatorPrecedence(atom)
	boolean continueops = true

	while(continueops && (!ExpressionAtomIsSentinel(opstack.value)))
	{
		ExpressionAtom opatom2 = opstack.value
		integer op2prec = GetOperatorPrecedence(opatom2)

		// TODO - this whole section is hacky. Replace with break() calls and >= operator.

		if(IsUnaryOperator(atom))
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
			elseif(opprec == op2prec)
			{
				continueops = false
			}
		}
		else
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
		}

		if(continueops)
		{
			PlaceAtomInList(outputqueue, opatom2)
			ShuntingYardPopStack(opstack, opstack.next)
		}
	}

	ExpressionAtom wrap = atom
	prepend<ExpressionAtom>(opstack, wrap)
}

ShuntingYardFlush : list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	while(!ExpressionAtomIsSentinel(opstack.value))
	{
		PlaceAtomInList(outputqueue, opstack.value)
		ShuntingYardPopStack(opstack, opstack.next)
	}
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, list<ExpressionAtom> ref tail [nogc]
{
	opstack = tail
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, nothing [nogc]
{
	AtomSentinel sentinel = 0
	list<ExpressionAtom> newlist = sentinel, nothing
	opstack = newlist
}


IsUnaryOperator : OperatorInvokeAtom ref atom -> boolean isunary = false [nogc]
{
	if(atom.OperatorName == PooledStringHandleForUnaryNot)
	{
		isunary = true
	}
}


GetOperatorPrecedence : OperatorInvokeAtom ref atom -> integer precedence = 0 [nogc]
{
	if(atom.OperatorName == PooledStringHandleForEquality)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForInequality)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForGreaterThan)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForLessThan)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForBooleanAnd)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForBitwiseAnd)
	{
		precedence = 1		// TODO - revisit all operator precedences
	}
	elseif(atom.OperatorName == PooledStringHandleForStringConcat)
	{
		precedence = 3
	}
	elseif(atom.OperatorName == PooledStringHandleForPlus)
	{
		precedence = 5
	}
	elseif(atom.OperatorName == PooledStringHandleForMinus)
	{
		precedence = 5
	}
	elseif(atom.OperatorName == PooledStringHandleForMultiply)
	{
		precedence = 9
	}
	elseif(atom.OperatorName == PooledStringHandleForDivide)
	{
		precedence = 9
	}
	elseif(atom.OperatorName == PooledStringHandleForUnaryNot)
	{
		precedence = 10
	}
	elseif(atom.OperatorName == PooledStringHandleForMemberAccess)
	{
		precedence = 11
	}
	else
	{
		print("Unknown operator " ; GetPooledString(GlobalStrings, atom.OperatorName))
		assert(false)
	}
}


ConstructVariableFromStatement : Statement ref statement, Scope ref scope, integer vartype, integer origin
{
	integer varname = ExtractConstructorIdentifier(statement.Parameters)

	if(varname != 0)
	{
		// TODO - do real shadowing checks here
		Variable var = 0, 0, 0, 0
		FindVariableDataInSingleScope(scope, varname, var)
		if(var.Name != 0)
		{
			return()
		}

		StoreVariableInSingleScope(scope, varname, vartype, false, origin)
	}
}

ExtractConstructorIdentifier : ExpressionList ref parameters -> integer varname = ExtractConstructorIdentifier(parameters.Expressions)
ExtractConstructorIdentifier : list<Expression> ref parameters -> integer varname = ExtractIdentifier(parameters.value)
ExtractConstructorIdentifier : nothing -> 0

ExtractIdentifier : Expression ref expression -> integer id = ExtractIdentifier(expression.Atoms.value) [nogc]

ExtractIdentifier : IdentifierAtom ref atom -> atom.Handle [nogc]
{
	atom.Type = 0x81000000		// HACK - reference to identifier
}

ExtractIdentifier : AtomSentinel 	    ref sentinel    -> 0 [nogc]
ExtractIdentifier : StringHandleAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : OperatorInvokeAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : TypeAnnotationAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : integer 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : integer16 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : boolean 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : real 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : Statement		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : RefBinding              ref nonsentinel -> 0 [nogc]
ExtractIdentifier : CompoundAtom            ref nonsentinel -> 0 [nogc]
ExtractIdentifier : ParentheticalExpression ref nonsentinel -> 0 [nogc]


PlaceAtomInList : list<ExpressionAtom> ref atoms, ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(atoms.value))
	{
		atoms.value = atom
	}
	else
	{
		AppendAtomToExpression(atoms, atoms.next, atom)
	}
}



PoolString : string s -> integer handle = FindHandleInTrie(GlobalStringTrie, s) [nogc]
{
	if(handle == 0)
	{
		handle = PoolStringFast(s)
	}
}

PoolStringFast : string s -> integer handle = 0 [nogc]
{
	++CurrentStringHandle
	OnCodeGenRegisterString(CurrentStringHandle, s)
	handle = CurrentStringHandle
}


IREnterFunction : integer namehandle
{
	OnCodeGenRegisterScope(namehandle, 0)
}

IRExitFunction :
{
	OnCodeGenExitContext()
}


IREnterStatement : string funcname, boolean istoplevel, boolean hastemplateargs
{
	integer namehandle = PoolString(funcname)
	OnCodeGenEnterStatement(namehandle, 0, istoplevel, hastemplateargs)
}

IRExitStatement :
{
	OnCodeGenExitContext()
}


IRAddOperator : string operatorname
{
	OnCodeGenRegisterOperatorInvoke(PoolString(operatorname))
}

IRAddLiteralString : string literal
{
	OnCodeGenRegisterLiteralString(PoolString(literal))
}

IRAddLiteralBoolean : boolean literal
{
	OnCodeGenRegisterLiteralBoolean(literal)
}

IRAddLiteralReal : real literal
{
	OnCodeGenRegisterLiteralReal(literal)
}

IRAddLiteralInteger : integer literal
{
	OnCodeGenRegisterLiteralInteger(literal, 0x01000001)		// We can demote the integer later
}

IRAddLiteralIdentifier : string token
{
	OnCodeGenRegisterAtomIdentifier(PoolString(token), 0)
}



GetPooledString : list<StringTableEntry> ref strings, integer handle -> string pooled = "" [nogc]
{
	if(strings.value.Handle == handle)
	{
		pooled = strings.value.Data
	}
	else
	{
		pooled = GetPooledString(strings.next, handle)
	}
}

GetPooledString : nothing, integer handle -> "" [nogc]
{
	print("String handle not pooled: " ; cast(string, handle))
	assert(false)
}


DumpAtom : AtomSentinel 	   ref sentinel    { print("Sentinel") }
DumpAtom : StringHandleAtom 	   ref nonsentinel { print("String handle " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : IdentifierAtom 	   ref nonsentinel { print("Identifier " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : OperatorInvokeAtom 	   ref nonsentinel { print("Operator " ; cast(string, nonsentinel.OperatorName)) }
DumpAtom : TypeAnnotationAtom 	   ref nonsentinel { print("Type annotation") }
DumpAtom : integer 		   ref nonsentinel { print("integer " ; cast(string, nonsentinel)) }
DumpAtom : integer16 		   ref nonsentinel { print("integer16") }
DumpAtom : boolean 		   ref nonsentinel { print("boolean") }
DumpAtom : real 		   ref nonsentinel { print("real " ; cast(string, nonsentinel)) }
DumpAtom : RefBinding              ref nonsentinel { print("RefBinding") }
DumpAtom : ParentheticalExpression ref nonsentinel { print("Parenthetical") }
DumpAtom : CompoundAtom            ref nonsentinel { print("Compound") }

DumpAtom : Statement		   ref nonsentinel
{
	print("Statement " ; GetPooledString(GlobalStrings, nonsentinel.Name))
	print("BEGIN PARAMS")
	DumpParameterAtoms(nonsentinel.Parameters)
	print("END PARAMS")
}

DumpExpressionAtoms : list<ExpressionAtom> ref atoms
{
	DumpAtom(atoms.value)
	DumpExpressionAtoms(atoms.next)
}

DumpExpressionAtoms : nothing


DumpExpressionList : list<Expression> ref exprs
{
	print("BEGIN EXPR")
	DumpExpressionAtoms(exprs.value.Atoms)
	print("END EXPR")

	DumpExpressionList(exprs.next)
}

DumpExpressionList : nothing


DumpParameterAtoms : ExpressionList ref exprs
{
	DumpExpressionList(exprs.Expressions)
}

DumpParameterAtoms : nothing



AddPossibilityPerOperatorOverload : integer basenamehandle, list<InferencePossibility> ref possibilities
{
	if(basenamehandle == PooledStringHandleForEquality)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityInteger,   0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityInteger16, 0x01000002, 0x01000002, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityBoolean,   0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityReal,      0x01000004, 0x01000004, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityString,    0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForInequality)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityInteger, 0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityBoolean, 0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityString,  0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForGreaterThan)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForGreaterThanInteger, 0x01000001, 0x01000001, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForLessThan)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForLessThanInteger, 0x01000001, 0x01000001, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForPlus)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForPlusInteger, 0x01000001, 0x01000001, 0x01000001)
		AddBinaryPossibility(possibilities, PooledStringHandleForPlusReal, 0x01000004, 0x01000004, 0x01000004)
	}
	elseif(basenamehandle == PooledStringHandleForMinus)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForMinusInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForMultiply)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForMultiplyInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForDivide)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForDivideInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForBitwiseAnd)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForBitwiseAnd, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForBooleanAnd)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForBooleanAnd, 0x01000003, 0x01000003, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForStringConcat)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForStringConcat, 0x02000000, 0x02000000, 0x02000000)
	}
	elseif(basenamehandle == PooledStringHandleForUnaryNot)
	{
		AddUnaryPossibility(possibilities, PooledStringHandleForUnaryNotBoolean, 0x01000003, 0x01000003)
	}
	else
	{
		print("Unrecognized operator")
		assert(false)
	}
}


GetExpectedParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(funcname, paramindex, paramcount, toplevel, types)
	EnumerateOverloadsAndAddParameterTypes(AutoGenOverloads, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : list<Overload> ref overloads, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(overloads.value.NormalName == funcname)
	{
		AddParameterTypesForOverloadImplementation(overloads.value.Implementation, overloads.value.MangledName, paramindex, paramcount, toplevel, types)
	}

	EnumerateOverloadsAndAddParameterTypes(overloads.next, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types


AddParameterTypesForOverloadImplementation : FunctionDefinition ref func, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!func.InferenceDone)
	{
		TypeInference(func, DummyContextForFunctions)
	}

	UnwrapParamsForTypeRetrieval(func.Params, paramindex, paramcount, types)
}

AddParameterTypesForOverloadImplementation : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(funcname, paramindex, paramcount, toplevel, types)
}


InferFunctionParameterTypes : FunctionDefinition ref function, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}

	UnwrapParamsForTypeRetrieval(function.Params, paramindex, paramcount, types)
}

FindFunctionAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!FindConstructorAndAddParameterTypes(Structures, funcname, paramindex, paramcount, toplevel, types))
	{
		FindBuiltinAndAddParameterTypes(funcname, paramindex, paramcount, types)
	}
}

UnwrapParamsForTypeRetrieval : FunctionParams ref params, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveParamType(params.Params, paramindex, types)
	}
}

UnwrapParamsForTypeRetrieval : nothing, integer paramindex, integer paramcount, simplelist<integer> ref types


RetrieveParamType : list<UnresolvedParameter> ref params, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{
		simpleprepend<integer>(types, params.value.ResolvedType)
		return()
	}

	RetrieveParamType(params.next, paramindex - 1, types)
}

RetrieveParamType : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many parameters to call!")
	assert(false)
}


InferFunctionReturnType : PendingTypeMatcher ref pending -> integer rettype = InferFunctionReturnType(pending.OverloadImplementation)

InferFunctionReturnType : FunctionDefinition ref func -> integer rettype = 0
{
	if(!func.InferenceDone)
	{
		TypeInference(func, DummyContextForFunctions)
	}

	rettype = GetOptionalExpressionType(func.Return)
}


GetFunctionReturnType : list<FunctionDefinition> ref functions, integer funcname -> integer rettype = 0
{
	if(functions.value.Name == funcname)
	{
		rettype = InferFunctionReturnType(functions.value)
	}
	else
	{
		rettype = GetFunctionReturnType(functions.next, funcname)
	}
}

GetFunctionReturnType : nothing, integer funcname -> integer rettype = 0
{
	ContextNode<PendingTypeMatcher> ignored = nothing
	rettype = GetPendingTypeMatcherReturnType(funcname, ignored)
}


GetOptionalExpressionType : Expression ref expr -> expr.Type [nogc]
GetOptionalExpressionType : nothing -> 0 [nogc]


FindBuiltinAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	integer ctype = GetTypeByName(funcname)
	if((ctype & 0x7f000000) == 0x05000000)
	{
		funcname = GetNameOfType(FindTypeAliasBase(TypeAliases, ctype))
	}

	if((ctype & 0x7f000000) == 0x07000000)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				FindSumTypeAndPrependTypesToList(SumTypes, ctype, types)
			}
		}
		return()
	}

	if(funcname == PooledStringHandleForPassTest)
	{
		// No parameters
	}
	elseif(funcname == PooledStringHandleForAssert)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForPrint)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForInteger16)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForBoolean)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForReal)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForBuffer)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForNarrowString)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubstringWithLength)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastBooleanToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastRealToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastRealToString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastStringToReal)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastIntegerToString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastStringToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastInteger16ToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastIntegerToInteger16)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		if(paramcount == 4)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 3)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		if(paramcount == 4)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 3)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForLength)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWidenFromPtr)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCmdLineGet)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCmdLineGetCount)
	{
		// no params
	}
	elseif(funcname == PooledStringHandleForCmdLineIsValid)
	{
		// no params
	}
}


PrependSumTypeBases : simplelist<integer> ref input, list<SumTypeBase> ref newentries [nogc]
{
	simpleprepend<integer>(input, newentries.value.Name)
	PrependSumTypeBases(input, newentries.next)
}

PrependSumTypeBases : simplelist<integer> ref input, nothing [nogc]


FindSumTypeAndPrependTypesToList : list<SumType> ref sumtypes, integer sumtypeid, simplelist<integer> ref types [nogc]
{
	if(sumtypes.value.Type == sumtypeid)
	{
		PrependSumTypeBases(types, sumtypes.value.Bases)
	}
	else
	{
		FindSumTypeAndPrependTypesToList(sumtypes.next, sumtypeid, types)
	}
}


FindConstructorAndAddParameterTypes : list<StructureDefinition> ref structures, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> boolean hit = false
{
	integer membercount = structures.value.MemberCount

	if((structures.value.ConstructorName == funcname) && (paramcount == membercount + 1))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		else
		{
			FindMemberAndAddParameterTypes(structures.value.Members, paramindex - 1, types)
		}
		hit = true
	}
	elseif((structures.value.AnonConstructorName == funcname) && (paramcount == membercount))
	{
		FindMemberAndAddParameterTypes(structures.value.Members, paramindex, types)
		hit = true
	}
	elseif((toplevel) && (structures.value.CopyConstructorName == funcname) && (paramcount == 2))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		elseif(paramindex == 1)
		{
			simpleprepend<integer>(types, structures.value.Type)
		}
		hit = true
	}
	else
	{
		hit = FindConstructorAndAddParameterTypes(structures.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindConstructorAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> false


FindMemberAndAddParameterTypes : list<StructureMember> ref members, integer paramindex, simplelist<integer> ref types [nogc]
{
	if(paramindex == 0)
	{
		AddParameterTypesForMember(members.value, types)
	}
	else
	{
		FindMemberAndAddParameterTypes(members.next, paramindex - 1, types)
	}
}

FindMemberAndAddParameterTypes : nothing, integer paramindex, simplelist<integer> ref types [nogc]
{
	print("Too many arguments to constructor")
	assert(false)
}


AddParameterTypesForMember : StructureMemberVariable ref memvar, simplelist<integer> ref types [nogc]
{
	simpleprepend<integer>(types, memvar.Type)
}

AddParameterTypesForMember : StructureMemberFunctionRef ref memfunc, simplelist<integer> ref types [nogc]
{
	simpleprepend<integer>(types, GetMemberTypeDecompose(memfunc))
}


GetConstructorName : list<StructureDefinition> ref structures, integer typeid -> integer name = 0 [nogc]
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.ConstructorName
	}
	else
	{
		name = GetConstructorName(structures.next, typeid)
	}
}


StructureConstructorExists : list<StructureDefinition> ref structures, integer ctorname -> boolean exists = false [nogc]
{
	if(structures.value.ConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		exists = true
	}
	else
	{
		exists = StructureConstructorExists(structures.next, ctorname)
	}
}

StructureConstructorExists : nothing, integer ctorname -> false [nogc]


CoalesceMemberAccesses : list<ExpressionAtom> ref atoms, Scope ref scope
{
	while(SearchForMemberAccessStart(atoms, atoms.next, scope))
	{
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, list<ExpressionAtom> ref current, Scope ref scope -> boolean found = false
{
	if(IsMemberAccessOperator(current.value))
	{
		CoalesceMemberAccessTriplet(previous, current, current.next, scope)
		found = true
	}
	else
	{
		found = SearchForMemberAccessStart(current, current.next, scope)
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, nothing, Scope ref scope -> false


CoalesceMemberAccessTriplet : list<ExpressionAtom> ref lhs, list<ExpressionAtom> ref op, list<ExpressionAtom> ref rhs, Scope ref scope
{
	CoalesceMemberAccessAtoms(lhs, lhs.value, rhs.value, scope)
	lhs.next = rhs.next
}

CoalesceMemberAccessAtoms : list<ExpressionAtom> ref lhslist, ExpressionAtom ref lhs, ExpressionAtom ref rhs, Scope ref scope
{
	CoalesceMemberAccessAtomsUnwrapped(lhslist, lhs, rhs, scope)
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, IdentifierAtom ref lhs, IdentifierAtom ref rhs, Scope ref scope
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(scope, lhs.Handle, var)

	if(var.Name == 0)
	{
		print("Member access is bogus!")
		assert(false)
	}

	assert(var.VarType != 0)
	integer lhstypename = GetNameOfType(var.VarType)

	integer rhstype = GetStructureMemberType(lhstypename, rhs.Handle)
	if(rhstype == 0)
	{
		print(GetPooledString(GlobalStrings, rhs.Handle))
	}
	
	assert(rhstype != 0)
	integer rhstypename = GetNameOfType(rhstype)

	RefBinding lhsbinding = lhs.Handle, lhstypename, false, false
	RefBinding rhsbinding = rhs.Handle, rhstypename, false, false

	list<RefBinding> bindings = rhsbinding, nothing
	prepend<RefBinding>(bindings, lhsbinding)

	CompoundAtom compound = bindings, rhstype
	ExpressionAtom wrap = compound
	lhslist.value = wrap
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, CompoundAtom ref lhs, IdentifierAtom ref rhs, Scope ref scope
{
	assert(lhs.Type != 0)
	integer typename = GetNameOfType(lhs.Type)

	RefBinding temp = rhs.Handle, typename, false, false
	AppendBinding(lhs.Bindings, lhs.Bindings.next, temp)

	lhs.Type = GetStructureMemberType(typename, rhs.Handle)
}

AppendBinding : list<RefBinding> ref bindings, list<RefBinding> ref tail, RefBinding ref binding [nogc]
{
	AppendBinding(tail, tail.next, binding)
}

AppendBinding : list<RefBinding> ref bindings, nothing, RefBinding ref binding [nogc]
{
	list<RefBinding> newtail = binding, nothing
	bindings.next = newtail
}


FindOrCreateTypeMatcher : integer rawname, integer overloadnamehandle, FunctionDefinition ref func -> integer matcherhandle = 0
{
	if(!func.IsTemplate)
	{
		string matchername = func.RawNameString ; "@@typematcher"
		matcherhandle = PoolString(matchername)

		EnsureMatcherIsPending(overloadnamehandle, matcherhandle, func)
	}
}

EnsureMatcherIsPending : integer overloadname, integer matcher, FunctionDefinition ref func [nogc]
{
	boolean found = SearchBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloadname)
	if(found)
	{
		return()
	}

	PendingTypeMatcher m = overloadname, matcher, func
	prepend<PendingTypeMatcher>(PendingTypeMatchers, m)
	InsertIntoBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloadname, m)
	InsertIntoBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matcher, m)
}

GetPendingTypeMatcherReturnType : integer matchername, ContextNode<PendingTypeMatcher> ref outcontext -> integer rettype = 0
{
	boolean found = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matchername, outcontext)
	if(found)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = InferFunctionReturnType(outcontext)
		return()
	}

	rettype = GetPendingPatternMatcherReturnType(PendingPatternMatchers, matchername)
}


GetPendingPatternMatcherReturnType : list<PendingPatternMatcher> ref pending, integer matchername -> integer rettype = 0
{
	if(pending.value.MatcherName == matchername)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = GetFunctionReturnType(Functions, pending.value.OverloadName)
		return()
	}

	rettype = GetPendingPatternMatcherReturnType(pending.next, matchername)
}

GetPendingPatternMatcherReturnType : nothing, integer matchername -> integer typeid = GetBuiltInReturnType(matchername)



GetBuiltInReturnType : integer builtinname -> integer returntype = 0
{
	if(StructureConstructorExists(Structures, builtinname))
	{
		returntype = GetStructureByAnonConstructorName(Structures, builtinname)
		return()
	}

	if(builtinname == PooledStringHandleForNarrowString)
	{
		returntype = 0x02000001		// buffer type signature
	}
	elseif(builtinname == PooledStringHandleForUnescape)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubstringWithLength)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubstringNoLength)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubchar)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastRealToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastBooleanToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastInteger16ToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastIntegerToInteger16)
	{
		returntype = 0x01000002		// integer16 type signature
	}
	elseif(builtinname == PooledStringHandleForCastIntegerToString)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCastRealToString)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCastStringToReal)
	{
		returntype = 0x01000004		// real type signature
	}
	elseif(builtinname == PooledStringHandleForCastStringToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForLength)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineGet)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForWidenFromPtr)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineGetCount)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineIsValid)
	{
		returntype = 0x01000003		// boolean type signature
	}
}


FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, nothing


FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, ExpressionList ref paramexprs
{
	FindConstructorAndAnnotateTypeMatchedParams(Structures, funcname, paramexprs.Expressions)
}

FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, list<Expression> ref paramexprs
{
	if(structures.value.ConstructorName == funcname)
	{
		listnode<Expression> ne = paramexprs.next
		AnnotateTypeMatchedParamsFromConstructor(structures.value.Members, ne)
	}
	else
	{
		FindConstructorAndAnnotateTypeMatchedParams(structures.next, funcname, paramexprs)
	}
}

FindConstructorAndAnnotateTypeMatchedParams : nothing, integer funcname, list<Expression> ref paramexprs
{
	if(SumTypeExists(funcname))
	{
		AnnotateNonReferenceParameters(paramexprs.next)
	}
}


AnnotateTypeMatchedParamsFromConstructor : list<StructureMember> ref members, list<Expression> ref paramexprs
{
	integer membertype = GetMemberTypeDecompose(members.value)
	if((membertype & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(paramexprs.value.Type) != MakeNonReferenceType(membertype))
		{
			AddTypeAnnotation(paramexprs.value)
		}
	}

	listnode<StructureMember> nm = members.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParamsFromConstructor(nm, ne)
}

AnnotateTypeMatchedParamsFromConstructor : nothing, nothing


AnnotateTypeMatchedParams : FunctionParams ref params, list<Expression> ref paramexprs
{
	AnnotateTypeMatchedParams(params.Params, paramexprs)
}

AnnotateTypeMatchedParams : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	if((params.value.ResolvedType & 0x7f000000) == 0x07000000)
	{
		AddTypeAnnotation(paramexprs.value)
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParams(np, ne)
}

AnnotateTypeMatchedParams : nothing, nothing


MakeParametersReferencesUnwrapFast : FunctionDefinition ref function, integer overloadname, ExpressionList ref params
{
	WalkFunctionParamsAndSetReferences(function.Params, params)
}

MakeParametersReferencesForTypeMatcherFast : PendingTypeMatcher ref pending, integer matchername, ExpressionList ref params
{
	if(pending.MatcherName == matchername)
	{
		MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)
	}
}

MakeParametersReferencesUnwrap : PendingTypeMatcher ref pending, ExpressionList ref params
{
	MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
}

MakeParametersReferencesForTypeMatcher : integer matchername, ExpressionList ref params
{
	ContextNode<PendingTypeMatcher> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matchername, wrap)
	if(found)
	{
		MakeParametersReferencesUnwrap(wrap, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)
	}
}


MakeParametersReferencesForConstructor : list<StructureDefinition> ref structures, integer constructorname, ExpressionList ref params
{
	if(structures.value.ConstructorName == constructorname)
	{
		boolean ok = MakeParametersReferencesForStructureMembers(structures.value.Members, params.Expressions.next)
		if(!ok)
		{
			print("Failed to generate call to constructor " ; GetPooledString(GlobalStrings, constructorname))
			assert(false)
		}
	}
	else
	{
		MakeParametersReferencesForConstructor(structures.next, constructorname, params)
	}
}


MakeParametersReferencesForConstructor : nothing, integer constructorname, ExpressionList ref params
{
	MakeParametersReferencesForBuiltIn(constructorname, params)
}

MakeParametersReferencesForBuiltIn : integer funcname, ExpressionList ref params
{
	if(funcname == PooledStringHandleForWriteBuffer)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, list<Expression> ref params -> boolean ret = true
{
	if(IsMemberReferenceType(members.value))
	{
		if(!MarkAtomAsReference(params.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}

	ret = MakeParametersReferencesForStructureMembers(members.next, params.next)
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, nothing -> false
{
	if(GetMemberName(members.value) != 0)
	{
		print("Constructor has too few arguments!")
	}
}

MakeParametersReferencesForStructureMembers : nothing, list<Expression> ref params -> false
{
	print("Constructor has too many arguments!")
}

MakeParametersReferencesForStructureMembers : nothing, nothing -> true



IsMemberReferenceType : StructureMemberVariable ref memvar -> boolean isref = IsReferenceType(memvar.Type) [nogc]
IsMemberReferenceType : StructureMemberFunctionRef ref memfunc -> false [nogc]


WalkFunctionParamsAndSetReferencesShim : FunctionDefinition ref func, OptionalExpressionList ref optexprs
{
	WalkFunctionParamsAndSetReferences(func.Params, optexprs)
}

WalkFunctionParamsAndSetReferences : nothing, ExpressionList ref paramexprs

WalkFunctionParamsAndSetReferences : FunctionParams ref params, ExpressionList ref paramexprs
{
	WalkFunctionParamsAndSetReferencesUnwrapped(params.Params, paramexprs.Expressions)
}


WalkFunctionParamsAndSetReferencesUnwrapped : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	boolean needref = false
	if(IsReferenceType(params.value.ResolvedType))
	{
		needref = true
	}
	elseif(params.value.ResolvedType == 0x00000004)			// TODO - don't assume "nothing" is always passed by ref
	{
		needref = true
	}

	if(needref)
	{
		if(!MarkAtomAsReference(paramexprs.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	WalkFunctionParamsAndSetReferencesUnwrapped(np, ne)
}

WalkFunctionParamsAndSetReferencesUnwrapped : nothing, nothing


DemoteAtomType : list<ExpressionAtom> ref atoms [nogc]
{
	PerformDemotion(atoms, atoms.value)
}

PerformDemotion : list<ExpressionAtom> ref atoms, integer ref atom [nogc]
{
	integer16 newatom = cast(integer16, atom)
	ExpressionAtom wrap = newatom
	atoms.value = wrap
}

PerformDemotion : list<ExpressionAtom> ref atoms, IdentifierAtom ref atom [nogc]

PerformDemotion : list<ExpressionAtom> ref atoms, Statement ref atom [nogc]
{
	assertmsg(atom.Type == 0x01000002, "Failed to demote statement type")
}


DumpOverloadList : list<InferencePossibility> ref possibilities
{
	if(possibilities.value.FunctionName != 0)
	{
		print(GetPooledString(GlobalStrings, possibilities.value.FunctionName))
	}

	DumpOverloadList(possibilities.next)
}

DumpOverloadList : nothing



FilterOverloadsForTypeDemotion : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedOverloads(in, hasdemoted, hassuperior, hasother)

	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedOverloads(in, out)
	}
	else
	{
		out = in
	}
}


FilterTypesForDemotion : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedTypes(in, hasdemoted, hassuperior, hasother)

	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedTypes(in, out)
	}
	else
	{
		out = in
	}
}


CheckIfContainsOnlyDemotedOverloads : list<InferencePossibility> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value == 0x01000001)
		{
			hassuperior = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0x01000002)
		{
			hasdemoted = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0)
		{
		}
		else
		{
			hasother = true
		}
	}

	CheckIfContainsOnlyDemotedOverloads(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedOverloads : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedOverloads : list<InferencePossibility> ref in, list<InferencePossibility> ref out [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value != 0x01000002)
		{
			prepend<InferencePossibility>(out, in.value)
		}
	}

	StripDemotedOverloads(in.next, out)
}

StripDemotedOverloads : nothing, list<InferencePossibility> ref out [nogc]



CheckIfContainsOnlyDemotedTypes : simplelist<integer> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value == 0x01000001)
	{
		hassuperior = true
	}
	elseif(in.value == 0x01000002)
	{
		hasdemoted = true
	}
	elseif(in.value == 0)
	{
	}
	else
	{
		hasother = true
	}

	CheckIfContainsOnlyDemotedTypes(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedTypes : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedTypes : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	if(in.value != 0)
	{
		if(in.value != 0x01000002)
		{
			simpleprepend<integer>(out, in.value)
		}
	}

	StripDemotedTypes(in.next, out)
}

StripDemotedTypes : nothing, simplelist<integer> ref out [nogc]


InitBuiltInOverloads : [nogc]
{
	Overload substrlength = PooledStringHandleForSubstring, PooledStringHandleForSubstringWithLength, nothing
	prepend<Overload>(AutoGenOverloads, substrlength)

	Overload substrnolen = PooledStringHandleForSubstring, PooledStringHandleForSubstringNoLength, nothing
	prepend<Overload>(AutoGenOverloads, substrnolen)

	Overload castrealtoint = PooledStringHandleForCast, PooledStringHandleForCastRealToInteger, nothing
	prepend<Overload>(AutoGenOverloads, castrealtoint)

	Overload castinttostr = PooledStringHandleForCast, PooledStringHandleForCastIntegerToString, nothing
	prepend<Overload>(AutoGenOverloads, castinttostr)

	Overload caststrtoint = PooledStringHandleForCast, PoolString("cast@@string_to_integer"), nothing
	prepend<Overload>(AutoGenOverloads, caststrtoint)

	Overload castrealtostr = PooledStringHandleForCast, PooledStringHandleForCastRealToString, nothing
	prepend<Overload>(AutoGenOverloads, castrealtostr)

	Overload castbooltoint = PooledStringHandleForCast, PooledStringHandleForCastBooleanToInteger, nothing
	prepend<Overload>(AutoGenOverloads, castbooltoint)

	Overload castint16toint = PooledStringHandleForCast, PoolString("cast@@integer16_to_integer"), nothing
	prepend<Overload>(AutoGenOverloads, castint16toint)

	Overload castinttoint16 = PooledStringHandleForCast, PoolString("cast@@integer_to_integer16"), nothing
	prepend<Overload>(AutoGenOverloads, castinttoint16)

	Overload caststrtoreal = PooledStringHandleForCast, PooledStringHandleForCastStringToReal, nothing
	prepend<Overload>(AutoGenOverloads, caststrtoreal)

	Overload writebuffernormal = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBuffer, nothing
	prepend<Overload>(AutoGenOverloads, writebuffernormal)

	Overload writebuffermultiple = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferMultiple, nothing
	prepend<Overload>(AutoGenOverloads, writebuffermultiple)

	Overload writebufferstring = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferString, nothing
	prepend<Overload>(AutoGenOverloads, writebufferstring)

	Overload writebufferreal = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferReal, nothing
	prepend<Overload>(AutoGenOverloads, writebufferreal)
}



CheckMemberTypes : list<StructureMember> ref members, simplelist<integer> ref types -> boolean match = true
{
	integer membertype = MakeNonReferenceType(GetMemberTypeDecompose(members.value))
	integer curtype = MakeNonReferenceType(types.value)

	if(membertype == curtype)
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	elseif(SumTypeHasBase(SumTypes, membertype, curtype))
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	else
	{
		match = false
	}
}

CheckMemberTypes : nothing, nothing -> true

CheckMemberTypes : list<StructureMember> ref members, nothing -> false

CheckMemberTypes : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}


GetStructureByAnonConstructorName : nothing, integer name -> 0 [nogc]

GetStructureByAnonConstructorName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0 [nogc]
{
	if(structures.value.AnonConstructorName == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureByAnonConstructorName(structures.next, name)
	}
}


stringcontains : string haystack, string needle -> boolean contains = false [nogc]
{
	integer needlelen = length(needle)
	integer haystacklen = length(haystack)

	integer index = 0
	while(index < (haystacklen - needlelen))
	{
		if(substring(haystack, index, needlelen) == needle)
		{
			contains = true
			return()
		}

		++index
	}
}


PrependFunctionParameter : list<FunctionDefinition> ref functions, integer funcname, integer paramname, integer paramtype
{
	if(functions.value.Name == funcname)
	{
		assert(paramtype != 0)
		UnresolvedParameter p = paramname, GetNameOfType(paramtype), paramtype, IsReferenceType(paramtype), nothing, nothing
		PrependUnresolvedParameter(functions.value.Params, p)
	}
	else
	{
		PrependFunctionParameter(functions.next, funcname, paramname, paramtype)
	}
}

PrependUnresolvedParameter : FunctionParams ref params, UnresolvedParameter ref p
{
	PrependUnresolvedParameter(params.Params, p)
}

PrependUnresolvedParameter : list<UnresolvedParameter> ref thelist, UnresolvedParameter ref p
{
	prepend<UnresolvedParameter>(thelist, p)
}

PrependUnresolvedParameter : nothing, UnresolvedParameter ref p
{
	print("Cannot set constructor tag on function with no parameters")
	assert(false)
}


GetSignatureReturnType : list<FunctionSignature> ref signatures, integer functype -> integer rettype = 0
{
	if(signatures.value.Name == functype)		// stupid overload of "name" to also mean "type"
	{
		rettype = GetTypeByName(signatures.value.ReturnTypeName)
	}
	else
	{
		rettype = GetSignatureReturnType(signatures.next, functype)
	}
}


FindOrCreateFunctionSignatureType : FunctionSignature ref signature -> integer typeid = 0
{
	typeid = FindMatchingSignature(FunctionSignatures, signature)
	if(typeid == 0)
	{
		FunctionSignature newsig = signature
		newsig.Name = (++GlobalFunctionTypeCounter)
		prepend<FunctionSignature>(FunctionSignatures, newsig)

		typeid = newsig.Name
	}
}

FindOrCreateFunctionSignatureType : simplelist<integer> ref paramtypenames, integer returntypename -> integer typeid = 0
{
	typeid = FindFunctionSignatureType(FunctionSignatures, paramtypenames, returntypename)
	if(typeid == 0)
	{
		OnCodeGenRegisterFunctionSig((++GlobalFunctionTypeCounter), returntypename)
		OnCodeGenRegisterFunctionSigParamList(paramtypenames)

		typeid = GlobalFunctionTypeCounter
	}
}

FindFunctionSignatureType : list<FunctionSignature> ref signatures, simplelist<integer> ref paramtypes, integer returntypename -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == returntypename)
	{
		if(SignatureMatchesParams(signatures.value.Parameters, paramtypes))
		{
			typeid = signatures.value.Name
			return()
		}
	}

	typeid = FindFunctionSignatureType(signatures.next, paramtypes, returntypename)
}

FindFunctionSignatureType : nothing, simplelist<integer> ref paramtypes, integer returntypename -> 0


SignatureMatchesParams : list<Parameter> ref params, simplelist<integer> ref paramtypes -> boolean match = true
{
	if(params.value.Name == 0)
	{
		match = SignatureMatchesParams(params.next, paramtypes)
	}
	elseif(paramtypes.value == 0)
	{
		match = SignatureMatchesParams(params, paramtypes.next)
	}
	elseif(params.value.Type != GetTypeByName(paramtypes.value))
	{
		match = false
	}
	else
	{
		match = SignatureMatchesParams(params.next, paramtypes.next)
	}
}

SignatureMatchesParams : nothing, simplelist<integer> ref paramtypes -> (paramtypes.value == 0)
SignatureMatchesParams : list<Parameter> ref params, nothing -> (params.value.Name == 0)

SignatureMatchesParams : nothing, nothing -> true


FindFunctionAndGetSignatureType : list<FunctionDefinition> ref functions, integer funcname -> integer typeid = 0
{
	if(functions.value.Name == funcname)
	{
		simplelist<integer> paramtypes = 0, nothing
		GetFunctionParameterTypes(functions.value.Params, paramtypes)

		integer rettypename = 0
		integer rettype = InferFunctionReturnType(functions.value)
		if(rettype != 0)
		{
			rettypename = GetNameOfType(rettype)
		}
		typeid = FindOrCreateFunctionSignatureType(paramtypes, rettypename)
	}
	else
	{
		typeid = FindFunctionAndGetSignatureType(functions.next, funcname)
	}
}


GetFunctionParameterTypes : FunctionParams ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.Params, outtypenames)
}

GetFunctionParameterTypes : list<UnresolvedParameter> ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.next, outtypenames)

	assert(params.value.ResolvedType != 0)

	simpleprepend<integer>(outtypenames, GetNameOfType(params.value.ResolvedType))
}

GetFunctionParameterTypes : nothing, simplelist<integer> ref outtypenames


FindMatchingSignature : list<FunctionSignature> ref signatures, FunctionSignature ref targetsig -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == targetsig.ReturnTypeName)
	{
		if(SignaturesMatch(signatures.value.Parameters, targetsig.Parameters))
		{
			typeid = signatures.value.Name
			return()
		}
	}

	typeid = FindMatchingSignature(signatures.next, targetsig)
}

FindMatchingSignature : nothing, FunctionSignature ref targetsig -> 0


SignaturesMatch : list<Parameter> ref a, list<Parameter> ref b -> boolean match = true
{
	if(a.value.Type != b.value.Type)
	{
		match = false
	}
	else
	{
		match = SignaturesMatch(a.next, b.next)
	}
}

SignaturesMatch : nothing, list<Parameter> ref b -> (b.value.Name == 0)
SignaturesMatch : list<Parameter> ref a, nothing -> (a.value.Name == 0)

SignaturesMatch : nothing, nothing -> true


DumpSignature : FunctionSignature ref sig
{
	print("  Function signature")
	DumpSignatureParams(sig.Parameters)
	print("  ->")
	if(sig.ReturnTypeName != 0)
	{
		print(GetPooledString(GlobalStrings, sig.ReturnTypeName))
	}
}

DumpSignatureParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		print(GetPooledString(GlobalStrings, GetNameOfType(params.value.Type)))
	}
	DumpSignatureParams(params.next)
}

DumpSignatureParams : nothing



ResolveSignatureTypes : FunctionSignature ref signature
{
	ResolveSignatureTypes(signature.Parameters)
}

ResolveSignatureTypes : list<Parameter> ref params
{
	params.value.Type = GetTypeByName(params.value.Type)
	ResolveSignatureTypes(params.next)
}

ResolveSignatureTypes : nothing



FindBuiltinAndGetSignatureType : integer builtinname -> integer typeid = 0
{
	if(builtinname == PooledStringHandleForPassTest)
	{
		simplelist<integer> paramtypes = 0, nothing
		typeid = FindOrCreateFunctionSignatureType(paramtypes, 0)
	}
}


FindPrePostOperatorOverload : integer operatorname, integer operandtype -> integer overloadname = 0 [nogc]
{
	if(operatorname == PooledStringHandleForPrePostIncrement)
	{
		if(operandtype == 0x01000001)
		{
			overloadname = PooledStringHandleForPrePostIncrementInteger
		}
	}
	elseif(operatorname == PooledStringHandleForPrePostDecrement)
	{
		if(operandtype == 0x01000001)
		{
			overloadname = PooledStringHandleForPrePostDecrementInteger
		}
	}
}

FindAssignmentOperator : integer operatorname, integer lhstype, integer rhstype -> integer overloadname = operatorname [nogc]
{
	lhstype = MakeNonReferenceType(lhstype)
	rhstype = MakeNonReferenceType(rhstype)

	if(operatorname == PooledStringHandleForIncrementAssign)
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = PooledStringHandleForIncrementAssignInteger
		}
	}
	elseif(operatorname == PooledStringHandleForDecrementAssign)
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = PooledStringHandleForDecrementAssignInteger
		}
	}
}


SetFunctionReturnType : FunctionDefinition ref func, integer funcname, integer rettype [nogc]
{
	SetOptionalExpressionType(func.Return, rettype)
}


SetOptionalExpressionType : Expression ref expr, integer typeid [nogc]
{
	expr.Type = typeid
}



CheckForNeededPatternMatcher : list<PendingPatternMatcher> ref patternmatchers, integer rawname -> integer matchername = 0 [nogc]
{
	if(patternmatchers.value.RawName == rawname)
	{
		matchername = patternmatchers.value.MatcherName
	}
	else
	{
		matchername = CheckForNeededPatternMatcher(patternmatchers.next, rawname)
	}
}

CheckForNeededPatternMatcher : nothing, integer rawname -> 0 [nogc]


EnsurePatternMatcherExists : list<PendingPatternMatcher> ref patternmatchers, integer rawname, integer mangledname
{
	if(patternmatchers.value.OverloadName == mangledname)
	{
		return()
	}

	EnsurePatternMatcherExists(patternmatchers.next, rawname, mangledname)
}

EnsurePatternMatcherExists : nothing, integer rawname, integer mangledname
{
	PendingPatternMatcher pm = rawname, mangledname, PoolStringFast(GetPooledString(GlobalStrings, rawname) ; "@@patternmatch")
	prepend<PendingPatternMatcher>(PendingPatternMatchers, pm)
}



CodeGenEmitPatternMatchers : list<PendingPatternMatcher> ref matchers
{
	if(!listcontains(EmittedPatternMatchers, matchers.value.MatcherName))
	{
		OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
		OnBytecodeEmitInteger(matchers.value.MatcherName)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(0)

		OnBytecodeEnterPatternResolver(matchers.value.MatcherName)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, true)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, false)
		OnBytecodeExitPatternResolver()

		simpleprepend<integer>(EmittedPatternMatchers, matchers.value.MatcherName)
	}

	CodeGenEmitPatternMatchers(matchers.next)
}

CodeGenEmitPatternMatchers : nothing


EmitOverloadsForPatternMatcher : list<PendingPatternMatcher> ref matchers, integer matchername, boolean preferliterals
{
	if(matchername == matchers.value.MatcherName)
	{
		// TODO - filter down to matchers that fit the most general function pattern

		EmitPatternMatchOverload(Functions, matchers.value.OverloadName, preferliterals)
	}

	EmitOverloadsForPatternMatcher(matchers.next, matchername, preferliterals)
}

EmitOverloadsForPatternMatcher : nothing, integer matchername, boolean preferliterals



EmitPatternMatchOverload : list<FunctionDefinition> ref functions, integer overloadname, boolean preferliterals
{
	if(functions.value.Name == overloadname)
	{
		boolean hasliterals = FunctionSignatureHasLiterals(functions.value.Params)
		if(hasliterals && preferliterals)
		{
			EmitPatternMatchingForFunction(functions.value)
		}
		elseif((!hasliterals) && (!preferliterals))
		{
			EmitPatternMatchingForFunction(functions.value)
		}
	}
	else
	{
		EmitPatternMatchOverload(functions.next, overloadname, preferliterals)
	}
}


FunctionSignatureHasLiterals : FunctionParams ref params -> boolean hasliterals = FunctionSignatureHasLiterals(params.Params) [nogc]

FunctionSignatureHasLiterals : list<UnresolvedParameter> ref params -> boolean hasliterals = false [nogc]
{
	integer exprtype = GetOptionalExpressionType(params.value.PatternMatchValue)
	if((exprtype != 0) && (exprtype != 0x00000002))
	{
		hasliterals = true
		return()
	}

	if(FunctionSignatureHasLiterals(params.next))
	{
		hasliterals = true
	}
}

FunctionSignatureHasLiterals : nothing -> false [nogc]



EmitPatternMatchingForFunction : FunctionDefinition ref function
{
	OnBytecodeEmitByte(0x12)			// PatternMatch instruction
	OnBytecodeEmitInteger(function.Name)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitInteger(CountUnresolvedParameters(function.Params))
	EmitPatternMatchingForParameters(function.Params)
}

EmitPatternMatchingForParameters : FunctionParams ref params
{
	EmitPatternMatchingForParameters(params.Params)
}

EmitPatternMatchingForParameters : list<UnresolvedParameter> ref params
{
	integer parampatterntype = GetOptionalExpressionType(params.value.PatternMatchValue)
	OnBytecodeEmitInteger(MakeNonReferenceType(parampatterntype))

	if(parampatterntype != 0)
	{
		OnBytecodeEmitBoolean(true)
		EmitPatternMatchLiteral(params.value.PatternMatchValue)
	}
	else
	{
		OnBytecodeEmitBoolean(false)
	}

	EmitPatternMatchingForParameters(params.next)
}

EmitPatternMatchingForParameters : nothing


EmitPatternMatchLiteral : Expression ref expr
{
	EmitPatternMatchLiteralAtom(expr.Atoms.value)
}

EmitPatternMatchLiteralAtom : integer value
{
	OnBytecodeEmitInteger(value)
}


PatternMatcherExists : nothing, integer matchername -> false

PatternMatcherExists : list<PendingPatternMatcher> ref matchers, integer matchername -> boolean exists = false
{
	if(matchers.value.MatcherName == matchername)
	{
		exists = true
	}
	else
	{
		exists = PatternMatcherExists(matchers.next, matchername)
	}
}



GetCastOverload : nothing -> 0

GetCastOverload : ExpressionList ref params -> integer overloadname = FigureOutCastOverload(params.Expressions)


FigureOutCastOverload : list<Expression> ref params -> integer overloadname = 0
{
	integer idtype = GetTypeByName(GetIdentifier(params.value.Atoms.value))
	if(idtype != 0)
	{
		integer origintype = FigureOutCastOriginType(params.next)

		if((idtype == 0x01000001) && (origintype == 0x01000004))
		{
			overloadname = PooledStringHandleForCastRealToInteger
		}
		elseif((idtype == 0x02000000) && (origintype == 0x01000001))
		{
			overloadname = PooledStringHandleForCastIntegerToString
		}
		elseif((idtype == 0x02000000) && (origintype == 0x01000004))
		{
			overloadname = PooledStringHandleForCastRealToString
		}
		elseif((idtype == 0x01000001) && (origintype == 0x01000002))
		{
			overloadname = PooledStringHandleForCastInteger16ToInteger
		}
		elseif((idtype == 0x01000002) && (origintype == 0x01000001))
		{
			overloadname = PooledStringHandleForCastIntegerToInteger16
		}
		elseif((idtype == 0x01000001) && (origintype == 0x01000003))
		{
			overloadname = PooledStringHandleForCastBooleanToInteger
		}
		elseif((idtype == 0x01000004) && (origintype == 0x02000000))
		{
			overloadname = PooledStringHandleForCastStringToReal
		}
		elseif((idtype == 0x01000001) && (origintype == 0x02000000))
		{
			overloadname = PooledStringHandleForCastStringToInteger
		}
	}
}

FigureOutCastOverload : nothing -> 0



FigureOutCastOriginType : list<Expression> ref params -> integer origintype = params.value.Type [nogc]

FigureOutCastOriginType : nothing -> 0 [nogc]


GetIdentifier : IdentifierAtom ref atom -> atom.Handle [nogc]



IRRegisterTemplateParameter : integer paramtype, integer paramname [nogc]
{
	TemplateParameter p = paramname, paramtype
	prepend<TemplateParameter>(TemplateParameterQueue, p)
}


CreateFunctionTemplateAndAttachParams : integer funcname, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateFunction templfunc = funcname, dummyparams
	prepend<TemplateFunction>(TemplateFunctions, templfunc)
}


CreateStructureTemplateAndAttachParams : integer structurename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateStructure templstructure = structurename, dummyparams
	prepend<TemplateStructure>(TemplateStructures, templstructure)
}


CreateSumTypeTemplateAndAttachParams : integer typename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateSumType templtype = typename, dummyparams
	prepend<TemplateSumType>(TemplateSumTypes, templtype)
}



TransferTemplateParamsFromQueue : list<TemplateParameter> ref out, list<TemplateParameter> ref queue
{
	if(queue.value.ParamType != 0)
	{
		TransferTemplateParamsFromQueue(out, queue.next)

		if(out.value.ParamType == 0)
		{
			out.value = queue.value
		}
		else
		{
			prepend<TemplateParameter>(out, queue.value)
		}
	}
}



PopTemplateArgStack : list<TemplateArgumentList> ref stack, list<TemplateArgumentList> ref next [nogc]
{
	stack = next
}

PopTemplateArgList : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail [nogc]
{
	thelist = tail
}


AppendTemplateArgument : list<TemplateArgument> ref thelist, TemplateArgument ref arg [nogc]
{
	AppendTemplateArgumentRecurse(thelist, thelist.next, arg)
}


AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, nothing, TemplateArgument ref arg [nogc]
{
	list<TemplateArgument> newlist = arg, nothing
	thelist.next = newlist
}

AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail, TemplateArgument ref arg [nogc]
{
	AppendTemplateArgumentRecurse(tail, tail.next, arg)
}


InstantiateTemplateFast : integer templatename, nothing -> templatename

InstantiateTemplateFast : integer templatename, TemplateArgumentList ref args -> integer instancename = templatename
{
	integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, templatename, args.Args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	existing = FindExistingTemplateInstance(TemplateStructureInstances, templatename, args.Args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	instancename = InstantiateFunctionTemplate(templatename, args)
}



InstantiateFunctionTemplate : integer templatename, nothing -> templatename

InstantiateFunctionTemplate : integer templatename, TemplateArgumentList ref args -> integer instancename = templatename
{
	instancename = FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, templatename, args.Args)

	ContextNode<FunctionDefinition> wrap = nothing
	while(PopPendingFunctionForInference(wrap))
	{
		TypeInference(wrap, DummyContextForFunctions)
	}
}


EnumerateOverloadsAndInstantiate : list<Overload> ref overloads, integer templatename, list<TemplateArgument> ref args
{
	if(overloads.value.NormalName == templatename)
	{
		integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, overloads.value.MangledName, args)
		if(existing == 0)
		{
			FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, overloads.value.MangledName, args)
		}
	}

	EnumerateOverloadsAndInstantiate(overloads.next, templatename, args)
}

EnumerateOverloadsAndInstantiate : nothing, integer templatename, list<TemplateArgument> ref args


FindFunctionTemplateAndInstantiate : list<TemplateFunction> ref templates, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.FunctionDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = RegisterOverloadForFunction(mangledname, PoolString(mangledname))

		// TODO - validate that args suit the formal template parameters!

		string basenamemangled = MangleTemplateName(basename, args)
		integer bnmh = PoolString(basenamemangled)
		Overload overload = bnmh, instancename, nothing
		FindFunctionAndAddOverload(overload)

		DoFunctionInstantiation(bnmh, defname, instancename, templates.value.Parameters, args, overload)
	}
	else
	{
		instancename = FindFunctionTemplateAndInstantiate(templates.next, basename, defname, args)
	}
}

FindFunctionTemplateAndInstantiate : nothing, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateStructureTemplateFast(defname, args)


FindStructureTemplateAndInstantiate : list<TemplateStructure> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.StructureDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)

		// TODO - validate that args suit the formal template parameters!

		DoStructureInstantiation(defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindStructureTemplateAndInstantiate(templates.next, defname, args)
	}
}

FindStructureTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateSumType(defname, args)


InstantiateSumType : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateSumTypeInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	instancename = FindSumTypeTemplateAndInstantiate(TemplateSumTypes, defname, args)
}

FindSumTypeTemplateAndInstantiate : list<TemplateSumType> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.SumTypeName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)

		// TODO - validate that args suit the formal template parameters!

		DoSumTypeInstantiation(defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindSumTypeTemplateAndInstantiate(templates.next, defname, args)
	}
}


FindSumTypeTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer t = GetTypeByName(defname)
	if(t != 0)
	{
		instancename = defname
		return()
	}

	string namestr = GetPooledString(GlobalStrings, defname)
	print("Error - no template provided for '" ; namestr ; "', cannot create instance!")
}


DoStructureInstantiation : integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, defname, wrap)
	assert(found)

	StructInstInner(wrap, defname, instancename, params, args)
}

StructInstInner : StructureDefinition ref templstruct, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	assert(templstruct.IsTemplate)

	++GlobalTemplateInstanceCounter

	list<StructureMember> members = dummymember, nothing
	DoMemberListInstantiation(templstruct.Members, members, params, args)
	PopMember(members, members.next)

	StructureDefinition struct = instancename, GlobalTemplateInstanceCounter, 0, 0, 0, members, templstruct.MemberCount, GetPooledString(GlobalStrings, instancename), false
	prepend<StructureDefinition>(Structures, struct)
	InsertIntoBinaryTree<StructureDefinition>(StructuresWhichExist, instancename, struct)

	TemplateInstance instance = defname, instancename, args
	prepend<TemplateInstance>(TemplateStructureInstances, instance)

	TypeInference(Structures.value, DummyContextForFunctions)
}


DoSumTypeInstantiation : integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	ContextNode<SumType> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<SumType>(SumTypesWhichExist, defname, wrap)

	if(found)
	{
		STInst(wrap, instancename, params, args)
	}
}

STInst : SumType ref templst, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	assert(templst.IsTemplate)

	++GlobalSumTypeCounter

	list<SumTypeBase> bases = dummybasetype, nothing
	DoBaseTypeInstantiation(templst.Bases, bases, params, args)

	SumType st = instancename, GlobalSumTypeCounter, bases, false
	prepend<SumType>(SumTypes, st)
	InsertIntoBinaryTree<SumType>(SumTypesWhichExist, instancename, st)

	TemplateInstance instance = templst.Name, instancename, args
	prepend<TemplateInstance>(TemplateSumTypeInstances, instance)

	ResolveSumTypeBases(SumTypes.value.Bases)
}


PopMember : list<StructureMember> ref members, list<StructureMember> ref tail [nogc]
{
	members = tail
}

DoMemberListInstantiation : list<StructureMember> ref members, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	DoMemberInstantiation(members.value, out, params, args)
	DoMemberListInstantiation(members.next, out, params, args)
}

DoMemberListInstantiation : nothing, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args

DoMemberInstantiation : StructureMemberVariable ref memvar, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(memvar.Name != 0)
	{
		integer newtype = MapTemplateType(memvar.TypeNameHandle, params, args)

		StructureMemberVariable newmemvar = memvar.Name, 0, newtype, scratchtemplatearglist
		CopyTemplateArgs(memvar.TemplateArgs, newmemvar.TemplateArgs)
		RemapAllTemplateArguments(newmemvar.TemplateArgs, params, args)
		StructureMember newmember = newmemvar
		AppendStructureMember(out, out.next, newmember)
	}
}

CopyTemplateArgs : TemplateArgumentList ref in, TemplateArgumentList ref out [nogc]
{
	TemplateArgumentList copy = in
	out = copy
}

CopyTemplateArgs : nothing, TemplateArgumentList ref out [nogc]

DoBaseTypeInstantiation : list<SumTypeBase> ref bases, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	InstantiateBaseType(bases.value, out, params, args)
	DoBaseTypeInstantiation(bases.next, out, params, args)
}

DoBaseTypeInstantiation : nothing, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args


InstantiateBaseType : SumTypeBase ref in, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(in.Name != 0)
	{
		integer newtype = MapTemplateType(in.Name, params, args)

		SumTypeBase newbase = newtype, scratchtemplatearglist
		CopyTemplateArgs(in.TemplateArgs, newbase.TemplateArgs)
		RemapAllTemplateArguments(newbase.TemplateArgs, params, args)
		prepend<SumTypeBase>(out, newbase)
	}
}

RemapAllTemplateArguments : TemplateArgumentList ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	RemapAllTemplateArguments(toremap.Args, params, args)
}

RemapAllTemplateArguments : list<TemplateArgument> ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(toremap.value.ReplaceWith != 0)
	{
		toremap.value.ReplaceWith = MapTemplateType(toremap.value.ReplaceWith, params, args)
		toremap.value.ReplaceWithString = GetPooledString(GlobalStrings, toremap.value.ReplaceWith)
	}

	RemapAllTemplateArguments(toremap.next, params, args)
}

RemapAllTemplateArguments : nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args


DoFunctionInstantiation : integer basenamemangled, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args, Overload ref overload
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, defname, wrap)
	assert(found)

	FunctionInstantiationInner(wrap, basenamemangled, defname, instancename, params, args, overload)
	EnumerateOverloadsAndInstantiate(wrap, defname, args)
}

EnumerateOverloadsAndInstantiate : FunctionDefinition ref func, integer templatename, list<TemplateArgument> ref args
{
	EnumerateOverloadsAndInstantiate(func.Overloads, templatename, args)
}

FunctionInstantiationInner : FunctionDefinition ref originalfunc, integer basenamemangled, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args, Overload ref outoverload
{
	if(!originalfunc.IsTemplate)
	{
		print("Function is not template: " ; GetPooledString(GlobalStrings, defname))
		assert(false)
	}

	TemplateInstance inst = defname, instancename, args
	prepend<TemplateInstance>(TemplateFunctionInstances, inst)

	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = basenamemangled, instancename, nothing, nothing, nothing, originalfunc.Overloads, scopewrap, GetPooledString(GlobalStrings, basenamemangled), 0, false, false, originalfunc.AnonymousReturn
	prepend<FunctionDefinition>(Functions, func)
	InsertIntoBinaryTree<FunctionDefinition>(FunctionsWhichExist, instancename, func)

	Overload selfoverload = instancename, instancename, func
	prepend<Overload>(func.Overloads, selfoverload)

	AttachContextToOverload(func.Overloads, instancename, func)
	outoverload.Implementation = func

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	DoParameterInstantiation(originalfunc.Params, params, args)
	DoReturnInstantiation(originalfunc.Return, instancename, originalfunc.AnonymousReturn, params, args)

	// TODO - traverse template and instantiate the following stuff
	//ParseFunctionTags(namehandle, rawnamehandle)

	IREnterFunction(instancename)
	Functions.value.AttachedScope.Wrapped = Scopes.value
	OnCodeGenEnterFunctionBody(instancename)

	DoCodeBlockInstantiation(originalfunc.Code, params, args)

	IRExitFunction()

	PushPendingFunctionForInference(func)
}


DoParameterInstantiation : FunctionParams ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	DoParameterInstantiation(params.Params, templateparams, templateargs)
}

DoParameterInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoParameterInstantiation : list<UnresolvedParameter> ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer newtype = MapTemplateType(params.value.TypeNameHandle, templateparams, templateargs)
	integer resolvedtype = params.value.ResolvedType

	if((resolvedtype & 0x7f000000) == 0x09000000)
	{
		resolvedtype = InstantiateFunctionSignature(FunctionSignatures, resolvedtype, templateparams, templateargs)
		newtype = GetNameOfType(resolvedtype)
	}

	UnresolvedParameter p = params.value.NameHandle, newtype, resolvedtype, params.value.HasRefTag, params.value.PatternMatchValue, nothing
	PropagateTemplateArgsForParameter(p, params.value.TemplateArgs, templateparams, templateargs)

	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)

	DoParameterInstantiation(params.next, templateparams, templateargs)
}

InstantiateFunctionSignature : list<FunctionSignature> ref sigs, integer targettype, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs -> integer ret = 0
{
	if(sigs.value.Name == targettype)
	{
		FunctionSignature clone = sigs.value
		clone.ReturnTypeName = MapTemplateType(clone.ReturnTypeName, templateparams, templateargs)
		RemapSignatureParamTypes(clone.Parameters, templateparams, templateargs)

		ret = FindOrCreateFunctionSignatureType(clone)
	}
	else
	{
		ret = InstantiateFunctionSignature(sigs.next, targettype, templateparams, templateargs)
	}
}

RemapSignatureParamTypes : list<Parameter> ref parameters, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	parameters.value.Type = GetTypeByName(MapTemplateType(parameters.value.Type, templateparams, templateargs))
	RemapSignatureParamTypes(parameters.next, templateparams, templateargs)
}

RemapSignatureParamTypes : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs


PropagateTemplateArgsForParameter : UnresolvedParameter ref p, TemplateArgumentList ref check, list<TemplateParameter> ref params, list<TemplateArgument> ref args [nogc]
{
	TemplateArgumentList wrap = args
	RemapAllTemplateArguments(wrap, params, args)
	p.TemplateArgs = wrap
}

PropagateTemplateArgsForParameter : UnresolvedParameter ref p, nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args [nogc]


DoReturnInstantiation : Expression ref retexpr, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterFunctionReturn(funcname, anonymous)
	InstantiateExpression(retexpr, true, templateparams, templateargs)
	OnCodeGenExitContext()
}

DoReturnInstantiation : nothing, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs


MapTemplateType : integer typenamehandle, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs -> integer newtypename = typenamehandle [nogc]
{
	if(templateparams.value.ParamName == typenamehandle)
	{
		newtypename = templateargs.value.ReplaceWith
	}
	else
	{
		newtypename = MapTemplateType(typenamehandle, templateparams.next, templateargs.next)
	}
}

MapTemplateType : integer typenamehandle, nothing, nothing -> typenamehandle [nogc]


MangleTemplateNameByHandle : integer defname, nothing -> integer mangled = defname [nogc]

MangleTemplateNameByHandle : integer defname, TemplateArgumentList ref args -> integer mangled = PoolString(MangleTemplateName(defname, args.Args)) [nogc]


MangleTemplateName : integer defname, list<TemplateArgument> ref args -> string mangled = GetPooledString(GlobalStrings, defname) ; "@@templateinst@" [nogc]
{
	mangled = mangled ; MangleTemplateArguments(args)
}

MangleTemplateArguments : list<TemplateArgument> ref args -> string mangled = args.value.ReplaceWithString [nogc]
{
	mangled = mangled ; MangleTemplateArguments(args.next)
}

MangleTemplateArguments : nothing -> "" [nogc]


InstantiateStructureTemplate : integer defname, TemplateArgumentList ref args -> integer instancename = InstantiateStructureTemplate(defname, args.Args)

InstantiateStructureTemplate : integer defname, nothing -> integer instancename = 0

InstantiateStructureTemplate : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateStructureInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	instancename = FindStructureTemplateAndInstantiate(TemplateStructures, defname, args)
}


InstantiateStructureTemplateFast : integer defname, TemplateArgumentList ref args -> integer instancename = InstantiateStructureTemplateFast(defname, args.Args)

InstantiateStructureTemplateFast : integer defname, nothing -> integer instancename = 0

InstantiateStructureTemplateFast : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	instancename = FindStructureTemplateAndInstantiate(TemplateStructures, defname, args)
}


FindExistingTemplateInstance : list<TemplateInstance> ref instances, integer defname, list<TemplateArgument> ref args -> integer instancename = 0 [nogc]
{
	if(instances.value.DefName == defname)
	{
		if(TemplateArgumentsMatch(instances.value.Arguments, args))
		{
			instancename = instances.value.InstanceName
			return()
		}
	}

	instancename = FindExistingTemplateInstance(instances.next, defname, args)
}

FindExistingTemplateInstance : nothing, integer defname, list<TemplateArgument> ref args -> 0 [nogc]



TemplateArgumentsMatch : list<TemplateArgument> ref a, list<TemplateArgument> ref b -> boolean match = true [nogc]
{
	if(a.value.ReplaceWith != b.value.ReplaceWith)
	{
		match = false
	}
	else
	{
		match = TemplateArgumentsMatch(a.next, b.next)
	}
}

TemplateArgumentsMatch : nothing, list<TemplateArgument> ref b -> false [nogc]
TemplateArgumentsMatch : list<TemplateArgument> ref a, nothing -> false [nogc]
TemplateArgumentsMatch : nothing, nothing -> true [nogc]



InstantiateExpression : Expression ref expr, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateAtoms(expr.Atoms, inret, templateparams, templateargs)
}

InstantiateExpression : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

InstantiateAtoms : list<ExpressionAtom> ref atoms, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateSingleAtom(atoms.value, inret, templateparams, templateargs)
	InstantiateAtoms(atoms.next, inret, templateparams, templateargs)
}

InstantiateAtoms : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support ALL atom types (parenthetical should be the only one left)
InstantiateSingleAtom : IdentifierAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterAtomIdentifier(atom.Handle, 0)
}

InstantiateSingleAtom : OperatorInvokeAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterOperatorInvoke(atom.OperatorName)
}

InstantiateSingleAtom : Statement ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer statementname = MapTemplateType(atom.Name, templateparams, templateargs)

	OnCodeGenEnterSubStatement()
	InstantiateStatement(statementname, inret, atom.TemplateArgs, templateparams, templateargs)

	InstantiateExpressionList(atom.Parameters, false, templateparams, templateargs, 0)

	IRExitStatement()
	IRExitStatement()
}


InstantiateSingleAtom : AtomSentinel ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

InstantiateSingleAtom : boolean ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralBoolean(atom)
}

InstantiateSingleAtom : StringHandleAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralString(atom.Handle)
}

InstantiateSingleAtom : integer ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralInteger(atom, 0x01000001)
}

InstantiateSingleAtom : integer16 ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralInteger(cast(integer, atom), 0x01000002)
}

InstantiateSingleAtom : real ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralReal(atom)
}


InstantiateStatement : integer statementname, boolean inret, nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterStatement(statementname, 0, inret, false)
}

InstantiateStatement : integer statementname, boolean inret, TemplateArgumentList ref args, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	Statement statement = statementname, nothing, 0, args, inret, false
	PropagateTemplateArgsForStatement(statement, args, templateargs)
	RemapAllTemplateArguments(statement.TemplateArgs, templateparams, templateargs)
	OnCodeGenEmplaceStatement(statement)
}

PropagateTemplateArgsForStatement : Statement ref s, TemplateArgumentList ref check, list<TemplateArgument> ref args
{
	TemplateArgumentList wrap = args
	s.TemplateArgs = wrap
}

PropagateTemplateArgsForStatement : Statement ref s, nothing, list<TemplateArgument> ref args


InstantiateExpressionList : ExpressionList ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	InstantiateExpressionList(exprs.Expressions, inret, templateparams, templateargs, count)
}

InstantiateExpressionList : list<Expression> ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	if(count != 0)
	{
		OnCodeGenShiftParameter()
	}

	InstantiateExpression(exprs.value, inret, templateparams, templateargs)
	InstantiateExpressionList(exprs.next, inret, templateparams, templateargs, count + 1)
}

InstantiateExpressionList : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count


DoCodeBlockInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoCodeBlockInstantiation : CodeBlock ref code, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntries(code.Entries, templateparams, templateargs)
}

InstantiateCodeBlockEntries : list<CodeBlockEntry> ref entries, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntry(entries.value, templateparams, templateargs)
	InstantiateCodeBlockEntries(entries.next, templateparams, templateargs)
}

InstantiateCodeBlockEntries : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support all code block entry types
InstantiateCodeBlockEntry : Statement ref s, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateStatement(s.Name, true, s.TemplateArgs, templateparams, templateargs)
	InstantiateExpressionList(s.Parameters, false, templateparams, templateargs, 0)

	IRExitStatement()
}

InstantiateCodeBlockEntry : Assignment ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support

	OnCodeGenEnterAssignment(a.Operator, a.LHSName, 0, 0)
	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCodeBlockEntry : AssignmentCompound ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support

	OnCodeGenEnterAssignmentCompound(a.Operator, a.LHS.value, 0, 0)
	InstantiateCompoundAssignmentLHS(a.LHS.next)
	OnCodeGenAssignmentCompoundEnd()

	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCompoundAssignmentLHS : simplelist<integer> ref lhs
{
	FindCurrentFunctionAndAppendCompoundMember(lhs.value)
	InstantiateCompoundAssignmentLHS(lhs.next)
}

InstantiateCompoundAssignmentLHS : nothing


InstantiateCodeBlockEntry : EntityChain ref chain, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterChain()
	InstantiateEntityChainEntries(chain.Entries, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateEntityChainEntries : EntityList ref entities, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateEntityChainEntries(entities.ActualList, templateparams, templateargs)
}

InstantiateEntityChainEntries : list<Entity> ref entities, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterEntity(entities.value.Tag, entities.value.PostfixTag)
	InstantiateExpression(entities.value.Param, false, templateparams, templateargs)
	OnCodeGenEnterEntityCode()
	DoCodeBlockInstantiation(entities.value.Code, templateparams, templateargs)
	OnCodeGenExitContext()
	OnCodeGenExitContext()

	InstantiateEntityChainEntries(entities.next, templateparams, templateargs)
}

InstantiateEntityChainEntries : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs




SetStructureToTemplate : integer name
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, name, wrap)
	assert(found)

	SetStructureToTemplate(wrap)
}

SetStructureToTemplate : StructureDefinition ref struct
{
	struct.IsTemplate = true

	CreateStructureTemplateAndAttachParams(struct.Name, TemplateParameterQueue)

	// Reset template parameter queue
	list<TemplateParameter> dummylist = scratchtemplateparam, nothing
	TemplateParameterQueue = dummylist
}


PopPendingFunctionForInference : ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	hasnode = PopPendingFunctionForInferenceWorker(PendingInferenceFunctions, PendingInferenceFunctions.next, out)
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, list<FunctionDefinition> ref tail, ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	if(head.value.Name != 0)
	{
		ContextNode<FunctionDefinition> outwrap = head.value
		out = outwrap
		head = tail
		hasnode = true
	}
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, nothing, ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	assert(head.value.Name == 0)
}

PushPendingFunctionForInference : FunctionDefinition ref func [nogc]
{
	prepend<FunctionDefinition>(PendingInferenceFunctions, func)
}


DumpOverloadList : list<Overload> ref overloads
{
	DumpOverload(overloads.value)
	DumpOverloadList(overloads.next)
}


DumpOverload : Overload ref overload
{
	print(GetPooledString(GlobalStrings, overload.NormalName) ; " -> " ; GetPooledString(GlobalStrings, overload.MangledName))
}


CacheGlobalCodeBlock : list<Scope> ref scopes [nogc]
{
	if(scopes.value.Name == GlobalCodeBlockName)
	{
		GlobalScope.Wrapped = scopes.value
	}
	else
	{
		CacheGlobalCodeBlock(scopes.next)
	}
}
