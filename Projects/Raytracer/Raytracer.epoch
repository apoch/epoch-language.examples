//
// Some working thought-space for the raytracer project for R14
//


type listnode<type T> : list<T> | nothing

structure list<type T> :
	T value,
	listnode<T> next



structure Point :
	real x,
	real y,
	real z

// TODO - fix type aliases
structure Vector :
	real x,
	real y,
	real z

structure Ray :
	Point origin,
	Vector direction


structure Sphere :
	Point center,
	real radius


structure Plane :
	Vector normal,
	real offset


type Geometry : Sphere | Plane



structure Color :
	real r,
	real g,
	real b


structure Light :
	Point location,
	Color color,
	real intensity


dot : Vector ref v1, Vector ref v2 -> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z [native]
dot : Vector ref v1, Point ref v2 -> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z [native]
dot : Point ref v1, Point ref v2 -> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z [native]


intersect : Plane ref p, Ray ref r -> real t = 100000.0 [native]
{
	real dotprod = dot(p.normal, r.direction)
	if(dotprod < 0.0)
	{
		real t0 = (0.0 - (dot(p.normal, r.origin) + p.offset)) / dotprod
		if(t0 > 0.0)
		{
			t = t0
		}
	}
}

intersect : Sphere ref s, Ray ref r -> real t = 100000.0 [native]
{
	// TODO - transform ray into object space

	real b = dot(r.direction, r.origin)
	real c = dot(r.origin, r.origin) - 1.0
	real disc = 4.0 * (b * b - c)

	if(disc > 0.0)
	{
		real distSqrt = sqrt(disc)
		real t0 = 0.0
		if(b < 0.0)
		{
			t0 = (-2.0*b - distSqrt) / 2.0
		}
		else
		{
			t0 = (-2.0*b + distSqrt) / 2.0
		}

		real t1 = c / t0

		if(t0 > t1)
		{
			real temp = t0
			t0 = t1
			t1 = temp
		}

		if(t1 > 0.0)
		{
			if(t0 < 0.0)
			{
				t = t1
			}
			else
			{
				t = t0
			}
		}
	}
}


structure Camera :
	Point location,
	Vector direction,
	real horizontalFOV,
	real verticalFOV

structure Scene :
	list<Geometry> objects,
	Light thelight,
	Camera camera


test : nothing, Ray ref r, Geometry ref closest, real ref t [native]

test : list<Geometry> ref geometry, Ray ref r, Geometry ref closest, real ref t [native]
{
	real thist = intersect(geometry.value, r)
	if(thist < t)
	{
		t = thist
		closest = geometry.value
	}

	listnode<Geometry> nextnode = geometry.next
	test(nextnode, r, closest, t)
}


shadowtest : nothing, Ray ref r -> boolean ret = false [native]

shadowtest : list<Geometry> ref geometry, Ray ref r -> boolean ret = false [native]
{
	real t = intersect(geometry.value, r)
	if(t < 100000.0)
	{
		ret = true
	}
	else
	{
		listnode<Geometry> nextnode = geometry.next
		ret = shadowtest(nextnode, r)
	}
}


shade : Sphere ref s, Scene ref scene, Point ref intersectpt, Vector ref lightdirvec, Ray ref sr -> integer c = 0 [native]
{
	sr.direction.x = intersectpt.x - s.center.x
	sr.direction.y = intersectpt.y - s.center.y
	sr.direction.z = intersectpt.z - s.center.z
	normalize(sr.direction)

	real i = dot(sr.direction, lightdirvec)
	if(i > 0.0)
	{
		c += cast(integer, i * 0.816 * 255.0)
		c += cast(integer, i * 0.584 * 255.0) * 256
		c += cast(integer, i * 0.306 * 255.0) * 65536
	}
}


shade : Plane ref p, Scene ref scene, Point ref intersectpt, Vector ref lightdirvec, Ray ref sr -> integer c = 0 [native]
{
	real i = p.normal.x * lightdirvec.x + p.normal.y * lightdirvec.y + p.normal.z * lightdirvec.z
	if(i > 0.0)
	{
		sr.origin.x = intersectpt.x + lightdirvec.x * 0.01
		sr.origin.y = intersectpt.y + lightdirvec.y * 0.01
		sr.origin.z = intersectpt.z + lightdirvec.z * 0.01
		
		sr.direction.x = lightdirvec.x
		sr.direction.y = lightdirvec.y
		sr.direction.z = lightdirvec.z

		if(!shadowtest(scene.objects, sr))
		{
			real red = i * 0.306
			real g = i * 0.816
			real b = i * 0.584
			c += cast(integer, b * 255.0)
			c += cast(integer, g * 255.0) * 256
			c += cast(integer, red * 255.0) * 65536
		}
	}
}


trace : Scene ref scene, Ray ref r, Point ref p, Vector ref v, Ray ref sr -> integer c = 0 [native]
{
	Geometry closestobj = scene.objects.value
	real t = 100000.0
	test(scene.objects, r, closestobj, t)
	if(t < 100000.0)
	{
		p.x = r.origin.x + r.direction.x * t
		p.y = r.origin.y + r.direction.y * t
		p.z = r.origin.z + r.direction.z * t

		v.x = scene.thelight.location.x - p.x
		v.y = scene.thelight.location.y - p.y
		v.z = scene.thelight.location.z - p.z
		normalize(v)

		c = shade(closestobj, scene, p, v, sr)
	}
}


structure Point2D :
	integer x,
	integer y

structure Rect :
	integer left,
	integer top,
	integer right,
	integer bottom

structure PaintInfo :
	integer hdc,
	boolean erase,
	Rect paintarea,
	boolean restore,
	boolean incupdate,
	integer reserved0,
	integer reserved1,
	integer reserved2,
	integer reserved3,
	integer reserved4,
	integer reserved5,
	integer reserved6,
	integer reserved7

structure WindowClass :
	integer Size,
	integer Style,
	(WindowProc : integer, integer, integer, integer -> integer),
	integer ClassExtra,
	integer WindowExtra,
	integer hInstance,
	integer hIcon,
	integer hCursor,
	integer hBackgroundBrush,
	string MenuName,
	string ClassName,
	integer hIconSmall


structure MessageInfo :
	integer hwnd,
	integer message,
	integer wparam,
	integer lparam,
	integer time,
	Point2D point


GetModuleHandle : integer null -> integer handle = 0 [external("Kernel32.dll", "GetModuleHandleW")]
RegisterClassEx : WindowClass wc -> integer16 atom = 0 [external("User32.dll", "RegisterClassExW")]
CreateWindowEx : integer exstyle, string classname, string windowname, integer style, integer x, integer y, integer width, integer height, integer hwndparent, integer hmenu, integer hinstance, integer param -> integer windowhandle = 0 [external("User32.dll", "CreateWindowExW")]
ShowWindow : integer hwnd, integer cmdshow -> integer success = 0 [external("User32.dll", "ShowWindow")]
PeekMessage : MessageInfo ref msg, integer hwnd, integer filtermin, integer filtermax, integer removeflag -> boolean success = false [external("User32.dll", "PeekMessageW")]
TranslateMessage : MessageInfo msg -> boolean success = false [external("User32.dll", "TranslateMessage")]
DispatchMessage : MessageInfo msg -> integer unused = 0 [external("User32.dll", "DispatchMessageW")]
BeginPaint : integer hwnd, PaintInfo ref paintinfo -> integer hdc = 0 [external("User32.dll", "BeginPaint")]
EndPaint : integer hwnd, PaintInfo paintinfo -> integer success = 0 [external("User32.dll", "EndPaint")]
PostQuitMessage : integer exitcode [external("User32.dll", "PostQuitMessage")]
DefWindowProc : integer hwnd, integer msg, integer wparam, integer lparam -> integer ret = 0 [external("User32.dll", "DefWindowProcW")]
DestroyWindow : integer handle -> integer ret = 0 [external("User32.dll", "DestroyWindow")]
InvalidateRect : integer hwnd, integer ignored, integer erase -> integer ret = 0 [external("User32.dll", "InvalidateRect")]
GetCursorPos : Point2D ref out -> integer ret = 0 [external("User32.dll", "GetCursorPos")]

LoadCursor : integer hinstance, integer cursorid -> integer cursorhandle = 0 [external("User32.dll", "LoadCursorW")]

SetWindowText : integer hwnd, string text -> integer result = 0 [external("User32.dll", "SetWindowTextW")]


MessageBox : integer hwnd, string message, string caption, integer style -> integer ret = 0 [external("User32.dll", "MessageBoxW")]


global
{
	buffer RenderedBitmap = 600 * 600 * 4
	integer FrameCount = 0
	integer AccumulatedDuration = 0
}


normalize : Vector ref in [native]
{
	real length = sqrt(in.x * in.x + in.y * in.y + in.z * in.z)
	in.x = in.x / length
	in.y = in.y / length
	in.z = in.z / length
}


rgb : Color ref c -> integer ret = 0 [native]
{
	ret += cast(integer, c.b * 255.0)
	ret += cast(integer, c.g * 255.0) * 256
	ret += cast(integer, c.r * 255.0) * 65536
}


timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime")]

Render : Scene ref scene, buffer ref bitmap [native]
{
	Vector zero2 = 0.0, 0.0, 0.0
	Ray ray = Point(0.0, 0.0, -10.0), zero2

	Point scratchp = 0.0, 0.0, 0.0
	Vector scratchv = 0.0, 0.0, 0.0
	Ray scratchr = scratchp, scratchv

	integer y = 0
	integer x = 0

	// TODO - see if we can figure out why LICM doesn't work without this prefetch stub
	ray.direction.x = 0.0
	ray.direction.y = 0.0
	ray.direction.z = 1.0
	normalize(ray.direction)
	plotpixel(bitmap, 0, trace(scene, ray, scratchp, scratchv, scratchr))
	
	while(y < 600)
	{
		while(x < 600)
		{
			ray.direction.x = cast(real, 300 - x) / 600.0
			ray.direction.y = cast(real, 300 - y) / 600.0
			ray.direction.z = 1.0
			normalize(ray.direction)

			integer c = trace(scene, ray, scratchp, scratchv, scratchr)
			plotpixel(bitmap, ((600 - y) * 600 + x), c)

			x = x + 1
		}

		x = 0
		y = y + 1
	}
}

entrypoint :
{
	DisplayWindow()
}

DoScene :
{
	Point2D cursorpos = 0, 0
	GetCursorPos(cursorpos)

	real rx = cast(real, 960 - cursorpos.x) / 40.0
	real ry = cast(real, 540 - cursorpos.y) / 40.0

	Point zero = 0.0, 0.0, 0.0

	Sphere sphere = zero, 1.0

	Vector pnorm = 0.0, 1.0, 0.0
	Plane plane = pnorm, 50.0

	Color white = 1.0, 1.0, 1.0
	Light light = Point(rx, ry, -10.0), white, 1.0

	list<Geometry> objects2 = plane, nothing
	list<Geometry> objects = sphere, objects2
	Camera camera = Point(0.0, 0.0, -10.0), Vector(0.0, 0.0, 1.0), 1.0, 1.0

	Scene scene = objects, light, camera

	Render(scene, RenderedBitmap)
}



AdjustWindowRect : Rect ref r, integer style, boolean menu -> boolean result = false [external("User32.dll", "AdjustWindowRect")]


DisplayWindow :
{
	integer IDC_ARROW = 32512
	integer COLOR_WINDOWFRAME = 6
	integer WS_OVERLAPPEDWINDOW = 13565952
	integer CW_USEDEFAULT = -2147483648
	integer SW_SHOW = 5
	integer MB_ICONEXCLAMATION = 0x30
	integer WM_QUIT = 0x12

	integer hInstance = GetModuleHandle(0)

	WindowClass wc = sizeof(wc), 0, MainWindowProcedure, 0, 0, hInstance, 0, LoadCursor(0, IDC_ARROW), COLOR_WINDOWFRAME, "", "RaytracerClass", 0
	RegisterClassEx(wc)

	Rect adjusted = 0, 0, 600, 600
	AdjustWindowRect(adjusted, WS_OVERLAPPEDWINDOW, false)

	integer hwnd = CreateWindowEx(0, "RaytracerClass", "Raytracer", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, adjusted.right - adjusted.left, adjusted.bottom - adjusted.top, 0, 0, hInstance, 0)

	ShowWindow(hwnd, SW_SHOW)

	Point2D pt = 0, 0
	MessageInfo msg = 0, 0, 0, 0, 0, pt

	while(msg.message != WM_QUIT)
	{
		if(PeekMessage(msg, 0, 0, 0, 1))
		{
			TranslateMessage(msg)
			DispatchMessage(msg)
		}
		else
		{
			integer startms = timeGetTime()

			DoScene()
			++FrameCount

			integer duration = timeGetTime() - startms
			AccumulatedDuration += duration

			if(FrameCount == 10)
			{
				real fps = 10000.0 / cast(real, AccumulatedDuration)
				string fpsstr = cast(string, fps)

				string title = "Raytracer - FPS: " ; fpsstr
				SetWindowText(hwnd, title)

				AccumulatedDuration = 0
				FrameCount = 0
			}

			InvalidateRect(hwnd, 0, 0)
		}
	}
}


structure BitmapInfoHeader :
	integer size,
	integer width,
	integer height,
	integer16 planes,
	integer16 bitcount,
	integer compression,
	integer sizeimage,
	integer xppm,
	integer yppm,
	integer used,
	integer important

SetDIBitsToDevice :
	integer hdc,
	integer xdest,
	integer ydest,
	integer width,
	integer height,
	integer xsrc,
	integer ysrc,
	integer startscan,
	integer scanlines,
	buffer ref bits,
	BitmapInfoHeader ref bitmap,
	integer coloruse
  ->
	integer unused = 0
  [external("Gdi32.dll", "SetDIBitsToDevice")]


MainWindowProcedure : integer hwnd, integer message, integer wparam, integer lparam -> integer ret = 0
{
	integer WM_PAINT = 15
	integer WM_DESTROY = 2
	integer DIB_RGB_COLORS = 0

	if(message == WM_PAINT)
	{
		Rect prect = 0, 0, 0, 0
		PaintInfo ps = 0, false, prect, false, false, 0, 0, 0, 0, 0, 0, 0, 0

		integer hdc = BeginPaint(hwnd, ps)

		BitmapInfoHeader bitmap = sizeof(bitmap), 600, 600, 1, 32, 0, 0, 0, 0, 0, 0
		SetDIBitsToDevice(hdc, 0, 0, 600, 600, 0, 0, 0, 600, RenderedBitmap, bitmap, DIB_RGB_COLORS)

		EndPaint(hwnd, ps)
	}
	elseif(message == WM_DESTROY)
	{
		PostQuitMessage(0)
	}
	else
	{
		ret = DefWindowProc(hwnd, message, wparam, lparam)
	}
}
