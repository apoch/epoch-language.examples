//
// Some working thought-space for the raytracer project for R14
//


type listnode<type T> : list<T> | nothing

structure list<type T> :
	T value,
	listnode<T> next



structure Point :
	real x,
	real y,
	real z

// TODO - fix type aliases
structure Vector :
	real x,
	real y,
	real z

structure Ray :
	Point origin,
	Vector direction


structure Sphere :
	Point center,
	real radius


structure Plane :
	Point origin,
	Vector normal


type Geometry : Sphere | Plane



structure Color :
	real r,
	real g,
	real b


structure Light :
	Point location,
	Color color,
	real intensity


dot : Vector ref v1, Vector ref v2 -> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z [native]
dot : Vector ref v1, Point ref v2 -> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z [native]
dot : Point ref v1, Point ref v2 -> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z [native]


//intersect : Plane ref p, Ray ref r -> real t = 100000.0
//{
	// TODO - implement plane intersection code
//}

intersect : Sphere ref s, Ray ref r -> real t = 100000.0 [native]
{
	// TODO - transform ray into object space

	real b = dot(r.direction, r.origin)
	real c = dot(r.origin, r.origin) - 1.0
	real disc = 4.0 * (b * b - c)

	if(disc > 0.0)
	{
		real distSqrt = sqrt(disc)
		real t0 = 0.0
		if(b < 0.0)
		{
			t0 = (-2.0*b - distSqrt) / 2.0
		}
		else
		{
			t0 = (-2.0*b + distSqrt) / 2.0
		}

		real t1 = c / t0

		if(t0 > t1)
		{
			real temp = t0
			t0 = t1
			t1 = temp
		}

		if(t1 > 0.0)
		{
			if(t0 < 0.0)
			{
				t = t1
			}
			else
			{
				t = t0
			}
		}
	}
}


structure Camera :
	Point location,
	Vector direction,
	real horizontalFOV,
	real verticalFOV

structure Scene :
	list<Geometry> objects,
	Light thelight,
	Camera camera


test : nothing, Ray ref r, Geometry ref closest, real ref t [native]

test : list<Geometry> ref geometry, Ray ref r, Geometry ref closest, real ref t [native]
{
	real thist = intersect(geometry.value, r)
	if(thist < t)
	{
		t = thist
		closest = geometry.value
	}

	listnode<Geometry> nextnode = geometry.next
	test(nextnode, r, closest, t)
}

shade : Sphere ref s, Scene ref scene, Ray ref r, real t -> integer c = 0 [native]
{
	real px = r.origin.x + r.direction.x * t
	real py = r.origin.y + r.direction.y * t
	real pz = r.origin.z + r.direction.z * t

	Vector normal = px - s.center.x, py - s.center.y, pz - s.center.z
	normalize(normal)

	Vector lightdir = scene.thelight.location.x - px, scene.thelight.location.y - py, scene.thelight.location.z - pz
	normalize(lightdir)

	real i = dot(normal, lightdir)
	if(i > 0.0)
	{
		Color cs = i * 0.306, i * 0.584, i * 0.816
		c = rgb(cs)
	}
}


trace : Scene ref scene, Ray ref r -> integer c = 0 [native]
{
	Geometry closestobj = scene.objects.value
	real t = 100000.0
	test(scene.objects, r, closestobj, t)
	if(t < 100000.0)
	{
		c = shade(closestobj, scene, r, t)
	}
}


structure Point2D :
	integer x,
	integer y

structure Rect :
	integer left,
	integer top,
	integer right,
	integer bottom

structure PaintInfo :
	integer hdc,
	boolean erase,
	Rect paintarea,
	boolean restore,
	boolean incupdate,
	integer reserved0,
	integer reserved1,
	integer reserved2,
	integer reserved3,
	integer reserved4,
	integer reserved5,
	integer reserved6,
	integer reserved7

structure WindowClass :
	integer Size,
	integer Style,
	(WindowProc : integer, integer, integer, integer -> integer),
	integer ClassExtra,
	integer WindowExtra,
	integer hInstance,
	integer hIcon,
	integer hCursor,
	integer hBackgroundBrush,
	string MenuName,
	string ClassName,
	integer hIconSmall


structure MessageInfo :
	integer hwnd,
	integer message,
	integer wparam,
	integer lparam,
	integer time,
	Point2D point


GetModuleHandle : integer null -> integer handle = 0 [external("Kernel32.dll", "GetModuleHandleW")]
RegisterClassEx : WindowClass wc -> integer16 atom = 0 [external("User32.dll", "RegisterClassExW")]
CreateWindowEx : integer exstyle, string classname, string windowname, integer style, integer x, integer y, integer width, integer height, integer hwndparent, integer hmenu, integer hinstance, integer param -> integer windowhandle = 0 [external("User32.dll", "CreateWindowExW")]
ShowWindow : integer hwnd, integer cmdshow -> integer success = 0 [external("User32.dll", "ShowWindow")]
PeekMessage : MessageInfo ref msg, integer hwnd, integer filtermin, integer filtermax, integer removeflag -> boolean success = false [external("User32.dll", "PeekMessageW")]
TranslateMessage : MessageInfo msg -> boolean success = false [external("User32.dll", "TranslateMessage")]
DispatchMessage : MessageInfo msg -> integer unused = 0 [external("User32.dll", "DispatchMessageW")]
BeginPaint : integer hwnd, PaintInfo ref paintinfo -> integer hdc = 0 [external("User32.dll", "BeginPaint")]
EndPaint : integer hwnd, PaintInfo paintinfo -> integer success = 0 [external("User32.dll", "EndPaint")]
PostQuitMessage : integer exitcode [external("User32.dll", "PostQuitMessage")]
DefWindowProc : integer hwnd, integer msg, integer wparam, integer lparam -> integer ret = 0 [external("User32.dll", "DefWindowProcW")]
DestroyWindow : integer handle -> integer ret = 0 [external("User32.dll", "DestroyWindow")]
InvalidateRect : integer hwnd, integer ignored, integer erase -> integer ret = 0 [external("User32.dll", "InvalidateRect")]
GetCursorPos : Point2D ref out -> integer ret = 0 [external("User32.dll", "GetCursorPos")]

LoadCursor : integer hinstance, integer cursorid -> integer cursorhandle = 0 [external("User32.dll", "LoadCursorW")]

SetWindowText : integer hwnd, string text -> integer result = 0 [external("User32.dll", "SetWindowTextW")]


MessageBox : integer hwnd, string message, string caption, integer style -> integer ret = 0 [external("User32.dll", "MessageBoxW")]


global
{
	buffer RenderedBitmap = 600 * 600 * 4
}


normalize : Vector ref in [native]
{
	real length = sqrt(in.x * in.x + in.y * in.y + in.z * in.z)
	in.x = in.x / length
	in.y = in.y / length
	in.z = in.z / length
}


rgb : Color ref c -> integer ret = 0 [native]
{
	ret += cast(integer, c.b * 255.0)
	ret += cast(integer, c.g * 255.0) * 256
	ret += cast(integer, c.r * 255.0) * 65536
}


timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime")]

Render : Scene ref scene, buffer ref bitmap [native]
{
	Vector zero2 = 0.0, 0.0, 0.0
	Ray ray = Point(0.0, 0.0, -10.0), zero2

	integer yoffset = 0

	integer y = 0
	integer x = 0

	real rayy = 0.0

	ray.direction.x = 0.0
	ray.direction.y = 0.0
	ray.direction.z = 1.0
	normalize(ray.direction)
	plotpixel(bitmap, 0, trace(scene, ray))
	
	while(y < 600)
	{
		rayy = cast(real, 300 - y) / 600.0
		yoffset = (600 - y) * 600
		x = 0
		while(x < 600)
		{
			ray.direction.x = cast(real, 300 - x) / 600.0
			ray.direction.y = rayy
			ray.direction.z = 1.0
			normalize(ray.direction)

			integer c = trace(scene, ray)
			plotpixel(bitmap, (yoffset + x), c)

			x = x + 1
		}

		y = y + 1
	}
}

entrypoint :
{
	DisplayWindow()
}


DoScene :
{
	Point2D cursorpos = 0, 0
	GetCursorPos(cursorpos)

	real rx = cast(real, 960 - cursorpos.x) / 40.0
	real ry = cast(real, 540 - cursorpos.y) / 40.0

	Point zero = 0.0, 0.0, 0.0

	Sphere sphere = zero, 1.0

	Color white = 1.0, 1.0, 1.0
	Light light = Point(rx, ry, -10.0), white, 1.0

	list<Geometry> objects = sphere, nothing	
	Camera camera = Point(0.0, 0.0, -10.0), Vector(0.0, 0.0, 1.0), 1.0, 1.0

	Scene scene = objects, light, camera

	Render(scene, RenderedBitmap)
}



AdjustWindowRect : Rect ref r, integer style, boolean menu -> boolean result = false [external("User32.dll", "AdjustWindowRect")]


DisplayWindow :
{
	integer IDC_ARROW = 32512
	integer COLOR_WINDOWFRAME = 6
	integer WS_OVERLAPPEDWINDOW = 13565952
	integer CW_USEDEFAULT = -2147483648
	integer SW_SHOW = 5
	integer MB_ICONEXCLAMATION = 0x30
	integer WM_QUIT = 0x12

	integer hInstance = GetModuleHandle(0)

	WindowClass wc = sizeof(wc), 0, MainWindowProcedure, 0, 0, hInstance, 0, LoadCursor(0, IDC_ARROW), COLOR_WINDOWFRAME, "", "RaytracerClass", 0
	RegisterClassEx(wc)

	Rect adjusted = 0, 0, 600, 600
	AdjustWindowRect(adjusted, WS_OVERLAPPEDWINDOW, false)

	integer hwnd = CreateWindowEx(0, "RaytracerClass", "Raytracer", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, adjusted.right - adjusted.left, adjusted.bottom - adjusted.top, 0, 0, hInstance, 0)

	ShowWindow(hwnd, SW_SHOW)

	Point2D pt = 0, 0
	MessageInfo msg = 0, 0, 0, 0, 0, pt

	while(msg.message != WM_QUIT)
	{
		if(PeekMessage(msg, 0, 0, 0, 1))
		{
			TranslateMessage(msg)
			DispatchMessage(msg)
		}
		else
		{
			integer startms = timeGetTime()

			DoScene()

			integer duration = timeGetTime() - startms

			real fps = 1000.0 / cast(real, duration)
			string fpsstr = cast(string, fps)

			string title = "Raytracer - FPS: " ; fpsstr
			SetWindowText(hwnd, title)

			InvalidateRect(hwnd, 0, 0)
		}
	}
}


structure BitmapInfoHeader :
	integer size,
	integer width,
	integer height,
	integer16 planes,
	integer16 bitcount,
	integer compression,
	integer sizeimage,
	integer xppm,
	integer yppm,
	integer used,
	integer important

SetDIBitsToDevice :
	integer hdc,
	integer xdest,
	integer ydest,
	integer width,
	integer height,
	integer xsrc,
	integer ysrc,
	integer startscan,
	integer scanlines,
	buffer ref bits,
	BitmapInfoHeader ref bitmap,
	integer coloruse
  ->
	integer unused = 0
  [external("Gdi32.dll", "SetDIBitsToDevice")]


MainWindowProcedure : integer hwnd, integer message, integer wparam, integer lparam -> integer ret = 0
{
	integer WM_PAINT = 15
	integer WM_DESTROY = 2
	integer DIB_RGB_COLORS = 0

	if(message == WM_PAINT)
	{
		Rect prect = 0, 0, 0, 0
		PaintInfo ps = 0, false, prect, false, false, 0, 0, 0, 0, 0, 0, 0, 0

		integer hdc = BeginPaint(hwnd, ps)

		BitmapInfoHeader bitmap = sizeof(bitmap), 600, 600, 1, 32, 0, 0, 0, 0, 0, 0
		SetDIBitsToDevice(hdc, 0, 0, 600, 600, 0, 0, 0, 600, RenderedBitmap, bitmap, DIB_RGB_COLORS)

		EndPaint(hwnd, ps)
	}
	elseif(message == WM_DESTROY)
	{
		PostQuitMessage(0)
	}
	else
	{
		ret = DefWindowProc(hwnd, message, wparam, lparam)
	}
}

