
AttachContextToFunction : FunctionDefinition ref funcraw, integer mangledfuncname, FunctionDefinition ref func
{
	AttachContextToOverload(funcraw.Overloads, mangledfuncname, func)
}


IRRegisterFunctionParam : integer paramname, integer paramtypename, boolean isref, boolean templated
{
	UnresolvedParameter p = paramname, paramtypename, 0, isref, nothing, nothing

	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		p.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, FunctionParams ref params, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(params.Params, params.Params.next, p)
}

AppendUnresolvedParameterToFunction : FunctionDefinition ref func, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	FunctionParams fp = newlist
	OptionalParameters params = fp
	func.Params = params
}


AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, list<UnresolvedParameter> ref tail, UnresolvedParameter ref p
{
	AppendUnresolvedParameter(tail, tail.next, p)
}

AppendUnresolvedParameter : list<UnresolvedParameter> ref thelist, nothing, UnresolvedParameter ref p
{
	list<UnresolvedParameter> newlist = p, nothing
	thelist.next = newlist
}



FunctionIsAutoGenOrHasIR : integer funcname -> boolean ret = false
{
	if(IsRecognizedBuiltIn(funcname))
	{
		return()
	}

	if(SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, funcname))
	{
		ret = true
	}
	elseif(FunctionIsAutoGen(AutoGeneratedFunctionNames, funcname))
	{
		ret = true
	}
	elseif(TypeMatcherExists(TypeMatchers, funcname))
	{
		ret = true
	}
	elseif(PatternMatcherExists(PendingPatternMatchers, funcname))
	{
		ret = true
	}
}

FunctionIsAutoGen : simplelist<integer> ref genlist, integer target -> boolean ret = false [nogc]
{
	if(genlist.value == target)
	{
		ret = true
	}
	else
	{
		ret = FunctionIsAutoGen(genlist.next, target)
	}
}

FunctionIsAutoGen : nothing, integer target -> boolean ret = false [nogc]


AppendParameter : list<Parameter> ref params, Parameter ref p
{
	AppendParameterRecurse(params, params.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, list<Parameter> ref tail, Parameter ref p
{
	AppendParameterRecurse(tail, tail.next, p)
}

AppendParameterRecurse : list<Parameter> ref params, nothing, Parameter ref p
{
	list<Parameter> newlist = p, nothing
	params.next = newlist
}



CountParameters : list<Parameter> ref params -> integer count = 0 [nogc]
{
	count = CountParameters(params.next)

	if(params.value.Type != 0)
	{
		++count
	}
}

CountParameters : nothing -> integer count = 0 [nogc]


FindFunctionAndSetInvokeTag : list<FunctionDefinition> ref functions, integer funcname, integer invoketarget [nogc]
{
	if(functions.value.Name == funcname)
	{
		functions.value.InvokeTag = invoketarget
	}
	else
	{
		FindFunctionAndSetInvokeTag(functions.next, funcname, invoketarget)
	}
}

FindFunctionAndSetInvokeTag : nothing, integer funcname, integer invoketarget [nogc]
{
	print("Cannot tag non-existent function")
	assert(false)
}


AppendFunctionTagParam : list<string> ref params, list<string> ref tail, string param
{
	AppendFunctionTagParam(tail, tail.next, param)
}

AppendFunctionTagParam : list<string> ref params, nothing, string param
{
	list<string> newlist = param, nothing
	params.next = newlist
}
