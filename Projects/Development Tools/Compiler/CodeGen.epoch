
//
// Callback invoked when the code generation process can begin
//

OnCodeGenProcessProgram :
{
	GenerateTypeMatcherMappings(Functions)
	GeneratePendingTypeMatchers(PendingTypeMatchers)

	CodeGenEmitStrings(GlobalStrings)
	CodeGenEmitSumTypes()
	CodeGenRearrangeStructures(Structures)
	CodeGenEmitStructures(Structures)
	CodeGenEmitFunctionSignatures(FunctionSignatures)

	if(GlobalCodeBlockName != 0)
	{
		CodeGenEmitSpecificScope(GlobalScope.Wrapped)
	}

	CodeGenEmitScopes()
	CodeGenEmitFunctionTags(GlobalRootNamespace.FunctionTags)
	CodeGenEmitGlobalBlockPrologue(GlobalCodeBlock)
	CodeGenEmitFunctions(Functions)
	CodeGenEmitGlobalBlockEpilogue(GlobalCodeBlock)
	CodeGenEmitTypeMatchers(TypeMatchers)
	CodeGenEmitPatternMatchers(PendingPatternMatchers)
	CodeGenEmitConstructors(Structures)
}

OnCodeGenRegisterString : integer handle, string data [nogc]
{
	StringTableEntry entry = handle, data
	prepend<StringTableEntry>(GlobalStrings, entry)

	PlaceDataInTrie(GlobalStringTrie, data, handle)

	if(handle > CurrentStringHandle)
	{
		CurrentStringHandle = handle
	}
}

OnCodeGenRegisterStructureMemVar : integer structurename, integer structuretype, integer membername, integer typenamehandle, boolean isref, boolean templated [nogc]
{
	integer refnum = 0
	if(isref)
	{
		refnum = 0x80000000
	}

	StructureMemberVariable member = membername, refnum, typenamehandle, nothing
	if(templated)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		member.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	StructureMember memwrap = member
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSig : integer structurename, integer structuretype, integer name, integer rettypename [nogc]
{
	list<Parameter> p = dummyparam, nothing
	FunctionSignature signature = name, p, rettypename, false
	StructureMemberFunctionRef m = name, signature
	StructureMember memwrap = m
	FindStructureAndAddMember(Structures, structurename, structuretype, memwrap)
}

OnCodeGenRegisterStructureMemFuncSigParam : integer structurename, integer structuretype, integer membername, integer paramtype
{
	Parameter param = 1, paramtype
	FindStructureAndAddMemberParam(Structures, structurename, structuretype, membername, param)
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, simplelist<integer> ref typenames
{
	OnCodeGenRegisterStructureMemFuncSigParamList(structurename, structuretype, membername, typenames.next)

	if(typenames.value != 0)
	{
		OnCodeGenRegisterStructureMemFuncSigParam(structurename, structuretype, membername, typenames.value)
	}
}

OnCodeGenRegisterStructureMemFuncSigParamList : integer structurename, integer structuretype, integer membername, nothing





OnCodeGenRegisterConstructors : integer structurename, integer constructorname, integer anonname, integer copyname [nogc]
{
	FindStructureAndSetConstructors(structurename, constructorname, anonname, copyname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, constructorname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, anonname)
	simpleprepend<integer>(AutoGeneratedFunctionNames, copyname)
}

OnCodeGenRegisterScope : integer scopename, integer parentname, boolean attachtofunction
{
	list<Variable> v = dummyvar, nothing
	Scope scope = scopename, parentname, v, 0, 0
	
	BinaryTreeCreateOrInsert<Scope>(GlobalRootNamespace.Scopes, scopename, scope)
	
	if(attachtofunction)
	{
		Functions.value.AttachedScope.Wrapped = scope
	}
}


OnCodeGenRegisterGlobalBlock : integer name
{
	ContextStackEntry entry = STACK_TYPE_GLOBAL, name
	prepend<ContextStackEntry>(ContextStack, entry)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	GlobalCodeBlockName = name
	
	
	CacheGlobalCodeBlock()
}


OnCodeGenRegisterFunction : integer funcname, integer rawfuncname, string rawfuncnamestr, boolean istemplate
{
	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = rawfuncname, funcname, nothing, nothing, nothing, dummyoverloadlist, scopewrap, rawfuncnamestr, 0, false, istemplate, false
	prepend<FunctionDefinition>(Functions, func)
	InsertIntoBinaryTree<FunctionDefinition>(FunctionsWhichExist, funcname, func)

	// TODO - this is a weird bug. For some reason we don't init the field correctly in the above constructor
	if(istemplate)
	{
		func.IsTemplate = true
	}

	if(funcname != rawfuncname)
	{	
		ContextNode<FunctionDefinition> wrap = nothing
		if(SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, rawfuncname, wrap))
		{
			AttachContextToFunction(wrap, funcname, func)
		}
	}
	
	Overload selfoverload = rawfuncname, funcname, func
	prepend<Overload>(func.Overloads, selfoverload)

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	if(istemplate)
	{
		CreateFunctionTemplateAndAttachParams(funcname, TemplateParameterQueue)

		// Reset template parameter queue
		list<TemplateParameter> dummylist = scratchtemplateparam, nothing
		TemplateParameterQueue = dummylist
	}
}


OnCodeGenEnterFunctionBody : integer funcname
{
	ContextStackEntry entry = STACK_TYPE_FUNCTION, funcname
	prepend<ContextStackEntry>(ContextStack, entry)
}

OnCodeGenEnterFunctionReturn : integer funcname, boolean anonymous
{
	ContextStackEntry entry = STACK_TYPE_FUNCRET, funcname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d

	Functions.value.AnonymousReturn = anonymous
	InFuncRetHack = true
}

OnCodeGenExitContext :
{
	integer entrytype = ContextStack.value.EntryType
	PopContext(ContextStack, ContextStack.next)

	if(entrytype == STACK_TYPE_STATEMENT)
	{
		if(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
		{
			AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		}
		elseif(ContextStack.value.EntryType != STACK_TYPE_SUBSTATEMENT)
		{
			FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
		}
	}
	elseif(entrytype == STACK_TYPE_ASSIGNMENT)
	{
		FindCurrentAssignmentAndSetExpression(ScratchExpressions.value)
	}
	elseif(entrytype == STACK_TYPE_SUBSTATEMENT)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
		PopCurrentStatementAndAppendToScratchExpression(ScratchExpressions, ScratchExpressions.next)
	}
	elseif(entrytype == STACK_TYPE_FUNCRET)
	{
		SetReturnExpression(Functions.value, ScratchExpressions.value)
		InFuncRetHack = false
	}
	elseif(entrytype == STACK_TYPE_FUNCTION)
	{
		assertmsg(CodeBlockDepth(CurrentCodeBlockStack) == 1, "Code block depth is invalid")
		SetFunctionCodeBlock(Functions.value, CurrentCodeBlockStack.value)
	}
	elseif(entrytype == STACK_TYPE_ENTITY_CODE)
	{
		Entity entity = EntityStack.value.Tag, EntityStack.value.PostfixTag, EntityStack.value.Param, CurrentCodeBlockStack.value
		AppendEntityToChain(ChainStack, entity)
		PopEntityStack(EntityStack, EntityStack.next)
		PopCodeBlock(CurrentCodeBlockStack, CurrentCodeBlockStack.next)
	}
	elseif(entrytype == STACK_TYPE_CHAIN)
	{
		CodeBlockEntry cbe = ChainStack.value
		AppendEntryToCurrentCodeBlock(cbe)
		PopChain(ChainStack, ChainStack.next)
	}
	elseif(entrytype == STACK_TYPE_PARENTHETICAL)
	{
		ExpressionOrPrePostOp epp = ScratchExpressions.value
		ParentheticalExpression parenthetical = epp
		ExpressionAtom atom = parenthetical
		PopExpression(ScratchExpressions, ScratchExpressions.next)
		PlaceAtomInScratchExpression(atom)
	}
	elseif(entrytype == STACK_TYPE_GLOBAL)
	{
		SetGlobalCodeBlock(CurrentCodeBlockStack.value)
	}
}


OnCodeGenEnterTypeMatcher : integer matchername
{
	ContextStackEntry entry = STACK_TYPE_TYPEMATCH, matchername
	prepend<ContextStackEntry>(ContextStack, entry)

	list<FunctionSignature> dsl = dummysignature, nothing
	TypeMatcher matcher = matchername, dsl
	prepend<TypeMatcher>(TypeMatchers, matcher)
}


OnCodeGenRegisterLiteralBoolean : boolean value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralInteger : integer value, integer literaltype
{
	while((literaltype & 0xff000000) == 0x05000000)
	{
		literaltype = FindTypeAliasBase(literaltype)
	}

	if(literaltype == 0x01000001)		// Integer32 type signature
	{
		ExpressionAtom atom = value
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		integer16 i16value = cast(integer16, value)
		ExpressionAtom atom = i16value
		PlaceAtomInScratchExpression(atom)
	}
}

OnCodeGenRegisterLiteralString : integer handle
{
	StringHandleAtom sha = handle
	ExpressionAtom atom = sha
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterLiteralReal : real value
{
	ExpressionAtom atom = value
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterOperatorInvoke : integer ophandle
{
	OperatorInvokeAtom oia = ophandle
	ExpressionAtom atom = oia
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifier : integer idhandle, integer idtype
{
	IdentifierAtom id = idhandle, idtype, false, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterAtomIdentifierReference : integer idhandle
{
	IdentifierAtom id = idhandle, 0, true, false
	ExpressionAtom atom = id
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenRegisterTypeAnnotation : integer annotationtype
{
	TypeAnnotationAtom taa = annotationtype
	ExpressionAtom atom = taa
	PlaceAtomInScratchExpression(atom)
}


OnCodeGenRegisterRefBinding : integer id, integer structureid, boolean isref, boolean inputref
{
	RefBinding binding = id, structureid, isref, inputref
	ExpressionAtom atom = binding
	PlaceAtomInScratchExpression(atom)
}

OnCodeGenEnterStatement : integer statementname, integer statementtype, boolean toplevel, boolean hastemplateargs
{
	Statement statement = statementname, nothing, statementtype, nothing, toplevel, false

	if(hastemplateargs)
	{
		PopTemplateArgList(ScratchTemplateArgumentStack.value.Args, ScratchTemplateArgumentStack.value.Args.next)
		statement.TemplateArgs = ScratchTemplateArgumentStack.value

		PopTemplateArgStack(ScratchTemplateArgumentStack, ScratchTemplateArgumentStack.next)
	}

	OnCodeGenEmplaceStatement(statement)
}

OnCodeGenEmplaceStatement : Statement ref statement
{
	if(ContextStack.value.EntryType == STACK_TYPE_SUBSTATEMENT)
	{
		prepend<Statement>(SubStatements, statement)
	}
	elseif(ContextStack.value.EntryType == STACK_TYPE_FUNCRET)
	{
		prepend<Statement>(SubStatements, statement)
	}
	else
	{
		CodeBlockEntry cbe = statement
		AppendEntryToCurrentCodeBlock(cbe)
		LastTopLevelStatementHack.Wrapped = statement
	}

	ContextStackEntry entry = STACK_TYPE_STATEMENT, statement.Name
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}


OnCodeGenEnterMessageSend : integer targetname, integer messagename
{
	MessageSend msg = targetname, messagename, nothing, 0, nothing, false
	
	CodeBlockEntry cbe = msg
	AppendEntryToCurrentCodeBlock(cbe)
	
	ContextStackEntry entry = STACK_TYPE_MESSAGE, msg.MessageName
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression expr = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, expr)
}


OnCodeGenEnterTask : integer taskname
{
	ContextStackEntry entry = STACK_TYPE_TASK, taskname
	prepend<ContextStackEntry>(ContextStack, entry)
}


OnCodeGenEnterAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)

	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, lhsname
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}


OnCodeGenChainAssignment : integer operator, integer lhsname, integer lhstype, integer annotation
{
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	Assignment assignment = operator, lhsname, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}


OnCodeGenEnterAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	CodeBlockEntry cbe = assignment
	AppendEntryToCurrentCodeBlock(cbe)
}

OnCodeGenAssignmentCompoundEnd :
{
	ContextStackEntry entry = STACK_TYPE_ASSIGNMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression blank = dummyatomlist, 0
	ScratchExpressions.value = blank
}



OnCodeGenChainAssignmentCompound : integer operator, integer lhsname, integer lhstype, integer annotation
{
	simplelist<integer> idlist = lhsname, nothing
	Expression tempexpr = dummyatomlist, 0
	ExpressionOrAssignment rhs = tempexpr
	AssignmentCompound assignment = operator, idlist, lhstype, annotation, rhs
	AppendEntryToCurrentAssignmentChain(assignment)
}

OnCodeGenEnterSubStatement :
{
	ContextStackEntry entry = STACK_TYPE_SUBSTATEMENT, 0
	prepend<ContextStackEntry>(ContextStack, entry)
}







CodeGenEmitStrings : list<StringTableEntry> ref table
{
	listnode<StringTableEntry> cur = table
	while(HasSTEntry(cur))
	{
		if(GetSTHandle(cur) != 0)
		{
			OnBytecodePoolString(GetSTHandle(cur), GetSTData(cur))
		}

		cur = GetSTNext(cur)
	}
}

HasSTEntry : list<StringTableEntry> ref table -> true
HasSTEntry : nothing -> false

GetSTHandle : list<StringTableEntry> ref table -> integer handle = table.value.Handle
GetSTData : list<StringTableEntry> ref table -> string data = table.value.Data
GetSTNext : list<StringTableEntry> ref table -> listnode<StringTableEntry> ret = table.next

CodeGenEmitStructures : list<StructureDefinition> ref structures
{
	CodeGenEmitStructures(structures.next)

	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		OnBytecodeDefineStructure(structures.value.Type, structures.value.MemberCount)
		CodeGenEmitMembers(structures.value.Members)
	}
}

CodeGenEmitStructures : nothing

CodeGenEmitMembers : list<StructureMember> ref members
{
	CodeGenEmitMember(members.value)
	CodeGenEmitMembers(members.next)
}

CodeGenEmitMembers : nothing

CodeGenEmitMember : StructureMemberVariable ref memvar
{
	OnBytecodeStructureMember(memvar.Name, memvar.Type)
}

CodeGenEmitMember : StructureMemberFunctionRef ref member
{
	OnBytecodeStructureMember(member.Name, GetMemberTypeDecompose(member))
}



CodeGenEmitSingleScope : Scope ref scope -> boolean ret = true
{
	if((scope.Name != 0) && (scope.Name != GlobalCodeBlockName))
	{
		integer parentname = scope.ParentName
		if((parentname == 0) && (scope.Name != GlobalCodeBlockName))
		{
			parentname = GlobalCodeBlockName
		}

		integer varcount = CountScopeVariables(scope)
		OnBytecodeLexicalScope(scope.Name, parentname, varcount)
		CodeGenEmitVariables(scope.Variables, scope.Name)
	}
}

CodeGenEmitScopes :
{
	BinaryTreeWalkAllNodes<Scope>(GlobalRootNamespace.Scopes.RootNode, CodeGenEmitSingleScope)
}


CodeGenEmitSpecificScope : Scope ref scope
{
	integer varcount = CountScopeVariables(scope)
	OnBytecodeLexicalScope(scope.Name, 0, varcount)
	CodeGenEmitVariables(scope.Variables, 0)
}


CodeGenEmitVariables : list<Variable> ref vars, integer funcname
{
	if(vars.value.Name != 0)
	{
		integer basetype = vars.value.VarType
		while((basetype & 0x7f000000) == 0x05000000)
		{
			basetype = FindTypeAliasBase(basetype)
		}

		if(vars.value.Origin == 2)
		{
			if(listcontains(CustomConstructors, funcname))
			{
				OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, 0)
			}
			else
			{
				OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, vars.value.Origin)
			}
		}
		else
		{
			OnBytecodeLexicalScopeEntry(vars.value.Name, basetype, vars.value.Origin)
		}
	}

	CodeGenEmitVariables(vars.next, funcname)
}

CodeGenEmitVariables : nothing, integer funcname



CodeGenEmitFunctions : list<FunctionDefinition> ref table
{
	if(!table.value.IsTemplate)
	{
		if(table.value.Name != 0)
		{
			FindScopeAndSetContext(table.value)

			EmittingFunctionName = table.value.Name
			OnBytecodeEnterFunction(table.value.Name)
			CodeGenEmitFunctionReturn(table.value.Return)

			if(table.value.InvokeTag != 0)
			{
				OnBytecodeInvoke(table.value.InvokeTag)
			}

			CodeGenEmitCodeBlock(table.value.Code)
			if(listcontains(CustomConstructors, table.value.Name))
			{
				OnBytecodePushVarValueNoCopy(FindReturnVariableName())
				OnBytecodeBindReference(0, 0)			// TODO - kind of a hack
				OnBytecodeAssign()
			}
			else
			{
				if(table.value.AnonymousReturn)
				{
					CodeGenEmitReturnRegisterAnonymous(table.value.Return)
				}
				else
				{
					CodeGenEmitReturnRegister(table.value.Return)
				}
			}
			OnBytecodeExitFunction()
		}
	}

	CodeGenEmitFunctions(table.next)
}

CodeGenEmitFunctions : nothing


CodeGenEmitFunctionReturn : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitFunctionReturn : nothing


CodeGenEmitReturnRegister : Expression ref expr
{
	integer index = FindReturnVariableIndex()
	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegister : nothing


CodeGenEmitReturnRegisterAnonymous : Expression ref expr
{
	integer index = FindReturnVariableIndex()

	OnBytecodeBindReference(0, index)
	OnBytecodeAssign()

	OnBytecodeSetReturnRegister(index)
}

CodeGenEmitReturnRegisterAnonymous : nothing



CodeGenEmitCodeBlock : CodeBlock ref block
{
	CodeGenEmitCodeBlockEntries(block.Entries)
}

CodeGenEmitCodeBlock : nothing


CodeGenEmitCodeBlockEntries : list<CodeBlockEntry> ref entries
{
	CodeGenEmitSingleCodeBlockEntry(entries.value)
	CodeGenEmitCodeBlockEntries(entries.next)
}

CodeGenEmitCodeBlockEntries : nothing


CodeGenEmitSingleCodeBlockEntry : Statement ref s
{
	boolean constructssumtype = false
	if((s.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtype = true
	}

	boolean constructorcall = StructureConstructorExists(Structures, s.Name)

	CodeGenEmitExpressionList(s.Parameters, constructssumtype, constructorcall)

	if(FunctionIsAutoGenOrHasIR(s.Name))
	{
		OnBytecodeInvokeOffset(s.Name)
	}
	elseif(SumTypeExists(s.Name))
	{
		OnBytecodeConstructSumType()
	}
	else
	{
		integer vartype = GetVariableTypeFromScope(EmittingScope.Wrapped, s.Name)
		if((vartype != 0) && ((vartype & 0x7f000000) == 0x09000000))
		{
			OnBytecodeInvokeIndirect(s.Name)
		}
		else
		{
			if(!IsRecognizedBuiltIn(s.Name))
			{
				print("ILLEGAL EXTERNAL FUNCTION: " ; GetPooledString(GlobalStrings, s.Name))
				assert(false)
			}
			
			OnBytecodeInvoke(s.Name)
		}
	}
}

CodeGenEmitSingleCodeBlockEntry : MessageSend ref m
{
	// TODO - send message to target task instead of just invoking a function
	CodeGenEmitExpressionList(m.Parameters, false, false)
	OnBytecodeInvokeOffset(m.MessageName)
}

CodeGenEmitAssignmentRHS : Expression ref expr
{
	CodeGenEmitExpressionAtoms(expr.Atoms, false, false)
}

CodeGenEmitAssignmentRHS : Assignment ref a
{
	CodeGenEmitAssignmentRHS(a.RHS)

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}

	CodeGenEmitBindingsForVariable(a.LHSName)
	OnBytecodeReadReference()
}

CodeGenEmitSingleCodeBlockEntry : Assignment ref a
{
	boolean sideeffects = false

	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForVariable(a.LHSName)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)

	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHSName, frames)
	OnBytecodeBindReference(frames, index)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}

CodeGenEmitSingleCodeBlockEntry : AssignmentCompound ref a
{
	boolean sideeffects = false
	if(a.Operator != PooledStringHandleForAssignment)
	{
		sideeffects = true
		CodeGenEmitBindingsForOperand(a.LHS)
		OnBytecodeReadReference()
	}

	CodeGenEmitAssignmentRHS(a.RHS)

	if(sideeffects)
	{
		OnBytecodeInvoke(a.Operator)
	}

	if(a.Annotation != 0)
	{
		OnBytecodePushTypeAnnotation(a.Annotation)
	}

	integer frames = 0
	integer index = FindVariable(a.LHS.value, frames)
	OnBytecodeBindReference(frames, index)

	integer typeid = MakeNonReferenceType(FindVariableType(a.LHS.value))

	integer structurename = GetNameOfStructureByType(typeid)
	BindAssignmentMembers(a.LHS.next, structurename)

	if((a.LHSType & 0x7f000000) == 0x07000000)
	{
		OnBytecodeAssignSumType()
	}
	else
	{
		OnBytecodeAssign()
	}
}


CodeGenEmitBindingsForOperand : simplelist<integer> ref operand
{
	integer frames = 0
	integer index = FindVariable(operand.value, frames)
	OnBytecodeBindReference(frames, index)

	integer structurename = GetNameOfStructureByType(FindVariableType(operand.value))
	BindAssignmentMembers(operand.next, structurename)
}

CodeGenEmitBindingsForVariable : integer operand
{
	integer frames = 0
	integer index = FindVariable(operand, frames)
	OnBytecodeBindReference(frames, index)
}


CodeGenEmitSingleCodeBlockEntry : PreOpStatement ref preop
{
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(preop.Operator)
	CodeGenEmitBindingsForOperand(preop.Operand)
	OnBytecodeAssign()
}

CodeGenEmitSingleCodeBlockEntry : PostOpStatement ref postop
{
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeReadReference()
	OnBytecodeInvoke(postop.Operator)
	CodeGenEmitBindingsForOperand(postop.Operand)
	OnBytecodeAssign()
}



CodeGenEmitSingleCodeBlockEntry : EntityChain ref chain
{
	OnBytecodeBeginChain()
	CodeGenEmitEntityChain(chain.Entries)
	OnBytecodeEndChain()
}


CodeGenEmitEntityChain : EntityList ref entities
{
	CodeGenEmitEntityList(entities.ActualList)
}

CodeGenEmitEntityList : list<Entity> ref thelist
{
	if(thelist.value.Tag != 0)
	{
		CodeGenEmitExpression(thelist.value.Param, false, false)
		OnBytecodeEnterEntity(thelist.value.Tag, 0)
		CodeGenEmitCodeBlock(thelist.value.Code)
		OnBytecodeExitEntity()
	}

	CodeGenEmitEntityList(thelist.next)
}

CodeGenEmitEntityList : nothing


BindAssignmentMembers : simplelist<integer> ref lhsmembers, integer structurename
{
	integer membertype = 0
	integer memberoffset = 0
	GetStructureMemberTypeAndOffset(structurename, lhsmembers.value, membertype, memberoffset)

	OnBytecodeBindStructReference(membertype, memberoffset)

	// Recurse
	assertmsg(membertype != 0, "Member has no type!")
	BindAssignmentMembers(lhsmembers.next, GetNameOfType(membertype))
}

BindAssignmentMembers : nothing, integer structurename



CodeGenEmitExpressionList : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpressionList : ExpressionList ref expressions, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionList(expressions.Expressions, constructssumtype, constructorcall)
}

CodeGenEmitExpressionList : list<Expression> ref expressions, boolean constructssumtype, boolean constructorcall
{
	boolean constructssumtypetemp = constructssumtype
	if((expressions.value.Type & 0x7f000000) == 0x07000000)
	{
		constructssumtypetemp = true
	}

	CodeGenEmitExpressionAtoms(expressions.value.Atoms, constructssumtypetemp, constructorcall)
	CodeGenEmitExpressionList(expressions.next, constructssumtype, constructorcall)
}

CodeGenEmitExpression : nothing, boolean constructssumtype, boolean constructorcall

CodeGenEmitExpression : Expression ref expr, boolean constructssumtype, boolean constructorcall
{
	CodeGenEmitExpressionAtoms(expr.Atoms, constructssumtype, constructorcall)
}

CodeGenEmitExpressionAtoms : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean constructorcall
{
	boolean needsref = false
	CodeGenEmitExpressionAtomsWorker(atoms, constructssumtype, needsref, constructorcall)
	if(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

CodeGenEmitExpressionAtomsWorker : list<ExpressionAtom> ref atoms, boolean constructssumtype, boolean ref needsref, boolean constructorcall
{
	boolean thisneedsref = CodeGenCheckAtomForReadRef(atoms.value)
	if(thisneedsref)
	{
		needsref = true
	}
	elseif(needsref)
	{
		if(constructssumtype)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
		needsref = false
	}

	CodeGenEmitSingleAtom(atoms.value, constructorcall)
	CodeGenEmitExpressionAtomsWorker(atoms.next, constructssumtype, needsref, constructorcall)
}

CodeGenEmitExpressionAtomsWorker : nothing, boolean constructssumtype, boolean ref needsref, boolean constructorcall


CodeGenCheckAtomForReadRef : RefBinding ref atom -> !atom.IsReference [nogc]
CodeGenCheckAtomForReadRef : CompoundAtom ref atom -> false [nogc]

CodeGenCheckAtomForReadRef : integer ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : integer16 ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : boolean ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : real ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : IdentifierAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : StringHandleAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : OperatorInvokeAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : TypeAnnotationAtom ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : Statement ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : ParentheticalExpression ref atom -> false [nogc]
CodeGenCheckAtomForReadRef : AtomSentinel ref atom -> false [nogc]




CodeGenEmitSingleAtom : integer ref literalinteger, boolean constructor
{
	OnBytecodePushLiteralInteger(literalinteger)
}

CodeGenEmitSingleAtom : integer16 ref literalinteger16, boolean constructor
{
	OnBytecodePushLiteralInteger16(literalinteger16)
}

CodeGenEmitSingleAtom : boolean ref literalboolean, boolean constructor
{
	OnBytecodePushBoolean(literalboolean)
}

CodeGenEmitSingleAtom : real ref literalreal, boolean constructor
{
	OnBytecodePushLiteralReal(literalreal)
}

CodeGenEmitSingleAtom : StringHandleAtom ref atom, boolean constructor
{
	OnBytecodePushLiteralString(atom.Handle)
}

CodeGenEmitSingleAtom : OperatorInvokeAtom ref atom, boolean constructor
{
	OnBytecodeInvoke(atom.OperatorName)
}

CodeGenEmitSingleAtom : IdentifierAtom ref idatom, boolean constructor
{
	integer atomtype = MakeNonReferenceType(idatom.Type)

	if(atomtype == 0x00000004)							// Nothing type signature
	{
		OnBytecodePushLiteralInteger(0)
	}
	else
	{
		if(idatom.IsFunction)
		{
			OnBytecodePushLiteralFunction(idatom.Handle)
		}
		elseif(GetTypeByName(idatom.Handle) != 0)
		{
			OnBytecodePushLiteralString(idatom.Handle)
		}
		else
		{
			if(atomtype == 0x01000000)					// Identifier type signature
			{
				if((!constructor) && (!idatom.IsReference))
				{
					OnBytecodePushLiteralString(idatom.Handle)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
			}
			elseif((atomtype & 0x7f000000) == 0x09000000)			// Function type family signature
			{
				OnBytecodePushLiteralFunction(idatom.Handle)
			}
			else
			{
				if(idatom.IsReference)
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)
					OnBytecodeBindReference(frames, index)
				}
				else
				{
					integer frames = 0
					integer index = FindVariable(idatom.Handle, frames)

					if(frames == 0)
					{
						OnBytecodePushVarValue(idatom.Handle, idatom.Type)
					}
					elseif(IsReferenceType(idatom.Type))
					{
						OnBytecodeBindReference(frames, index)
					}
					else
					{
						Variable var = 0, 0, 0, 0
						FindVariableDataInSingleScope(GlobalScope.Wrapped, idatom.Handle, var)

						if(var.Name == 0)
						{
							print("Code generation error - missing local variable " ; GetPooledString(GlobalStrings, idatom.Handle) ; " in scope " ; GetPooledString(GlobalStrings, EmittingFunctionName))
							assert(false)
						}
						OnBytecodePushLocal(frames, var.Offset)
					}
				}
			}
		}
	}
}

CodeGenEmitSingleAtom : TypeAnnotationAtom ref atom, boolean constructor
{
	OnBytecodePushTypeAnnotation(MakeNonReferenceType(atom.Type))
}

CodeGenEmitSingleAtom : Statement ref atom, boolean constructor
{
	CodeGenEmitSingleCodeBlockEntry(atom)
}

CodeGenEmitSingleAtom : RefBinding ref atom, boolean constructor
{
	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(atom.StructureName, atom.Identifier, memtype, memoffset)

	OnBytecodeBindStructReference(memtype, memoffset)
}

CodeGenEmitSingleAtom : ParentheticalExpression ref expr, boolean constructor
{
	CodeGenDecomposeParenthetical(expr.Inner)
}

CodeGenDecomposeParenthetical : Expression ref expr
{
	CodeGenEmitExpression(expr, false, false)
}

CodeGenDecomposeParenthetical : PreOpStatement ref statement
{
	CodeGenEmitSingleCodeBlockEntry(statement)
	CodeGenEmitBindingsForOperand(statement.Operand)
	OnBytecodeReadReference()
}

CodeGenDecomposeParenthetical : PostOpStatement ref statement
{
	CodeGenEmitBindingsForOperand(statement.Operand)
	OnBytecodeReadReference()
	CodeGenEmitSingleCodeBlockEntry(statement)
}

CodeGenEmitSingleAtom : CompoundAtom ref atom, boolean constructor
{
	integer frames = 0
	integer index = FindVariable(atom.Bindings.value.Identifier, frames)
	OnBytecodeBindReference(frames, index)

	EmitCompoundBindings(atom.Bindings, atom.Bindings.next)

	if(!IsReferenceType(atom.Type))
	{
		if((atom.Type & 0x7f000000) == 0x07000000)
		{
			OnBytecodeReadReferenceAnnotated()
		}
		else
		{
			OnBytecodeReadReference()
		}
	}
}

EmitCompoundBindings : list<RefBinding> ref bindings, list<RefBinding> ref tail
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(EmittingScope.Wrapped, bindings.value.Identifier, var)

	assertmsg(var.VarType != 0, "Compound bindings reference bogus variable")
	integer lhstypename = GetNameOfType(var.VarType)

	integer memtype = 0
	integer memoffset = 0
	GetStructureMemberTypeAndOffset(lhstypename, tail.value.Identifier, memtype, memoffset)

	OnBytecodeBindStructReference(memtype, memoffset)

	EmitCompoundSubsequentBindings(tail.next)
}

EmitCompoundSubsequentBindings : nothing

EmitCompoundSubsequentBindings : list<RefBinding> ref bindings
{
	CodeGenEmitSingleAtom(bindings.value, false)
	EmitCompoundSubsequentBindings(bindings.next)
}


CodeGenEmitSingleAtom : AtomSentinel ref sentinel, boolean constructor


CodeGenEmitSingleSumType : SumType ref st -> boolean ret = true [nogc]
{
	if((st.Type != 0) && (!st.IsTemplate))
	{
		OnBytecodeEmitByte(0x1f)			// SumTypeDef instruction
		OnBytecodeEmitInteger(st.Type)
		OnBytecodeEmitInteger(CountSumTypeBases(st.Bases))
		CodeGenEmitSumTypeBase(st.Bases)
	}
}

CodeGenEmitSumTypes :
{
	BinaryTreeWalkAllNodes<SumType>(GlobalRootNamespace.SumTypes.RootNode, CodeGenEmitSingleSumType)
}



CodeGenEmitSumTypeBase : list<SumTypeBase> ref bases [nogc]
{
	CodeGenEmitSumTypeBase(bases.next)

	if(bases.value.Name != 0)
	{
		OnBytecodeEmitInteger(bases.value.Name)
	}
}

CodeGenEmitSumTypeBase : nothing [nogc]



CodeGenEmitTypeMatchers : list<TypeMatcher> ref matchers
{
	if(matchers.value.Name != 0)
	{
		OnBytecodeLexicalScope(matchers.value.Name, 0, 0)
		OnBytecodeEnterTypeResolver(matchers.value.Name)
		CodeGenEmitTypeMatcherOverloads(matchers.value.Overloads)
		OnBytecodeExitTypeResolver()
	}

	CodeGenEmitTypeMatchers(matchers.next)
}

CodeGenEmitTypeMatchers : nothing

CodeGenEmitTypeMatcherOverloads : list<FunctionSignature> ref signatures
{
	CodeGenEmitTypeMatcherOverloads(signatures.next)

	if(signatures.value.Name != 0)
	{
		OnBytecodeEmitByte(0x20)				// TypeMatch instruction
		OnBytecodeEmitInteger(signatures.value.Name)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(CountParameters(signatures.value.Parameters))

		CodeGenEmitTypeMatcherParams(signatures.value.Parameters)
	}
}

CodeGenEmitTypeMatcherOverloads : nothing


CodeGenEmitTypeMatcherParams : list<Parameter> ref params [nogc]
{
	CodeGenEmitTypeMatcherParams(params.next)

	if(params.value.Name != 0)
	{
		integer refflag = 0
		if(IsReferenceType(params.value.Type))
		{
			refflag = 1
		}

		OnBytecodeEmitByte(refflag)
		OnBytecodeEmitInteger(MakeNonReferenceType(params.value.Type))
	}
}

CodeGenEmitTypeMatcherParams : nothing [nogc]


OnCodeGenRegisterFunctionTag : integer funcname, string tagname, integer rawfuncname
{
	list<string> dtp = "", nothing
	FunctionTag tag = funcname, tagname, dtp
	ListPrependOrCreate<FunctionTag>(GlobalRootNamespace.FunctionTags, tag)

	if(tagname == "constructor")
	{
		simpleprepend<integer>(CustomConstructors, funcname)

		integer baseconstructorname = PoolString(GetPooledString(GlobalStrings, rawfuncname) ; "@@constructor")

		Overload overload = baseconstructorname, funcname, nothing
		prepend<Overload>(AutoGenOverloads, overload)
		FindFunctionAndAddOverload(overload)

		PrependFunctionParameter(Functions, funcname, PoolString("@id"), 0x81000000)		// reference to identifier type signature
	}
}

OnCodeGenRegisterFunctionTagParam : integer funcname, string tagname, string param
{
	// TODO - less lazy implementation (find function and tag)
	AppendFunctionTagParamUnwrap(GlobalRootNamespace.FunctionTags, param)
}

AppendFunctionTagParamUnwrap : list<FunctionTag> ref tags, string param
{
	AppendFunctionTagParam(tags.value.Parameters, tags.value.Parameters.next, param)
}

AppendFunctionTagParamUnwrap : nothing, string param
{
	assertmsg(false, "Function tag parameter registered but no function tags have been set up!")
}


CodeGenEmitFunctionTags : list<FunctionTag> ref tags
{
	if(tags.value.FunctionName != 0)
	{
		if((tags.value.TagName != "") && (tags.value.TagName != "static"))
		{
			OnBytecodeEmitByte(0x1a)
			OnBytecodeEmitInteger(tags.value.FunctionName)
			OnBytecodeEmitInteger(CountTagParams(tags.value.Parameters))
			OnBytecodeEmitString(tags.value.TagName)

			CodeGenEmitFunctionTagParams(tags.value.Parameters)
		}
	}
	CodeGenEmitFunctionTags(tags.next)
}

CodeGenEmitFunctionTags : nothing



CodeGenEmitFunctionTagParams : list<string> ref params [nogc]
{
	if(params.value != "")
	{
		OnBytecodeEmitString(params.value)
	}

	CodeGenEmitFunctionTagParams(params.next)
}

CodeGenEmitFunctionTagParams : nothing [nogc]



CodeGenEmitConstructors : list<StructureDefinition> ref structures
{
	if((structures.value.Name != 0) && (!structures.value.IsTemplate))
	{
		EmitCtorTag(structures.value.ConstructorName)
		EmitCtorTag(structures.value.AnonConstructorName)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCtorTag(structures.value.CopyConstructorName)
		}

		EmitConstructor(structures.value)
		EmitAnonConstructor(structures.value)

		if(structures.value.CopyConstructorName != 0)
		{
			EmitCopyConstructor(structures.value)
		}
	}

	CodeGenEmitConstructors(structures.next)
}

CodeGenEmitConstructors : nothing

EmitCtorTag : integer funcname
{
	OnBytecodeEmitByte(0x1a)
	OnBytecodeEmitInteger(funcname)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitString("@@autogen@constructor")
}


EmitConstructor : StructureDefinition ref def
{
	integer idhandle = PooledStringHandleForIdentifier

	OnBytecodeLexicalScope(def.ConstructorName, 0, def.MemberCount + 1)
	OnBytecodeLexicalScopeEntry(idhandle, 0x81000000, 1)
	EmitScopeEntriesForMembers(def.Members)

	OnBytecodeEnterFunction(def.ConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, idhandle)

	OnBytecodeExitFunction()
}

EmitAnonConstructor : StructureDefinition ref def
{
	integer membercount = def.MemberCount
	OnBytecodeLexicalScope(def.AnonConstructorName, 0, membercount + 1)
	EmitScopeEntriesForMembers(def.Members)
	OnBytecodeLexicalScopeEntry(def.AnonConstructorName, def.Type, 2)

	OnBytecodeEnterFunction(def.AnonConstructorName)
	OnBytecodeAllocStructure(def.Type)
	OnBytecodeBindReference(0, membercount)
	OnBytecodeAssign()

	EmitMemberDataCopies(def.Members, def.AnonConstructorName)

	OnBytecodeSetReturnRegister(membercount)
	OnBytecodeExitFunction()
}

EmitCopyConstructor : StructureDefinition ref def
{
	OnBytecodeLexicalScope(def.CopyConstructorName, 0, 2)
	OnBytecodeLexicalScopeEntry(PooledStringHandleForIdentifier, 0x81000000, 1)
	OnBytecodeLexicalScopeEntry(def.Name, def.Type, 1)

	OnBytecodeEnterFunction(def.CopyConstructorName)
	OnBytecodePushVarValueNoCopy(def.Name)
	OnBytecodeCopyStructure()
	OnBytecodeBindReference(0, 0)
	OnBytecodeAssign()
	OnBytecodeExitFunction()
}


EmitScopeEntriesForMembers : list<StructureMember> ref members
{
	EmitScopeEntryForMember(members.value)
	EmitScopeEntriesForMembers(members.next)
}

EmitScopeEntriesForMembers : nothing


EmitScopeEntryForMember : StructureMemberVariable ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, memvar.Type, 1)
	}
}

EmitScopeEntryForMember : StructureMemberFunctionRef ref memvar
{
	if(memvar.Name != 0)
	{
		OnBytecodeLexicalScopeEntry(memvar.Name, GetMemberTypeDecompose(memvar), 1)
	}
}



EmitMemberDataCopies : list<StructureMember> ref members, integer idhandle
{
	EmitMemberDataCopy(members.value, idhandle)
	EmitMemberDataCopies(members.next, idhandle)
}

EmitMemberDataCopies : nothing, integer idhandle

EmitMemberDataCopy : StructureMemberVariable ref memvar, integer idhandle
{
	if(memvar.Name != 0)
	{
		OnBytecodePushVarValue(memvar.Name, memvar.Type)
		OnBytecodeCopyToStructure(idhandle, memvar.Name)
	}
}

EmitMemberDataCopy : StructureMemberFunctionRef ref member, integer idhandle
{
	if(member.Name != 0)
	{
		OnBytecodePushVarValue(member.Name, 0x09000000)
		OnBytecodeCopyToStructure(idhandle, member.Name)
	}
}


// Rearrange structure list to avoid dependency issues on load
CodeGenRearrangeStructures : list<StructureDefinition> ref thelist
{
	simplelist<integer> processed = 0, nothing
	boolean changed = CodeGenRearrangeStructuresRecurse(thelist, processed)

	if(changed)
	{
		CodeGenRearrangeStructures(thelist)
	}
}

CodeGenRearrangeStructuresRecurse : list<StructureDefinition> ref thelist, simplelist<integer> ref processed -> boolean changed = false
{
	if((thelist.value.Name != 0) && (!thelist.value.IsTemplate))
	{
		simplelist<integer> dependencies = 0, nothing
		ParseStructDependencies(thelist.value.Members, dependencies)

		if(MissingDependency(dependencies, processed))
		{
			SwapDown(thelist, thelist.next)
			changed = true
		}

		simpleprepend<integer>(processed, thelist.value.Type)
	}

	if(!changed)
	{
		CodeGenRearrangeStructuresRecurse(thelist.next, processed)
	}
}

CodeGenRearrangeStructuresRecurse : nothing, simplelist<integer> ref processed -> false


SwapDown : list<StructureDefinition> ref thelist, list<StructureDefinition> ref tail
{
	StructureDefinition temp = tail.value
	tail.value = thelist.value
	thelist.value = temp
}

SwapDown : list<StructureDefinition> ref thelist, nothing



OnCodeGenEnterEntity : integer entityname, integer postfixtag
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_PARAM, entityname
	prepend<ContextStackEntry>(ContextStack, entry)

	Entity entity = entityname, postfixtag, nothing, nothing
	prepend<Entity>(EntityStack, entity)

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

OnCodeGenEnterEntityCode :
{
	ContextStackEntry entry = STACK_TYPE_ENTITY_CODE, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityStack.value.Param = ScratchExpressions.value

	OptionalCodeBlock block = nothing
	prepend<OptionalCodeBlock>(CurrentCodeBlockStack, block)
}

OnCodeGenEnterChain :
{
	ContextStackEntry entry = STACK_TYPE_CHAIN, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	EntityChain newchain = dummychain
	prepend<EntityChain>(ChainStack, newchain)
}


OnCodeGenRegisterAlias : integer aliastype, integer aliasname, integer base
{
	TypeAlias newalias = aliastype, aliasname, base
	BinaryTreeCreateOrInsert<TypeAlias>(GlobalRootNamespace.TypeAliases, aliastype, newalias)
	BinaryTreeCreateOrInsert<integer>(NameToTypeMap, aliasname, aliastype)
}

OnCodeGenRegisterWeakAlias : integer aliastype, integer aliasname, integer basename
{
	TypeAlias newalias = aliastype, aliasname, basename
	BinaryTreeCreateOrInsert<TypeAlias>(GlobalRootNamespace.TypeWeakAliases, aliastype, newalias)
	BinaryTreeCreateOrInsert<integer>(NameToTypeMap, aliasname, aliastype)
}


OnCodeGenRegisterFunctionSig : integer sigtype, integer rettypename
{
	list<Parameter> d = dummyparam, nothing
	FunctionSignature sig = sigtype, d, rettypename, false
	prepend<FunctionSignature>(FunctionSignatures, sig)
}

OnCodeGenRegisterFunctionSigParam : integer paramtype, boolean isref
{
	// TODO - this is a really lame hack
	integer flag = 1
	if(isref)
	{
		flag = 2
	}
	
	Parameter param = flag, paramtype
	AppendParameter(FunctionSignatures.value.Parameters, param)
}

OnCodeGenRegisterFunctionSigParamList : simplelist<integer> ref paramtypenames, simplelist<boolean> ref paramrefflags
{
	OnCodeGenRegisterFunctionSigParamList(paramtypenames.next, paramrefflags.next)

	if(paramtypenames.value != 0)
	{
		OnCodeGenRegisterFunctionSigParam(paramtypenames.value, paramrefflags.value)
	}
}

OnCodeGenRegisterFunctionSigParamList : nothing, nothing


CodeGenEmitFunctionSignatures : list<FunctionSignature> ref thelist
{
	if(thelist.value.Name != 0)
	{
		integer rettype = GetTypeByName(thelist.value.ReturnTypeName)
		if(rettype == 0)
		{
			rettype = 0x00000002		// void
		}

		OnBytecodeEmitFunctionSignature(thelist.value.Name, rettype, CountParameters(thelist.value.Parameters))
		CodeGenEmitFunctionSigParams(thelist.value.Parameters)
	}
	CodeGenEmitFunctionSignatures(thelist.next)
}

CodeGenEmitFunctionSignatures : nothing


CodeGenEmitFunctionSigParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		integer t = params.value.Type
		if(params.value.Name == 2)		// VERY BAD HACK
		{
			t = MakeReferenceType(t)
		}
		OnBytecodeEmitFunctionSigParam(t)
	}
	CodeGenEmitFunctionSigParams(params.next)
}

CodeGenEmitFunctionSigParams : nothing


OnCodeGenRegisterParenthetical :
{
	ContextStackEntry entry = STACK_TYPE_PARENTHETICAL, 0
	prepend<ContextStackEntry>(ContextStack, entry)

	Expression d = dummyatomlist, 0
	prepend<Expression>(ScratchExpressions, d)
}


OnCodeGenPreparePreOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PreOpStatement preop = operator, operandlist, 0

	PreOpOnDeck = preop
}

OnCodeGenPreparePreOpCompoundOperand : integer operand
{
	AppendCompoundMemberHelper(PreOpOnDeck, operand)
}

OnCodeGenCompletePreOpStatement : boolean substatement
{
	if(substatement)
	{
		ExpressionOrPrePostOp wrap = PreOpOnDeck
		ParentheticalExpression parenthetical = wrap
		ExpressionAtom atom = parenthetical
		PlaceAtomInScratchExpression(atom)
	}
	else
	{
		CodeBlockEntry cbe = PreOpOnDeck
		AppendEntryToCurrentCodeBlock(cbe)
	}
}

OnCodeGenAddPreOpCompoundOperand : integer operand
{
	FindLastPreOpAndAppendCompoundMemberHelper(CurrentCodeBlockStack.value, operand)
}

OnCodeGenRegisterPostOpStatement : integer operator, integer operand
{
	simplelist<integer> operandlist = operand, nothing
	PostOpStatement postop = operator, operandlist, 0
	CodeBlockEntry cbe = postop
	AppendEntryToCurrentCodeBlock(cbe)
}



OnCodeGenShiftParameter :
{
	if(InFuncRetHack)
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}
	elseif(PeekContext(ContextStack, 1) != STACK_TYPE_SUBSTATEMENT)
	{
		FindCurrentStatementAndAppendExpression(ScratchExpressions.value)
	}
	else
	{
		AppendExpressionToStatement(SubStatements.value, ScratchExpressions.value)
	}

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

PeekContext : list<ContextStackEntry> ref stack, integer depth -> integer peek = STACK_TYPE_GLOBAL
{
	if(depth == 0)
	{
		peek = stack.value.EntryType
	}
	else
	{
		peek = PeekContext(stack.next, depth - 1)
	}
}


CodeGenEmitGlobalBlockPrologue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		EmittingScope.Wrapped = GlobalScope.Wrapped

		OnBytecodeEnterEntity(4, GlobalCodeBlockName)
		CodeGenEmitCodeBlock(block)
		OnBytecodeInvokeOffset(FindHandleInTrie(GlobalStringTrie, "entrypoint"))
		OnBytecodeHalt()
	}
}

CodeGenEmitGlobalBlockEpilogue : CodeBlock ref block
{
	if(GlobalCodeBlockName != 0)
	{
		OnBytecodeExitEntity()
	}
}


EmitPatternMatchingForFunction : FunctionDefinition ref function
{
	OnBytecodeEmitByte(0x12)			// PatternMatch instruction
	OnBytecodeEmitInteger(function.Name)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitInteger(CountUnresolvedParameters(function.Params))
	EmitPatternMatchingForParameters(function.Params)
}

EmitPatternMatchingForParameters : FunctionParams ref params
{
	EmitPatternMatchingForParameters(params.Params)
}

EmitPatternMatchingForParameters : list<UnresolvedParameter> ref params
{
	integer parampatterntype = GetOptionalExpressionType(params.value.PatternMatchValue)
	OnBytecodeEmitInteger(MakeNonReferenceType(parampatterntype))

	if(parampatterntype != 0)
	{
		OnBytecodeEmitBoolean(true)
		EmitPatternMatchLiteral(params.value.PatternMatchValue)
	}
	else
	{
		OnBytecodeEmitBoolean(false)
	}

	EmitPatternMatchingForParameters(params.next)
}

EmitPatternMatchingForParameters : nothing


EmitPatternMatchLiteral : Expression ref expr
{
	EmitPatternMatchLiteralAtom(expr.Atoms.value)
}

EmitPatternMatchLiteralAtom : integer value
{
	OnBytecodeEmitInteger(value)
}

