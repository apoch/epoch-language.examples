//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//

CloseHandle : integer handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]
CreateFile : string filename, integer access, integer sharemode, integer attributes, integer creation, integer flags, integer template -> integer ret = 0 [external("Kernel32.dll", "CreateFileW", "stdcall")]
CreateFileMapping : integer filehandle, integer attributes, integer protection, integer maxsizehigh, integer maxsizelow, integer name -> integer ret = 0 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
MapViewOfFile : integer handle, integer access, integer offsethigh, integer offsetlow, integer bytestomap -> integer ptr = 0 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]
UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]
GetFileSize : integer handle, integer ignored -> integer size = 0 [external("Kernel32.dll", "GetFileSize", "stdcall")]
SetCurrentDirectory : string path -> boolean success = false [external("Kernel32.dll", "SetCurrentDirectoryW", "stdcall")]

timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime", "stdcall")]

ExecuteByteCodeBuffer : buffer ref code, integer len [external("EpochRuntime.dll", "ExecuteByteCodeDeferred", "stdcall")]


entrypoint :
{
	print("Epoch Language Project")
	print("Command line compiler and tools interface")
	print("")

	if(cmdlineisvalid() && (cmdlinegetcount() > 1))
	{
		boolean makeproject = false

		string filename = cmdlineget(1)
		if((length(filename) > 5) && (substring(filename, length(filename) - 5) == ".eprj"))
		{
			makeproject = true
		}
		else
		{
			print("Executing: " ; filename)
			print("")
		}

		PrepareStringTable()
		InitBuiltInOverloads()

		if(makeproject)
		{
			ChangeToPath(filename)
			CompileProject(filename)
		}
		else
		{
			if(CompileFile(filename))
			{
				ExecuteByteCodeBuffer(Hack, HackSize)		
			}
		}
	}
	else
	{
		print("Please specify a program to execute!")
	}
}


ChangeToPath : string filename
{
	if(!stringcontains(filename, "\"))
	{
		return()
	}
	
	integer pos = length(filename) - 1
	while(charat(filename, pos) != "\")
	{
		--pos
	}
	
	string path = substring(filename, 0, pos)
	SetCurrentDirectory(path)
}


ParseFile : string filename -> boolean success = false
{
	integer len = 0
	string contents = ReadFile(filename, len)

	if(len == 0)
	{
		return()
	}
	
	success = Parse(contents, len)
}


CompileProject : string filename
{	
	simplelist<string> emptysourcefilelist = "", nothing
	simplelist<string> emptyresourcefilelist = "", nothing
	EpochProject project = "", "project.exe", emptysourcefilelist, emptyresourcefilelist, false

	ParseProjectFile(filename, project)

	print("Parsing source code...")
	boolean parseok = ProjectParseAllCode(project.SourceFiles)	
	if(!parseok)
	{
		return()
	}

	print("Performing semantic analysis...")
	boolean irok = IRProcess()
	if(!irok)
	{
		return()
	}

	print("Generating code...")
	OnCodeGenProcessProgram()
	
	print("Writing executable file...")
	MakeExe(project)
}

//
// Helper for traversing the list of files in a project
// and passing each in turn to the Epoch parser
//
ProjectParseAllCode : simplelist<string> ref files -> boolean success = true
{
	if(files.value != "")
	{
		print(files.value)
		if(!ParseFile(files.value))
		{
			success = false
		}
	}
	
	if(!ProjectParseAllCode(files.next))
	{
		success = false
	}
}

ProjectParseAllCode : nothing -> true


CompileFile : string filename -> boolean success = false
{
	integer len = 0
	string contents = ReadFile(filename, len)

	if(len == 0)
	{
		return()
	}

	integer startparsems = timeGetTime()
	boolean parseok = Parse(contents, len)
	integer durationparsems = timeGetTime() - startparsems

	print("Parsing completed in " ; cast(string, durationparsems) ; " milliseconds")
	if(!parseok)
	{
		return()
	}

	integer startprocessms = timeGetTime()
	boolean irok = IRProcess()
	integer durationprocessms = timeGetTime() - startprocessms

	print("Semantic analysis completed in " ; cast(string, durationprocessms) ; " milliseconds")
	if(!irok)
	{
		return()
	}

	integer startcodegenms = timeGetTime()
	OnCodeGenProcessProgram()
	integer durationcodegenms = timeGetTime() - startcodegenms

	print("Code generation completed in " ; cast(string, durationcodegenms) ; " milliseconds")
	print("")

	success = true
}



PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	print("No contexts available")
	assert(false)
}

PopExpression : list<Expression> ref thelist, list<Expression> ref next
{
	thelist = next
}

PopExpression : list<Expression> ref thelist, nothing



PopCodeBlock : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref next
{
	stack = next
}

PopCodeBlock : list<OptionalCodeBlock> ref stack, nothing
{
	list<OptionalCodeBlock> newlist = nothing, nothing
	stack = newlist
}


PopEntityStack : list<Entity> ref stack, list<Entity> ref next
{
	stack = next
}

PopEntityStack : list<Entity> ref stack, nothing


PopChain : list<EntityChain> ref stack, list<EntityChain> ref next
{
	stack = next
}

PopChain : list<EntityChain> ref stack, nothing



PopCurrentStatementAndAppendToScratchExpression : list<Expression> ref expressions, list<Expression> ref tail
{
	ExpressionAtom atom = SubStatements.value

	expressions = tail

	PlaceAtomInScratchExpression(atom)
	PopSubStatement(SubStatements, SubStatements.next)
}

SetReturnExpression : FunctionDefinition ref funcdef, Expression ref expr
{
	funcdef.Return = expr

	Expression d = dummyatomlist, 0
	ScratchExpressions.value = d
}

SetGlobalCodeBlock : CodeBlock ref block
{
	GlobalCodeBlock = block
}

SetGlobalCodeBlock : nothing


PopSubStatement : list<Statement> ref statements, list<Statement> ref tail
{
	statements = tail
}




FindScopeAndSetContext : FunctionDefinition ref func [nogc]
{
	EmittingScope.Wrapped = func.AttachedScope.Wrapped
}







TypeMatcherExists : list<TypeMatcher> ref matchers, integer matchername -> boolean ret = false [nogc]
{
	if(matchers.value.Name == matchername)
	{
		ret = true
	}
	else
	{
		ret = TypeMatcherExists(matchers.next, matchername)
	}
}

TypeMatcherExists : nothing, integer matchername -> boolean ret = false [nogc]


GetExistingTypeMatcher : list<TypeMatcher> ref matchers, integer matchername, ContextNode<TypeMatcher> ref out -> boolean ret = false [nogc]
{
	if(matchers.value.Name == matchername)
	{
		ContextNode<TypeMatcher> outwrap = matchers.value
		out = outwrap
		ret = true
	}
	else
	{
		ret = GetExistingTypeMatcher(matchers.next, matchername, out)
	}
}

GetExistingTypeMatcher : nothing, integer matchername, ContextNode<TypeMatcher> ref out -> boolean ret = false [nogc]



FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, list<FunctionSignature> ref signatures, integer overloadname, Parameter ref p
{
	if(signatures.value.Name == overloadname)
	{
		AppendParameter(signatures.value.Parameters, p)
	}
	else
	{
		FindTMOverloadAndAppendParameter(originallist, signatures.next, overloadname, p)
	}
}

FindTMOverloadAndAppendParameter : list<FunctionSignature> ref originallist, nothing, integer overloadname, Parameter ref p
{
	list<Parameter> paramlist = p, nothing
	FunctionSignature sig = overloadname, paramlist, 0
	prepend<FunctionSignature>(originallist, sig)
}



CountTagParams : list<string> ref params -> integer count = 0 [nogc]
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0 [nogc]



UnaliasType : list<TypeAlias> ref aliases, integer namehandle -> integer unaliasedname = 0 [nogc]
{
	if(aliases.value.AliasNameHandle == namehandle)
	{
		unaliasedname = aliases.value.BaseNameHandle
	}
	else
	{
		unaliasedname = UnaliasType(aliases.next, namehandle)
	}
}

UnaliasType : nothing, integer namehandle -> integer unaliasedname = namehandle [nogc]



ParseStructDependencies : list<StructureMember> ref members, simplelist<integer> ref out
{
	integer dependency = GetMemberDependency(members.value)
	if(dependency != 0)
	{
		simpleprepend<integer>(out, dependency)
	}

	ParseStructDependencies(members.next, out)
}

ParseStructDependencies : nothing, simplelist<integer> ref out


GetMemberDependency : StructureMemberVariable ref var -> integer dep = 0
{
	if(var.Name != 0)
	{
		if(IsStructureType(var.Type))
		{
			dep = var.Type
		}
	}
}

GetMemberDependency : StructureMemberFunctionRef ref member -> 0


MissingDependency : simplelist<integer> ref dependencies, simplelist<integer> ref processed -> boolean missing = true
{
	// TODO - clean up this horrible code
	if(dependencies.value != 0)
	{
		if(listcontains(processed, dependencies.value))
		{
			missing = false
		}
		else
		{
			missing = MissingDependency(dependencies.next, processed)
		}
	}
	else
	{
		missing = MissingDependency(dependencies.next, processed)
	}
}

MissingDependency : nothing, simplelist<integer> ref processed -> boolean missing = false



AppendEntityToChain : list<EntityChain> ref chainstack, Entity ref e
{
	AppendEntityToChainUnwrap(chainstack.value.Entries, e)
}

AppendEntityToChainUnwrap : EntityList ref entitylist, Entity ref e
{
	AppendEntityToChainWorker(entitylist.ActualList, entitylist.ActualList.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, list<Entity> ref tail, Entity ref e
{
	AppendEntityToChainWorker(tail, tail.next, e)
}

AppendEntityToChainWorker : list<Entity> ref chain, nothing, Entity ref e
{
	list<Entity> newtail = e, nothing
	chain.next = newtail
}


FindTypeAliasBase : list<TypeAlias> ref aliases, integer aliastype -> integer basetype = 0 [nogc]
{
	if(aliases.value.TypeID == aliastype)
	{
		basetype = GetTypeByName(aliases.value.BaseNameHandle)
	}
	else
	{
		basetype = FindTypeAliasBase(aliases.next, aliastype)
	}
}

FindTypeAliasBase : nothing, integer aliastype -> integer basetype = 0 [nogc]


FindTypeAliasByName : list<TypeAlias> ref aliases, integer aliasname -> integer aliastype = 0 [nogc]
{
	if(aliases.value.AliasNameHandle == aliasname)
	{
		aliastype = aliases.value.TypeID
	}
	else
	{
		aliastype = FindTypeAliasByName(aliases.next, aliasname)
	}
}

FindTypeAliasByName : nothing, integer aliasname -> 0 [nogc]


FindLastPreOpAndAppendCompoundMemberHelper : CodeBlock ref codeblock, integer operand
{
	FindLastPreOpAndAppendCompoundMember(codeblock.Entries, codeblock.Entries.next, operand)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastPreOpAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}



IRProcess : -> boolean success = true
{
	prepend<StructureDefinition>(Structures, dummystruct)		// TODO - why does this need to be here?

	if(!IRTypeInference())
	{
		success = false
		return()
	}
}


GeneratePendingTypeMatchers : list<PendingTypeMatcher> ref pendingmatchers
{
	GeneratePendingTypeMatcher(pendingmatchers.value)
	GeneratePendingTypeMatchers(pendingmatchers.next)
}

GeneratePendingTypeMatchers : nothing

GeneratePendingTypeMatcher : PendingTypeMatcher ref matcher
{
	if(matcher.OverloadName == 0)
	{
		return()
	}

	ContextNode<TypeMatcher> matchwrap = nothing
	if(!GetExistingTypeMatcher(TypeMatchers, matcher.MatcherName, matchwrap))
	{
		OnCodeGenEnterTypeMatcher(matcher.MatcherName)
		OnCodeGenExitContext()
		matchwrap = TypeMatchers.value
	}

	ContextNode<FunctionDefinition> wrap = nothing
	SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, matcher.OverloadName, wrap)

	WalkParametersForTypeMatcherContext(wrap, matchwrap)
}

WalkParametersForTypeMatcherContext : FunctionDefinition ref func, TypeMatcher ref matcher
{
	WalkParametersForTypeMatcher(func.Params, matcher, func.Name)
}


WalkParametersForTypeMatcher : FunctionParams ref params, TypeMatcher ref matcher, integer overloadname
{
	WalkParametersForTypeMatcherUnwrapped(params.Params, matcher, overloadname)
}


WalkParametersForTypeMatcherUnwrapped : list<UnresolvedParameter> ref params, TypeMatcher ref matcher, integer overloadname
{
	if(params.value.NameHandle != 0)
	{
		Parameter p = params.value.NameHandle, params.value.ResolvedType
		FindTMOverloadAndAppendParameter(matcher.Overloads, matcher.Overloads, overloadname, p)
	}

	WalkParametersForTypeMatcherUnwrapped(params.next, matcher, overloadname)
}

WalkParametersForTypeMatcherUnwrapped : nothing, TypeMatcher ref matcher, integer overloadname



DumpTypeList : simplelist<integer> ref types
{
	if(types.value != 0)
	{
		string refflag = ""
		if(IsReferenceType(types.value))
		{
			refflag = " ref"
		}

		print(" Potential type: " ; GetPooledString(GlobalStrings, GetNameOfType(types.value)) ; refflag)
	}

	DumpTypeList(types.next)
}

DumpTypeList : nothing


ContextHasTypeMatcher : PendingTypeMatcher ref matcher -> true [nogc]
ContextHasTypeMatcher : nothing -> false [nogc]


FindOverloadWithParameterTypesFast : FunctionDefinition ref func, integer rawname, simplelist<integer> ref paramtypes -> integer overloadname = rawname
{
	overloadname = FindOverloadWithParameterTypes(func.Overloads, rawname, paramtypes)
}


AnnotateTypeMatchedParamsForWrapper : FunctionDefinition ref func, OptionalExpressionList ref exprs
{
	AnnotateTypeMatchedParamsForWrapperUnwrap(func, exprs)
}

AnnotateTypeMatchedParamsForWrapperUnwrap : FunctionDefinition ref func, ExpressionList ref exprs
{
	AnnotateTypeMatchedParams(func.Params, exprs.Expressions)
}

AnnotateTypeMatchedParamsForWrapperUnwrap : FunctionDefinition ref func, nothing




DumpAllOverloadParameters : list<Overload> ref overloads, integer rawname
{
	if(overloads.value.NormalName == rawname)
	{
		DumpFunctionParameters(Functions, overloads.value.MangledName)
	}

	DumpAllOverloadParameters(overloads.next, rawname)
}

DumpAllOverloadParameters : nothing, integer rawname


DumpFunctionParameters : list<FunctionDefinition> ref functions, integer funcname
{
	if(functions.value.Name == funcname)
	{
		print(GetPooledString(GlobalStrings, funcname))
		DumpUnresolvedParameters(functions.value.Params)
	}
	else
	{
		DumpFunctionParameters(functions.next, funcname)
	}
}

DumpFunctionParameters : nothing, integer funcname


AnnotateAllParameters : ExpressionList ref exprs, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	AnnotateAllParameters(exprs.Expressions, statementname, paramindex, paramcount, toplevel)
}

AnnotateAllParameters : list<Expression> ref params, integer statementname, integer paramindex, integer paramcount, boolean toplevel
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	elseif(IsRefBind(params.value.Atoms.value))
	{
		TypeAnnotationAtom atom = 5
		ExpressionAtom wrap = atom
		AppendAtomToExpression(params.value.Atoms, params.value.Atoms.next, wrap)
	}

	AnnotateAllParameters(params.next, statementname, paramindex + 1, paramcount, toplevel)
}

AnnotateAllParameters : nothing, integer statementname, integer paramindex, integer paramcount, boolean toplevel



AnnotateNonReferenceParameters : ExpressionList ref exprs [nogc]
{
	AnnotateNonReferenceParameters(exprs.Expressions)
}

AnnotateNonReferenceParameters : list<Expression> ref params [nogc]
{
	if((params.value.Type & 0x7f000000) != 0x07000000)
	{
		AddTypeAnnotation(params.value)
	}
	AnnotateNonReferenceParameters(params.next)
}

AnnotateNonReferenceParameters : nothing [nogc]



AddTypeAnnotation : nothing [nogc]

AddTypeAnnotation : list<Expression> ref params [nogc]
{
	AddTypeAnnotation(params.value)
}

AddTypeAnnotation : Expression ref expr [nogc]
{
	integer typeid = expr.Type
	TypeAnnotationAtom atom = typeid
	ExpressionAtom wrap = atom
	AppendAtomToExpression(expr.Atoms, expr.Atoms.next, wrap)
}


AccumulateParameterTypes : simplelist<integer> ref types, OptionalExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrap(types, exprs)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, ExpressionList ref exprs [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.Expressions, types)
}

AccumulateParameterTypesUnwrap : simplelist<integer> ref types, nothing [nogc]

AccumulateParameterTypesUnwrapped : list<Expression> ref exprs, simplelist<integer> ref types [nogc]
{
	AccumulateParameterTypesUnwrapped(exprs.next, types)
	simpleprepend<integer>(types, exprs.value.Type)
}

AccumulateParameterTypesUnwrapped : nothing, simplelist<integer> ref types [nogc]


FindOverloadWithParameterTypes : list<Overload> ref overloads, integer rawname, simplelist<integer> ref types -> integer overloadname = rawname
{
	if(overloads.value.NormalName == rawname)
	{
		if(!IsFunctionTemplate(overloads.value.Implementation))
		{
			if(FunctionWrapperMatchesParameterTypes(overloads.value.Implementation, overloads.value.MangledName, types))
			{
				integer matchername = CheckForNeededPatternMatcher(PendingPatternMatchers, rawname)
				if(matchername != 0)
				{
					overloadname = matchername
				}
				else
				{
					overloadname = overloads.value.MangledName
				}
				return()
			}
			elseif(countnonzero(types) == GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName))
			{
				if(CheckForNeededTypeMatcher(types))
				{
					overloadname = FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName, overloads.value.Implementation)
					FindOverloadWithParameterTypes(overloads.next, rawname, types)
					return()
				}
			}
		}
	}

	overloadname = FindOverloadWithParameterTypes(overloads.next, rawname, types)
}

GetFunctionWrapperParameterCount : FunctionDefinition ref func, integer mangledname -> integer count = 0
{
	count = CountUnresolvedParameters(func.Params)
}

GetFunctionWrapperParameterCount : nothing, integer mangledname -> integer count = 0
{
	count = GetFunctionParameterCount(mangledname)
}


PopulateAllOverloadTypeMatchers : list<Overload> ref overloads, integer rawname, integer paramcount
{
	if(paramcount == GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName))
	{
		if(!IsFunctionTemplateFast(overloads.value.MangledName))
		{
			FindOrCreateTypeMatcher(overloads.value.NormalName, overloads.value.MangledName, overloads.value.Implementation)
		}
	}

	PopulateAllOverloadTypeMatchers(overloads.next, rawname, paramcount)
}

PopulateAllOverloadTypeMatchers : nothing, integer rawname, integer paramcount


IsFunctionTemplate : FunctionDefinition ref func -> boolean istemplate = func.IsTemplate [nogc]
IsFunctionTemplate : nothing -> false [nogc]


IsFunctionTemplateFast : integer name -> boolean istemplate = false [nogc]
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, name, wrap)
	if(!found)
	{
		print("Internal error - function undefined: " ; GetPooledString(GlobalStrings, name))
		assert(false)
	}

	istemplate = IsFunctionTemplate(wrap)
}


GenerateTypeMatcherMappings : list<FunctionDefinition> ref functions
{
	if(functions.value.Name != 0)
	{
		if(!functions.value.IsTemplate)
		{
			integer rawname = functions.value.RawName
			integer paramcount = CountUnresolvedParameters(functions.value.Params)

			if(AnyPendingTypeMatcherPointsToAnyOverload(functions.value.Overloads, rawname, paramcount))
			{
				PopulateAllOverloadTypeMatchers(functions.value.Overloads, rawname, paramcount)
			}
		}
	}

	GenerateTypeMatcherMappings(functions.next)
}

GenerateTypeMatcherMappings : nothing


AnyPendingTypeMatcherPointsToAnyOverload : list<Overload> ref overloads, integer rawname, integer paramcount -> boolean ret = false
{
	if(GetFunctionWrapperParameterCount(overloads.value.Implementation, overloads.value.MangledName) == paramcount)
	{
		if(SearchBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloads.value.MangledName))
		{
			ret = true
			return()
		}
	}

	ret = AnyPendingTypeMatcherPointsToAnyOverload(overloads.next, rawname, paramcount)
}

AnyPendingTypeMatcherPointsToAnyOverload : nothing, integer rawname, integer paramcount -> boolean ret = false



GetFunctionParameterCount : integer funcname -> integer count = -1 [nogc]
{
	if(funcname == PooledStringHandleForSubstringWithLength)
	{
		count = 3
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		count = 2
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		count = 2
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		count = 1
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		count = 3
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		count = 4
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		count = 4
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		count = 3
	}
}

CountUnresolvedParameters : FunctionParams ref params -> integer count = CountUnresolvedParametersUnwrapped(params.Params) [nogc]
CountUnresolvedParameters : nothing -> 0 [nogc]

CountUnresolvedParametersUnwrapped : list<UnresolvedParameter> ref params -> integer count = 0 [nogc]
{
	if(params.value.NameHandle != 0)
	{
		++count
	}
	elseif(GetOptionalExpressionType(params.value.PatternMatchValue) != 0)
	{
		++count
	}

	count += CountUnresolvedParametersUnwrapped(params.next)
}

CountUnresolvedParametersUnwrapped : nothing -> 0 [nogc]


CheckForNeededTypeMatcher : simplelist<integer> ref types -> boolean needsmatcher = false
{
	if((types.value & 0x7f000000) == 0x07000000)
	{
		needsmatcher = true
	}
	else
	{
		needsmatcher = CheckForNeededTypeMatcher(types.next)
	}
}

CheckForNeededTypeMatcher : nothing -> false


FindOverloadWithParameterTypes : nothing, integer rawname, simplelist<integer> ref types -> integer overloadname = 0
{
	if(rawname == PooledStringHandleForSubstring)
	{
		integer withlen = PooledStringHandleForSubstringWithLength
		integer nolen = PooledStringHandleForSubstringNoLength

		if(FunctionMatchesParameterTypes(nothing, withlen, types))
		{
			overloadname = withlen
		}
		elseif(FunctionMatchesParameterTypes(nothing, nolen, types))
		{
			overloadname = nolen
		}
	}
	elseif(rawname == PooledStringHandleForWriteBuffer)
	{
		integer normal = PooledStringHandleForWriteBuffer
		integer withstr = PooledStringHandleForWriteBufferString
		integer multiple = PooledStringHandleForWriteBufferMultiple
		integer withreal = PooledStringHandleForWriteBufferReal

		if(FunctionMatchesParameterTypes(nothing, normal, types))
		{
			overloadname = normal
		}
		elseif(FunctionMatchesParameterTypes(nothing, withstr, types))
		{
			overloadname = withstr
		}
		elseif(FunctionMatchesParameterTypes(nothing, multiple, types))
		{
			overloadname = multiple
		}
		elseif(FunctionMatchesParameterTypes(nothing, withreal, types))
		{
			overloadname = withreal
		}
	}
	elseif(rawname == PooledStringHandleForBuffer)
	{
		integer normal = PooledStringHandleForBuffer
		integer copy = PooledStringHandleForBufferCopy
		
		if(FunctionMatchesParameterTypes(nothing, normal, types))
		{
			overloadname = normal
		}
		elseif(FunctionMatchesParameterTypes(nothing, copy, types))
		{
			overloadname = copy
		}		
	}
	elseif(IsRecognizedBuiltIn(rawname))
	{
		overloadname = rawname
	}
	else
	{
		boolean matchesctor = false
		if(ConstructorMatchesParameterTypes(Structures, rawname, types, matchesctor))
		{
			overloadname = rawname
		}
		else
		{	// TODO - this is a sloppy hack to work around the fact that operators don't short circuit properly yet
			if(!matchesctor)
			{
				if(!SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, rawname))
				{
					overloadname = rawname
				}
			}
		}
	}
}


FunctionWrapperMatchesParameterTypes : FunctionDefinition ref func, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = CheckParameterTypesForMatch(func.Params, types)
}

FunctionWrapperMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	match = FunctionMatchesParameterTypes(Functions, funcname, types)
}


FunctionMatchesParameterTypes : list<FunctionDefinition> ref functions, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, funcname, wrap)
	if(found)
	{
		match = CheckParameterTypesForMatch(wrap, types)
	}
	else
	{
		match = FunctionMatchesParameterTypes(nothing, funcname, types)
	}
}

FunctionMatchesParameterTypes : nothing, integer funcname, simplelist<integer> ref types -> boolean match = false
{
	if(funcname == PooledStringHandleForSubstringWithLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x02000000)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		simplelist<integer> ptypes = 0x01000004, nothing
		simpleprepend<integer>(ptypes, 0x01000001)
		simpleprepend<integer>(ptypes, 0x82000001)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		simplelist<integer> ptypes = 0x02000000, nothing
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForBuffer)
	{
		simplelist<integer> ptypes = 0x01000001, nothing
		simpleprepend<integer>(ptypes, 0x01000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	elseif(funcname == PooledStringHandleForBufferCopy)
	{
		simplelist<integer> ptypes = 0x02000001, nothing
		simpleprepend<integer>(ptypes, 0x01000000)
		match = CheckParameterTypesForMatch(types, ptypes)
	}
	else
	{
		boolean ignored = false
		match = ConstructorMatchesParameterTypes(Structures, funcname, types, ignored)
	}
}


ConstructorMatchesParameterTypes : list<StructureDefinition> ref structures, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> boolean match = false
{
	if(structures.value.ConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}

		match = CheckMemberTypes(structures.value.Members, types.next)
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		matchesctor = true
		match = CheckMemberTypes(structures.value.Members, types)
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		matchesctor = true
		if(types.value != 0x01000000)		// identifier type signature
		{
			return()
		}

		match = CheckCopyType(types.next, structures.value.Type)
	}
	else
	{
		match = ConstructorMatchesParameterTypes(structures.next, ctorname, types, matchesctor)
	}
}

ConstructorMatchesParameterTypes : nothing, integer ctorname, simplelist<integer> ref types, boolean ref matchesctor -> false


CheckCopyType : simplelist<integer> ref a, integer b -> boolean match = (a.value == b)


CheckParameterTypesForMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	integer count = countnonzero(types)
	if(count == 0)
	{
		match = true
	}
	elseif(count == 1)
	{
		if(types.value == 0x00000002)		// void type signature
		{
			match = true
		}
	}
}

CheckParameterTypesForMatch : FunctionDefinition ref func, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(func.Params, types)
CheckParameterTypesForMatch : FunctionParams ref params, simplelist<integer> ref types -> boolean match = CheckParameterTypesForMatch(params.Params, types)


CheckParameterTypesForMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	if(!ResolvedTypesMatch(params, types))
	{
		match = false
	}
}

CheckParameterTypesForMatch : simplelist<integer> ref atypes, simplelist<integer> ref btypes -> boolean match = TypesMatch(atypes, btypes)


DumpUnresolvedParameters : list<UnresolvedParameter> ref params
{
	print(GetPooledString(GlobalStrings, GetNameOfType(params.value.ResolvedType)))
	DumpUnresolvedParameters(params.next)
}

DumpUnresolvedParameters : nothing


TypesMatch : simplelist<integer> ref a, simplelist<integer> ref b -> boolean match = true
{
	if(a.value != b.value)
	{
		match = false
	}
	else
	{
		match = TypesMatch(a.next, b.next)
	}
}

TypesMatch : nothing, nothing -> true

TypesMatch : nothing, simplelist<integer> ref b -> boolean match = (b.value == 0)
TypesMatch : simplelist<integer> ref a, nothing -> boolean match = (a.value == 0)



ResolvedTypesMatch : nothing, nothing -> true

ResolvedTypesMatch : list<UnresolvedParameter> ref params, nothing -> false
ResolvedTypesMatch : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}

ResolvedTypesMatch : list<UnresolvedParameter> ref params, simplelist<integer> ref types -> boolean match = true
{
	integer resolved = params.value.ResolvedType
	while((resolved & 0x7f000000) == 0x05000000)
	{
		resolved = FindTypeAliasBase(TypeAliases, resolved)
	}

	integer expected = types.value
	while((expected & 0x7f000000) == 0x0500000)
	{
		expected = FindTypeAliasBase(TypeAliases, expected)
	}

	if(MakeNonReferenceType(resolved) != MakeNonReferenceType(expected))
	{
		match = false
		return()
	}


	listnode<UnresolvedParameter> n = params.next
	simplelistnode<integer> nt = types.next
	match = ResolvedTypesMatch(n, nt)			// TODO - this is some kind of compiler bug... or maybe a runtime bug?!
}


GetAssignmentRHSType : Expression ref expr -> integer rettype = expr.Type
GetAssignmentRHSType : Assignment ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)
GetAssignmentRHSType : AssignmentCompound ref assignment -> integer rettype = GetAssignmentRHSType(assignment.RHS)


TypeInference : Assignment ref assignment, InferenceContext ref context -> boolean success = true
{
	integer vartype = GetVariableTypeFromScope(context.ScopeRef.Wrapped, assignment.LHSName)
	if(vartype == 0)
	{
		success = false
		print("Assignment to non-existent variable " ; GetPooledString(GlobalStrings, assignment.LHSName))
		return()
	}

	simplelist<integer> temp = vartype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}

	assignment.LHSType = vartype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?

		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}

	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : AssignmentCompound ref assignment, InferenceContext ref context -> boolean success = true
{
	integer lhstype = ComputeCompoundAssignmentLHSType(assignment, context.ScopeRef.Wrapped)

	simplelist<integer> temp = lhstype, nothing
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(assignment.RHS, newcontext))
	{
		print("Failed to infer type of RHS of assignment")
		success = false
	}

	assignment.LHSType = lhstype

	if(assignment.LHSType != GetAssignmentRHSType(assignment.RHS))
	{
		// TODO - check type of RHS vs. LHS?

		assignment.Annotation = GetAssignmentRHSType(assignment.RHS)
	}

	assignment.Operator = FindAssignmentOperator(assignment.Operator, assignment.LHSType, GetAssignmentRHSType(assignment.RHS))
}

TypeInference : EntityChain ref chain, InferenceContext ref context -> boolean success = TypeInference(chain.Entries, context)

TypeInference : EntityList ref entities, InferenceContext ref context -> boolean success = TypeInference(entities.ActualList, context)

TypeInference : list<Entity> ref entities, InferenceContext ref context -> boolean success = true
{
	if(!TypeInference(entities.value, context))
	{
		success = false
	}

	if(!TypeInference(entities.next, context))
	{
		success = false
	}
}

TypeInference : Entity ref entity, InferenceContext ref context -> boolean success = true
{
	simplelist<integer> temp = 0x01000003, nothing			// TODO - don't assume all entities take a boolean!
	InferenceContext newcontext = context.ScopeName, -1, temp, false, 0, false, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(entity.Param, newcontext))
	{
		success = false
	}

	if(!TypeInference(entity.Code, context))
	{
		success = false
	}
}


TypeInference : ExpressionList ref parameters, InferenceContext ref context -> boolean success = true
{
	boolean hasallparams = false

	if((context.NumParameters > 0) && (!IsRecognizedBuiltIn(context.StatementName)))
	{
		ParameterTypeList dummyparaminfo = globalemptyintlist
		list<ParameterTypeList> paramtypeinfo = dummyparaminfo, nothing

		integer i = 1
		while(i < context.NumParameters)
		{
			ParameterTypeList dummyparaminfo2 = globalemptyintlist
			prepend<ParameterTypeList>(paramtypeinfo, dummyparaminfo2)

			++i
		}

		hasallparams = GatherAllPossibleParamTypes(context.StatementName, context.NumParameters, context.TopLevelStatement, paramtypeinfo)
	}

	if(!TypeInferenceExpressionList(parameters.Expressions, context, 0, hasallparams, paramtypeinfo))
	{
		success = false
	}
}


GatherAllPossibleParamTypes : integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	ContextNode<FunctionDefinition> wrap = nothing
	found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, funcname, wrap)
	if(found)
	{
		InferAllFunctionParameterTypes(wrap, numparams, toplevel, outinfo)
		EnumerateOverloadsAndAddAllParameterTypes(wrap, numparams, toplevel, outinfo)
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(Structures, funcname, numparams, toplevel, outinfo)
	}
}

GatherAllPossibleParamTypesForConstructor : list<StructureDefinition> ref structures, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> boolean found = false
{
	if(structures.value.ConstructorName == funcname)
	{
		integer membercount = structures.value.MemberCount
		if(numparams == (membercount + 1))
		{
			simpleprepend<integer>(outinfo.value.Types, 0x01000000)		// Identifier type signature
			ExtractAllMemberTypes(structures.value.Members, outinfo.next)
			found = true
		}

		if(numparams == membercount)
		{
			ExtractAllMemberTypes(structures.value.Members, outinfo)
			found = true
		}

		if(numparams == 2)
		{
			AddTypeToParamTypeList(outinfo, 0x01000000)			// Identifier type signature
			AddTypeToParamTypeList(outinfo.next, structures.value.Type)
			found = true
		}
	}
	else
	{
		found = GatherAllPossibleParamTypesForConstructor(structures.next, funcname, numparams, toplevel, outinfo)
	}
}

GatherAllPossibleParamTypesForConstructor : nothing, integer funcname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo -> false


AddTypeToParamTypeList : list<ParameterTypeList> ref outinfo, integer ty
{
	simpleprepend<integer>(outinfo.value.Types, ty)
}

ExtractAllMemberTypes : list<StructureMember> ref members, list<ParameterTypeList> ref outinfo
{
	simpleprepend<integer>(outinfo.value.Types, GetMemberTypeDecompose(members.value))
	ExtractAllMemberTypes(members.next, outinfo.next)
}

ExtractAllMemberTypes : nothing, nothing


EnumerateOverloadsAndAddAllParameterTypes : FunctionDefinition ref func, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	EnumerateOverloadsAndAddAllParameterTypes(func.Overloads, numparams, toplevel, outinfo)
}

EnumerateOverloadsAndAddAllParameterTypes : list<Overload> ref overloads, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	AddAllParameterTypesForOverloadImplementation(overloads.value.Implementation, overloads.value.MangledName, numparams, toplevel, outinfo)
	EnumerateOverloadsAndAddAllParameterTypes(overloads.next, numparams, toplevel, outinfo)
}

EnumerateOverloadsAndAddAllParameterTypes : nothing, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo


AddAllParameterTypesForOverloadImplementation : FunctionDefinition ref function, integer mangledname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	InferAllFunctionParameterTypes(function, numparams, toplevel, outinfo)
}

AddAllParameterTypesForOverloadImplementation : nothing, integer mangledname, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo


InferAllFunctionParameterTypes : FunctionDefinition ref function, integer numparams, boolean toplevel, list<ParameterTypeList> ref outinfo
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}

	UnwrapAllParamsForTypeRetrieval(function.Params, numparams, outinfo)
}


UnwrapAllParamsForTypeRetrieval : FunctionParams ref params, integer paramcount, list<ParameterTypeList> ref outinfo
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveAllParamTypes(params.Params, outinfo)
	}
}

UnwrapAllParamsForTypeRetrieval : nothing, integer paramcount, list<ParameterTypeList> ref outinfo


RetrieveAllParamTypes : list<UnresolvedParameter> ref params, list<ParameterTypeList> ref outinfo [nogc]
{
	simpleprepend<integer>(outinfo.value.Types, params.value.ResolvedType)
	RetrieveAllParamTypes(params.next, outinfo.next)
}

RetrieveAllParamTypes : nothing, nothing [nogc]


GrabTypeListAtIndex : list<ParameterTypeList> ref paraminfo, integer paramindex, simplelist<integer> ref out [nogc]
{
	if(paramindex == 0)
	{
		out = paraminfo.value.Types
		return()
	}

	GrabTypeListAtIndex(paraminfo.next, paramindex - 1, out)
}


TypeInferenceExpressionList : list<Expression> ref parameters, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true
{
	simplelist<integer> temp = 0, nothing

	if(hasallparams)
	{
		GrabTypeListAtIndex(paraminfo, paramindex, temp)
	}
	else
	{
		GetExpectedParameterTypes(context.StatementName, paramindex, context.NumParameters, context.TopLevelStatement, temp)
	}

	InferenceContext newcontext = context.ScopeName, context.StatementName, temp, context.FunctionReturn, context.NumParameters, context.TopLevelStatement, false, context.ScopeRef, context.FuncRef

	if(!TypeInference(parameters.value, newcontext))
	{
		print("Parameter " ; cast(string, paramindex) ; " failed type inference!")
		success = false
	}
	else
	{
		context.StatementName = newcontext.StatementName
	}

	if(!TypeInferenceExpressionList(parameters.next, context, paramindex + 1, hasallparams, paraminfo))
	{
		success = false
	}
}

TypeInferenceExpressionList : nothing, InferenceContext ref context, integer paramindex, boolean hasallparams, list<ParameterTypeList> ref paraminfo -> boolean success = true


countatoms : list<ExpressionAtom> ref atoms -> integer count = 1 + countatoms(atoms.next)
countatoms : nothing -> 0


TypeInference : Expression ref expression, InferenceContext ref context -> boolean success = true
{
	if(expression.Type != 0)
	{
		return()
	}

	if(ExpressionAtomIsSentinel(expression.Atoms.value))
	{
		expression.Type = 0x00000002
		return()
	}

	if(countatoms(expression.Atoms) > 1)
	{
		CoalesceMemberAccesses(expression.Atoms, context.ScopeRef.Wrapped)
		ShuntingYard(expression.Atoms)
		
		InferencePossibility temp = 0, scratchparampossibles, scratchreturns
		list<InferencePossibility> possibilities = temp, nothing
		ExpressionInferenceStackEntry stackentry = possibilities
		list<ExpressionInferenceStackEntry> stack = stackentry, nothing

		integer counter = 0

		WalkAtomsForType(expression.Atoms, expression.Atoms.next, stack, counter, context)

		integer possibilitycount = CountPossibilities(stack.value.PossibilityList)
		if(possibilitycount == 1)
		{
			if((!context.FunctionReturn) && (context.StatementName != 0))
			{
				simplelist<integer> types = 0, nothing
				integer typecount = EliminateImpossibleType(stack.value.PossibilityList.value.ReturnType.Types, context.ExpectedTypes, types)

				if(typecount == 1)
				{
					assertmsg(types.value != 0, "Inferred a non-type!")
					expression.Type = types.value
				}
				elseif(typecount > 1)
				{
					print("Multiple types possible:")
					DumpTypeList(types)
				}
				else
				{
					// TODO - demotion logic here is MESSY
					if((countnonzero(stack.value.PossibilityList.value.ReturnType.Types) == 1) && (countnonzero(context.ExpectedTypes) == 1) && (stack.value.PossibilityList.value.ReturnType.Types.value == 0x01000001) && (context.ExpectedTypes.value == 0x01000002))
					{
						expression.Type = 0x01000002
					}
					else
					{
						print("All types ruled out")
						DumpTypeList(stack.value.PossibilityList.value.ReturnType.Types)
						print("Expected types are")
						DumpTypeList(context.ExpectedTypes)
					}
				}
			}
			else
			{
				simplelist<integer> possibletypes = 0, nothing
				FilterTypesForDemotion(stack.value.PossibilityList.value.ReturnType.Types, possibletypes)

				integer typecount = countnonzero(possibletypes)
				if(typecount == 1)
				{
					expression.Type = possibletypes.value
					assertmsg(expression.Type != 0, "Ruled out all types but a non-type!")
				}
				elseif(context.FunctionReturn)
				{
					print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
					DumpTypeList(possibletypes)
				}
				else
				{
					print("Expression has " ; cast(string, typecount) ; " types possible")
					DumpTypeList(possibletypes)
				}
			}
		}
		else
		{
			// TODO - error context!
			if(possibilitycount > 0)
			{
				print("Multiple overloads possible:")
				DumpOverloadList(stack.value.PossibilityList)
			}
			else
			{
				print("No types possible in this expression:")
				DumpExpressionAtoms(expression.Atoms)
				print("End expression")
			}
		}
	}
	else
	{
		simplelist<integer> possibletypes = 0, nothing
		TypePossibilityList poss = possibletypes, false
		GetAtomType(expression.Atoms.value, poss, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		if((!context.FunctionReturn) && (context.StatementName != 0))
		{
			simplelist<integer> types = 0, nothing
			integer typecount = EliminateImpossibleType(poss.Types, context.ExpectedTypes, types)

			if(typecount == 1)
			{
				expression.Type = types.value
			}
			elseif(typecount > 1)
			{
				print("Multiple types possible:")
				DumpTypeList(types)
			}
			else
			{
				print("Can't figure out type of expression atom!")
				DumpAtom(expression.Atoms.value)
				success = false
			}
		}
		else
		{
			simplelist<integer> filtered = 0, nothing
			FilterTypesForDemotion(poss.Types, filtered)

			integer typecount = countnonzero(filtered)
			if(typecount == 1)
			{
				expression.Type = filtered.value
				assertmsg(expression.Type != 0, "Ruled out all types but a non-type!")
			}
			elseif(context.FunctionReturn)
			{
				print("Failed to infer return type of function - " ; cast(string, typecount) ; " types possible")
				DumpTypeList(filtered)
			}
			else
			{
				print("Expression has " ; cast(string, typecount) ; " types possible")
				DumpTypeList(filtered)
			}
		}
	}

	if(expression.Type == 0)
	{
		success = false
	}
	elseif(expression.Type == 0x01000002)
	{
		DemoteAtomType(expression.Atoms)
	}
	elseif((expression.Type & 0x7f000000) == 0x09000000)
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
	elseif(IsStructureType(expression.Type))
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
	elseif(expression.Type == 0x01000000)
	{
		SetAtomType(expression.Atoms.value, expression.Type)
	}
}


CountPossibilities : list<InferencePossibility> ref thelist -> integer count = 0 [nogc]
{
	if(thelist.value.FunctionName != 0)
	{
		++count
	}

	count += CountPossibilities(thelist.next)
}

CountPossibilities : nothing -> 0 [nogc]


countnonzero : simplelist<integer> ref thelist -> integer count = 0 [nogc]
{
	if(thelist.value != 0)
	{
		++count
	}

	count += countnonzero(thelist.next)
}

countnonzero : nothing -> 0 [nogc]


SetAtomType : IdentifierAtom ref atom, integer typeid [nogc]
{
	atom.Type = typeid
}

SetAtomType : CompoundAtom ref atom, integer typeid [nogc]
{
	atom.Type = typeid
}

SetAtomType : Statement ref atom, integer typeid [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref tail, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	boolean didrightdemote = WalkAtomsForType(tail, tail.next, stack, counter, context)
	boolean unarycompensate = false

	if(IsOperatorInvoke(tail.value))
	{
		if(IsUnaryOperator(tail.value))
		{
			SetOperatorAtomToOverload(tail, stack.value.PossibilityList.value.FunctionName, 0)
			unarycompensate = true
		}
	}

	if(IsOperatorInvoke(atoms.value))
	{
		if(counter > 0)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter + 1)
			--counter
		}

		list<InferencePossibility> possibleoperators = scratchpossibility, nothing
		GetAtomTypeOperator(atoms.value, possibleoperators)

		ExpressionInferenceStackEntry entry = possibleoperators
		prepend<ExpressionInferenceStackEntry>(stack, entry)
	}
	else
	{
		list<InferencePossibility> out = scratchpossibility, nothing
		EliminateImpossibleParametersForAllOverloads(stack.value.PossibilityList, out, atoms.value, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		if(counter == 1)
		{
			list<InferencePossibility> filtered = scratchpossibility, nothing
			FilterOverloadsForTypeDemotion(out, filtered)
			stack.value.PossibilityList = filtered
		}
		else
		{
			stack.value.PossibilityList = out
		}

		if(CountPossibilities(stack.value.PossibilityList) == 1)
		{
			if(listcontains(stack.value.PossibilityList.value.ParameterTypes.value.Types, 0x01000002))
			{
				DemoteAtomType(atoms)
				demotedtoright = true

				if((!didrightdemote) && (!IsOperatorInvoke(tail.value)))
				{
					DemoteAtomType(tail)
				}
			}
		}
		elseif(didrightdemote)
		{
			DemoteAtomType(atoms)
		}

		++counter
		if(counter > 1)
		{
			SetOperatorAtomToOverload(atoms, stack.value.PossibilityList.value.FunctionName, counter)
			++counter
		}

		if(AllOptionsConsumed(stack.value.PossibilityList.value.ParameterTypes))
		{
			stack.value.PossibilityList.value.ReturnType.Consumed = true
			CopyReturnTypeToParamTypes(stack, stack.next)
		}
	}

	if(unarycompensate)
	{
		++counter
	}
}


CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail
{
	AddPossibleParamTypeForAllOverloads(tail.value.PossibilityList, stack.value.PossibilityList.value.ReturnType)
	PopExpressionInferenceStack(stack, tail)
}

CopyReturnTypeToParamTypes : list<ExpressionInferenceStackEntry> ref stack, nothing



AddPossibleParamTypeForAllOverloads : list<InferencePossibility> ref possibilities, TypePossibilityList ref paramtypes
{
	prepend<TypePossibilityList>(possibilities.value.ParameterTypes, paramtypes)

	AddPossibleParamTypeForAllOverloads(possibilities.next, paramtypes)
}

AddPossibleParamTypeForAllOverloads : nothing, TypePossibilityList ref paramtypes


AllOptionsConsumed : list<TypePossibilityList> ref options -> boolean allconsumed = true [nogc]
{
	if(!options.value.Consumed)
	{
		if(countnonzero(options.value.Types) > 0)
		{
			allconsumed = false
		}
		else
		{
			allconsumed = AllOptionsConsumed(options.next)
		}
	}
	else
	{
		allconsumed = AllOptionsConsumed(options.next)
	}
}

AllOptionsConsumed : nothing -> true [nogc]


PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, list<ExpressionInferenceStackEntry> ref tail [nogc]
{
	stack = tail
}

PopExpressionInferenceStack : list<ExpressionInferenceStackEntry> ref stack, nothing [nogc]


WalkAtomsForType : list<ExpressionAtom> ref atoms, nothing, list<ExpressionInferenceStackEntry> ref stack, integer ref counter, InferenceContext ref context -> boolean demotedtoright = false
{
	if(IsOperatorInvoke(atoms.value))
	{
		GetAtomTypeOperator(atoms.value, stack.value.PossibilityList)
	}
	else
	{
		TypePossibilityList poss = scratchpossibletypes, false
		InferencePossibility newpossibility = -1, scratchparampossibles, poss
		GetAtomType(atoms.value, newpossibility.ReturnType, context.ScopeRef.Wrapped, context.FuncRef.Wrapped, context.FunctionReturn, context.Parenthetical)

		prepend<InferencePossibility>(stack.value.PossibilityList, newpossibility)
	}
}


EliminateImpossibleParametersForAllOverloads : list<InferencePossibility> ref possibilities, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(possibilities.value.FunctionName != 0)
	{
		if(EliminateImpossibleParameters(possibilities.value.ParameterTypes, atom, scope, func, funcret, parenthetical))
		{
			prepend<InferencePossibility>(out, possibilities.value)
		}
	}

	EliminateImpossibleParametersForAllOverloads(possibilities.next, out, atom, scope, func, funcret, parenthetical)
}

EliminateImpossibleParametersForAllOverloads : nothing, list<InferencePossibility> ref out, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical


EliminateImpossibleParameters : list<TypePossibilityList> ref params, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> boolean valid = true
{
	if(!params.value.Consumed)
	{
		TypePossibilityList poss = scratchpossibletypes, false
		GetAtomType(atom, poss, scope, func, funcret, parenthetical)

		simplelist<integer> types = 0, nothing
		integer typecount = EliminateImpossibleType(params.value.Types, poss.Types, types)

		if(typecount == 0)
		{
			valid = false
		}

		params.value.Types = types
		params.value.Consumed = true
	}
	else
	{
		if(!EliminateImpossibleParameters(params.next, atom, scope, func, funcret, parenthetical))
		{
			valid = false
		}
	}
}


EliminateImpossibleParameters : nothing, ExpressionAtom ref atom, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical -> true


SetOperatorAtomToOverload : list<ExpressionAtom> ref atoms, integer overloadname, integer count [nogc]
{
	if(count == 0)
	{
		ChangeOperator(atoms.value, overloadname)
	}
	else
	{
		SetOperatorAtomToOverload(atoms.next, overloadname, count - 1)
	}
}

ChangeOperator : OperatorInvokeAtom ref atom, integer overloadname [nogc]
{
	atom.OperatorName = overloadname
}



EliminateImpossibleType : simplelist<integer> ref possibles, simplelist<integer> ref filter, simplelist<integer> ref out -> integer count = 0 [nogc]
{
	count = EliminateImpossibleType(possibles.next, filter, out)

	if(possibles.value != 0)
	{
		integer expectedtype = TypeListContains(filter, possibles.value)
		if(expectedtype != 0)
		{
			count = count + 1
			simpleprepend<integer>(out, expectedtype)
		}
	}
}

EliminateImpossibleType : nothing, simplelist<integer> ref filter, simplelist<integer> ref out -> 0 [nogc]


GetAtomType : AtomSentinel       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x00000002) }	// void magic
GetAtomType : StringHandleAtom   ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x02000000) }
GetAtomType : TypeAnnotationAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000001) }
GetAtomType : integer16          ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000002) }
GetAtomType : boolean            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000003) }
GetAtomType : real               ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, 0x01000004) }

GetAtomType : integer            ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	AddPossibleParameter(possibilities.Types, 0x01000001)
	AddPossibleParameter(possibilities.Types, 0x01000002)			// Allow demotion later
}

GetAtomType : CompoundAtom       ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical { AddPossibleParameter(possibilities.Types, atom.Type)  }

GetAtomType : Statement ref statement, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	ContextWrapper<Scope> scopewrap = scope
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext newcontext = scope.Name, statement.Name, globalemptyintlist, funcret, 0, false, false, scopewrap, funcwrap

	if(TypeInference(statement, newcontext))
	{
		AddPossibleParameter(possibilities.Types, statement.Type)
	}
}

GetAtomType : RefBinding ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical

GetAtomType : ParentheticalExpression ref parenthetical, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean isinparenthetical
{
	ContextWrapper<Scope> scopewrap = scope
	ContextWrapper<FunctionDefinition> funcwrap = func
	InferenceContext newcontext = scope.Name, 0, globalemptyintlist, funcret, 0, false, true, scopewrap, funcwrap

	if(TypeInference(parenthetical.Inner, newcontext))
	{
		AddPossibleParameter(possibilities.Types, GetParentheticalType(parenthetical.Inner))
	}
	else
	{
		print("Parenthetical expression failed type inference")
	}
}

GetParentheticalType : PreOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : PostOpStatement ref statement -> integer rettype = statement.Type [nogc]
GetParentheticalType : Expression ref expr -> integer rettype = expr.Type [nogc]

GetAtomTypeOperator : OperatorInvokeAtom ref atom, list<InferencePossibility> ref possibilities
{
	AddPossibilityPerOperatorOverload(atom.OperatorName, possibilities)
}

GetAtomType : IdentifierAtom ref atom, TypePossibilityList ref possibilities, Scope ref scope, ContextNode<FunctionDefinition> ref func, boolean funcret, boolean parenthetical
{
	if(atom.Handle == PooledStringHandleForNothing)
	{
		atom.Type = 0x00000004
		AddPossibleParameter(possibilities.Types, 0x00000004)
		return()
	}

	if((!parenthetical) && (!funcret))
	{
		AddPossibleParameter(possibilities.Types, 0x01000000)
	}

	integer nametype = GetTypeByName(atom.Handle)
	if(nametype != 0)
	{
		if(IsStructureType(nametype))
		{
			if(FunctionIsAutoGenOrHasIR(atom.Handle))
			{
				atom.IsFunction = true
			}
		}

		return()
	}


	integer vartype = GetVariableTypeFromScope(scope, atom.Handle)
	if(vartype != 0)
	{
		AddPossibleParameter(possibilities.Types, vartype)
		if((vartype & 0x7f000000) == 0x09000000)
		{
			atom.IsFunction = true
		}
	}
	else
	{
		if(SearchBinaryTree<FunctionDefinition>(FunctionsWhichExist, atom.Handle))
		{
			atom.IsFunction = true

			// TODO - overload resolution on higher order function name
			integer sigtype = FindFunctionAndGetSignatureType(Functions, atom.Handle)
			AddPossibleParameter(possibilities.Types, sigtype)
		}
		else
		{
			integer sigtype = FindBuiltinAndGetSignatureType(atom.Handle)
			if(sigtype != 0)
			{
				AddPossibleParameter(possibilities.Types, sigtype)
			}
			else
			{
				print(GetPooledString(GlobalStrings, atom.Handle) ; " is not a defined identifier!")
			}
		}
	}
}


IsOperatorInvoke : OperatorInvokeAtom 	   ref nonsentinel -> true [nogc]

IsOperatorInvoke : AtomSentinel 	   ref sentinel    -> false [nogc]
IsOperatorInvoke : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : IdentifierAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
IsOperatorInvoke : integer 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : integer16 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : boolean 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : real 		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : Statement		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : RefBinding              ref nonsentinel -> false [nogc]
IsOperatorInvoke : CompoundAtom		   ref nonsentinel -> false [nogc]
IsOperatorInvoke : ParentheticalExpression ref nonsentinel -> false [nogc]


IsRefBind : IdentifierAtom ref atom -> atom.IsReference [nogc]
IsRefBind : RefBinding ref atom -> true [nogc]
IsRefBind : CompoundAtom		   ref nonsentinel -> boolean ret = true [nogc]
{
	if(!IsReferenceType(nonsentinel.Type))
	{
		ret = false
	}
}

IsRefBind : TypeAnnotationAtom 	   ref nonsentinel -> false [nogc]
IsRefBind : AtomSentinel 	   ref sentinel    -> false [nogc]
IsRefBind : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsRefBind : integer 		   ref nonsentinel -> false [nogc]
IsRefBind : integer16 		   ref nonsentinel -> false [nogc]
IsRefBind : boolean 		   ref nonsentinel -> false [nogc]
IsRefBind : real 		   ref nonsentinel -> false [nogc]
IsRefBind : Statement		   ref nonsentinel -> false [nogc]
IsRefBind : ParentheticalExpression ref nonsentinel -> false [nogc]
IsRefBind : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]


IsTypeAnnotationAtom : TypeAnnotationAtom 	   ref nonsentinel -> true [nogc]

IsTypeAnnotationAtom : AtomSentinel 	   ref sentinel    -> false [nogc]
IsTypeAnnotationAtom : StringHandleAtom 	   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : IdentifierAtom 	   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : integer 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : integer16 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : boolean 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : real 		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : Statement		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : RefBinding              ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : CompoundAtom		   ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : ParentheticalExpression ref nonsentinel -> false [nogc]
IsTypeAnnotationAtom : OperatorInvokeAtom 	   ref nonsentinel -> false [nogc]



IsMemberAccessOperator : OperatorInvokeAtom 	 ref nonsentinel -> boolean ismemberaccess = false [nogc]
{
	if(nonsentinel.OperatorName == PooledStringHandleForMemberAccess)
	{
		ismemberaccess = true
	}
}

IsMemberAccessOperator : AtomSentinel 	   	 ref sentinel    -> false [nogc]
IsMemberAccessOperator : StringHandleAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : IdentifierAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : TypeAnnotationAtom 	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : integer 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : integer16 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : boolean 		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : real 		   	 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : Statement		 ref nonsentinel -> false [nogc]
IsMemberAccessOperator : RefBinding              ref nonsentinel -> false [nogc]
IsMemberAccessOperator : CompoundAtom            ref nonsentinel -> false [nogc]
IsMemberAccessOperator : ParentheticalExpression ref nonsentinel -> false [nogc]



MarkAtomAsReference : OperatorInvokeAtom      ref atom -> false [nogc]
MarkAtomAsReference : AtomSentinel 	      ref atom -> false [nogc]
MarkAtomAsReference : StringHandleAtom 	      ref atom -> false [nogc]
MarkAtomAsReference : TypeAnnotationAtom      ref atom -> false [nogc]
MarkAtomAsReference : integer 		      ref atom -> false [nogc]
MarkAtomAsReference : integer16               ref atom -> false [nogc]
MarkAtomAsReference : boolean 		      ref atom -> false [nogc]
MarkAtomAsReference : real 		      ref atom -> false [nogc]
MarkAtomAsReference : Statement		      ref atom -> false [nogc]
MarkAtomAsReference : ParentheticalExpression ref atom -> false [nogc]

MarkAtomAsReference : RefBinding              ref atom -> true [nogc]

MarkAtomAsReference : IdentifierAtom          ref atom -> true [nogc]
{
	atom.IsReference = true
}

MarkAtomAsReference : CompoundAtom            ref atom -> true [nogc]
{
	atom.Type = MakeReferenceType(atom.Type)
}


AddPossibleParameter : simplelist<integer> ref possibilities, integer paramtype [nogc]
{
	simpleprepend<integer>(possibilities, paramtype)

	if((paramtype & 0x7f000000) == 0x05000000)
	{
		simpleprepend<integer>(possibilities, FindTypeAliasBase(TypeAliases, paramtype))
	}
}

AddBinaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer param2type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing
	simplelist<integer> p2t = param2type, nothing

	TypePossibilityList param1options = p1t, false
	TypePossibilityList param2options = p2t, false

	list<TypePossibilityList> paramtypes = param2options, nothing
	prepend<TypePossibilityList>(paramtypes, param1options)

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}

AddUnaryPossibility : list<InferencePossibility> ref possibilities, integer functionname, integer param1type, integer rettype [nogc]
{
	assertmsg(functionname != 0, "Cannot configure inference possibility for nameless function")

	simplelist<integer> p1t = param1type, nothing

	TypePossibilityList param1options = p1t, false

	list<TypePossibilityList> paramtypes = param1options, nothing

	simplelist<integer> rt = rettype, nothing
	TypePossibilityList rettypelist = rt, false

	InferencePossibility possibility = functionname, paramtypes, rettypelist
	prepend<InferencePossibility>(possibilities, possibility)
}


ShuntingYard : list<ExpressionAtom> ref atoms
{
	AtomSentinel sentinel = 0

	list<ExpressionAtom> outputqueue = sentinel, nothing
	list<ExpressionAtom> opstack = sentinel, nothing

	ShuntingYardWalk(atoms, outputqueue, opstack)
	ShuntingYardFlush(outputqueue, opstack)

	atoms = outputqueue
}

ShuntingYardWalk : nothing, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack

ShuntingYardWalk : list<ExpressionAtom> ref atoms, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	ShuntingYardVisit(atoms.value, outputqueue, opstack)
	ShuntingYardWalk(atoms.next, outputqueue, opstack)
}

ShuntingYardVisit : AtomSentinel            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
ShuntingYardVisit : StringHandleAtom        ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : IdentifierAtom          ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : TypeAnnotationAtom      ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : integer16               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : boolean                 ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : real                    ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : Statement               ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : RefBinding              ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : ParentheticalExpression ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }
ShuntingYardVisit : CompoundAtom            ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack	{ ExpressionAtom wrap = atom  PlaceAtomInList(outputqueue, wrap) }

ShuntingYardVisit : OperatorInvokeAtom ref atom, list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	integer opprec = GetOperatorPrecedence(atom)
	boolean continueops = true

	while(continueops && (!ExpressionAtomIsSentinel(opstack.value)))
	{
		ExpressionAtom opatom2 = opstack.value
		integer op2prec = GetOperatorPrecedence(opatom2)

		// TODO - this whole section is hacky. Replace with break() calls and >= operator.

		if(IsUnaryOperator(atom))
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
			elseif(opprec == op2prec)
			{
				continueops = false
			}
		}
		else
		{
			if(opprec > op2prec)
			{
				continueops = false
			}
		}

		if(continueops)
		{
			PlaceAtomInList(outputqueue, opatom2)
			ShuntingYardPopStack(opstack, opstack.next)
		}
	}

	ExpressionAtom wrap = atom
	prepend<ExpressionAtom>(opstack, wrap)
}

ShuntingYardFlush : list<ExpressionAtom> ref outputqueue, list<ExpressionAtom> ref opstack
{
	while(!ExpressionAtomIsSentinel(opstack.value))
	{
		PlaceAtomInList(outputqueue, opstack.value)
		ShuntingYardPopStack(opstack, opstack.next)
	}
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, list<ExpressionAtom> ref tail [nogc]
{
	opstack = tail
}

ShuntingYardPopStack : list<ExpressionAtom> ref opstack, nothing [nogc]
{
	AtomSentinel sentinel = 0
	list<ExpressionAtom> newlist = sentinel, nothing
	opstack = newlist
}


IsUnaryOperator : OperatorInvokeAtom ref atom -> boolean isunary = false [nogc]
{
	if(atom.OperatorName == PooledStringHandleForUnaryNot)
	{
		isunary = true
	}
}


GetOperatorPrecedence : OperatorInvokeAtom ref atom -> integer precedence = 0 [nogc]
{
	if(atom.OperatorName == PooledStringHandleForEquality)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForInequality)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForGreaterThan)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForLessThan)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForBooleanAnd)
	{
		precedence = 0
	}
	elseif(atom.OperatorName == PooledStringHandleForBitwiseAnd)
	{
		precedence = 1		// TODO - revisit all operator precedences
	}
	elseif(atom.OperatorName == PooledStringHandleForStringConcat)
	{
		precedence = 3
	}
	elseif(atom.OperatorName == PooledStringHandleForPlus)
	{
		precedence = 5
	}
	elseif(atom.OperatorName == PooledStringHandleForMinus)
	{
		precedence = 5
	}
	elseif(atom.OperatorName == PooledStringHandleForMultiply)
	{
		precedence = 9
	}
	elseif(atom.OperatorName == PooledStringHandleForDivide)
	{
		precedence = 9
	}
	elseif(atom.OperatorName == PooledStringHandleForUnaryNot)
	{
		precedence = 10
	}
	elseif(atom.OperatorName == PooledStringHandleForMemberAccess)
	{
		precedence = 11
	}
	else
	{
		print("Unknown operator " ; GetPooledString(GlobalStrings, atom.OperatorName))
		assert(false)
	}
}


ConstructVariableFromStatement : Statement ref statement, Scope ref scope, integer vartype, integer origin
{
	integer varname = ExtractConstructorIdentifier(statement.Parameters)

	if(varname != 0)
	{
		// TODO - do real shadowing checks here
		Variable var = 0, 0, 0, 0
		FindVariableDataInSingleScope(scope, varname, var)
		if(var.Name != 0)
		{
			return()
		}

		StoreVariableInSingleScope(scope, varname, vartype, false, origin)
	}
}

ExtractConstructorIdentifier : ExpressionList ref parameters -> integer varname = ExtractConstructorIdentifier(parameters.Expressions)
ExtractConstructorIdentifier : list<Expression> ref parameters -> integer varname = ExtractIdentifier(parameters.value)
ExtractConstructorIdentifier : nothing -> 0

ExtractIdentifier : Expression ref expression -> integer id = ExtractIdentifier(expression.Atoms.value) [nogc]

ExtractIdentifier : IdentifierAtom ref atom -> atom.Handle [nogc]
{
	atom.Type = 0x81000000		// HACK - reference to identifier
}

ExtractIdentifier : AtomSentinel 	    ref sentinel    -> 0 [nogc]
ExtractIdentifier : StringHandleAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : OperatorInvokeAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : TypeAnnotationAtom 	    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : integer 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : integer16 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : boolean 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : real 		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : Statement		    ref nonsentinel -> 0 [nogc]
ExtractIdentifier : RefBinding              ref nonsentinel -> 0 [nogc]
ExtractIdentifier : CompoundAtom            ref nonsentinel -> 0 [nogc]
ExtractIdentifier : ParentheticalExpression ref nonsentinel -> 0 [nogc]


PlaceAtomInList : list<ExpressionAtom> ref atoms, ExpressionAtom ref atom
{
	if(ExpressionAtomIsSentinel(atoms.value))
	{
		atoms.value = atom
	}
	else
	{
		AppendAtomToExpression(atoms, atoms.next, atom)
	}
}



PoolString : string s -> integer handle = FindHandleInTrie(GlobalStringTrie, s) [nogc]
{
	if(handle == 0)
	{
		handle = PoolStringFast(s)
	}
}

PoolStringFast : string s -> integer handle = 0 [nogc]
{
	++CurrentStringHandle
	OnCodeGenRegisterString(CurrentStringHandle, s)
	handle = CurrentStringHandle
}


IREnterFunction : integer namehandle
{
	OnCodeGenRegisterScope(namehandle, 0)
}

IRExitFunction :
{
	OnCodeGenExitContext()
}


IREnterStatement : string funcname, boolean istoplevel, boolean hastemplateargs
{
	integer namehandle = PoolString(funcname)
	OnCodeGenEnterStatement(namehandle, 0, istoplevel, hastemplateargs)
}

IRExitStatement :
{
	OnCodeGenExitContext()
}


IRAddOperator : string operatorname
{
	OnCodeGenRegisterOperatorInvoke(PoolString(operatorname))
}

IRAddLiteralString : string literal
{
	OnCodeGenRegisterLiteralString(PoolString(literal))
}

IRAddLiteralBoolean : boolean literal
{
	OnCodeGenRegisterLiteralBoolean(literal)
}

IRAddLiteralReal : real literal
{
	OnCodeGenRegisterLiteralReal(literal)
}

IRAddLiteralInteger : integer literal
{
	OnCodeGenRegisterLiteralInteger(literal, 0x01000001)		// We can demote the integer later
}

IRAddLiteralIdentifier : string token
{
	OnCodeGenRegisterAtomIdentifier(PoolString(token), 0)
}



GetPooledString : list<StringTableEntry> ref strings, integer handle -> string pooled = "" [nogc]
{
	if(strings.value.Handle == handle)
	{
		pooled = strings.value.Data
	}
	else
	{
		pooled = GetPooledString(strings.next, handle)
	}
}

GetPooledString : nothing, integer handle -> "" [nogc]
{
	print("String handle not pooled: " ; cast(string, handle))
	assert(false)
}


DumpAtom : AtomSentinel 	   ref sentinel    { print("Sentinel") }
DumpAtom : StringHandleAtom 	   ref nonsentinel { print("String handle " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : IdentifierAtom 	   ref nonsentinel { print("Identifier " ; cast(string, nonsentinel.Handle) ; " = '" ; GetPooledString(GlobalStrings, nonsentinel.Handle) ; "'") }
DumpAtom : OperatorInvokeAtom 	   ref nonsentinel { print("Operator " ; cast(string, nonsentinel.OperatorName)) }
DumpAtom : TypeAnnotationAtom 	   ref nonsentinel { print("Type annotation") }
DumpAtom : integer 		   ref nonsentinel { print("integer " ; cast(string, nonsentinel)) }
DumpAtom : integer16 		   ref nonsentinel { print("integer16") }
DumpAtom : boolean 		   ref nonsentinel { print("boolean") }
DumpAtom : real 		   ref nonsentinel { print("real " ; cast(string, nonsentinel)) }
DumpAtom : RefBinding              ref nonsentinel { print("RefBinding") }
DumpAtom : ParentheticalExpression ref nonsentinel { print("Parenthetical") }
DumpAtom : CompoundAtom            ref nonsentinel { print("Compound") }

DumpAtom : Statement		   ref nonsentinel
{
	print("Statement " ; GetPooledString(GlobalStrings, nonsentinel.Name))
	print("BEGIN PARAMS")
	DumpParameterAtoms(nonsentinel.Parameters)
	print("END PARAMS")
}

DumpExpressionAtoms : list<ExpressionAtom> ref atoms
{
	DumpAtom(atoms.value)
	DumpExpressionAtoms(atoms.next)
}

DumpExpressionAtoms : nothing


DumpExpressionList : list<Expression> ref exprs
{
	print("BEGIN EXPR")
	DumpExpressionAtoms(exprs.value.Atoms)
	print("END EXPR")

	DumpExpressionList(exprs.next)
}

DumpExpressionList : nothing


DumpParameterAtoms : ExpressionList ref exprs
{
	DumpExpressionList(exprs.Expressions)
}

DumpParameterAtoms : nothing



AddPossibilityPerOperatorOverload : integer basenamehandle, list<InferencePossibility> ref possibilities
{
	if(basenamehandle == PooledStringHandleForEquality)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityInteger,   0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityInteger16, 0x01000002, 0x01000002, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityBoolean,   0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityReal,      0x01000004, 0x01000004, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForEqualityString,    0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForInequality)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityInteger, 0x01000001, 0x01000001, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityBoolean, 0x01000003, 0x01000003, 0x01000003)
		AddBinaryPossibility(possibilities, PooledStringHandleForInequalityString,  0x02000000, 0x02000000, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForGreaterThan)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForGreaterThanInteger, 0x01000001, 0x01000001, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForLessThan)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForLessThanInteger, 0x01000001, 0x01000001, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForPlus)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForPlusInteger, 0x01000001, 0x01000001, 0x01000001)
		AddBinaryPossibility(possibilities, PooledStringHandleForPlusReal, 0x01000004, 0x01000004, 0x01000004)
	}
	elseif(basenamehandle == PooledStringHandleForMinus)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForMinusInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForMultiply)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForMultiplyInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForDivide)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForDivideInteger, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForBitwiseAnd)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForBitwiseAnd, 0x01000001, 0x01000001, 0x01000001)
	}
	elseif(basenamehandle == PooledStringHandleForBooleanAnd)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForBooleanAnd, 0x01000003, 0x01000003, 0x01000003)
	}
	elseif(basenamehandle == PooledStringHandleForStringConcat)
	{
		AddBinaryPossibility(possibilities, PooledStringHandleForStringConcat, 0x02000000, 0x02000000, 0x02000000)
	}
	elseif(basenamehandle == PooledStringHandleForUnaryNot)
	{
		AddUnaryPossibility(possibilities, PooledStringHandleForUnaryNotBoolean, 0x01000003, 0x01000003)
	}
	else
	{
		print("Unrecognized operator")
		assert(false)
	}
}


GetExpectedParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(funcname, paramindex, paramcount, toplevel, types)
	EnumerateOverloadsAndAddParameterTypes(AutoGenOverloads, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : list<Overload> ref overloads, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(overloads.value.NormalName == funcname)
	{
		AddParameterTypesForOverloadImplementation(overloads.value.Implementation, overloads.value.MangledName, paramindex, paramcount, toplevel, types)
	}

	EnumerateOverloadsAndAddParameterTypes(overloads.next, funcname, paramindex, paramcount, toplevel, types)
}

EnumerateOverloadsAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types


AddParameterTypesForOverloadImplementation : FunctionDefinition ref func, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!func.InferenceDone)
	{
		TypeInference(func, DummyContextForFunctions)
	}

	UnwrapParamsForTypeRetrieval(func.Params, paramindex, paramcount, types)
}

AddParameterTypesForOverloadImplementation : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	FindFunctionAndAddParameterTypes(funcname, paramindex, paramcount, toplevel, types)
}


InferFunctionParameterTypes : FunctionDefinition ref function, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!function.InferenceDone)
	{
		TypeInference(function, DummyContextForFunctions)
	}

	UnwrapParamsForTypeRetrieval(function.Params, paramindex, paramcount, types)
}

FindFunctionAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types
{
	if(!FindConstructorAndAddParameterTypes(Structures, funcname, paramindex, paramcount, toplevel, types))
	{
		FindBuiltinAndAddParameterTypes(funcname, paramindex, paramcount, types)
	}
}

UnwrapParamsForTypeRetrieval : FunctionParams ref params, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	if(CountUnresolvedParameters(params) == paramcount)
	{
		RetrieveParamType(params.Params, paramindex, types)
	}
}

UnwrapParamsForTypeRetrieval : nothing, integer paramindex, integer paramcount, simplelist<integer> ref types


RetrieveParamType : list<UnresolvedParameter> ref params, integer paramindex, simplelist<integer> ref types
{
	if(paramindex == 0)
	{
		simpleprepend<integer>(types, params.value.ResolvedType)
		return()
	}

	RetrieveParamType(params.next, paramindex - 1, types)
}

RetrieveParamType : nothing, integer paramindex, simplelist<integer> ref types
{
	print("Too many parameters to call!")
	assert(false)
}


InferFunctionReturnType : PendingTypeMatcher ref pending -> integer rettype = InferFunctionReturnType(pending.OverloadImplementation)

InferFunctionReturnType : FunctionDefinition ref func -> integer rettype = 0
{
	if(!func.InferenceDone)
	{
		TypeInference(func, DummyContextForFunctions)
	}

	rettype = GetOptionalExpressionType(func.Return)
}


GetFunctionReturnType : list<FunctionDefinition> ref functions, integer funcname -> integer rettype = 0
{
	if(functions.value.Name == funcname)
	{
		rettype = InferFunctionReturnType(functions.value)
	}
	else
	{
		rettype = GetFunctionReturnType(functions.next, funcname)
	}
}

GetFunctionReturnType : nothing, integer funcname -> integer rettype = 0
{
	ContextNode<PendingTypeMatcher> ignored = nothing
	rettype = GetPendingTypeMatcherReturnType(funcname, ignored)
}


GetOptionalExpressionType : Expression ref expr -> expr.Type [nogc]
GetOptionalExpressionType : nothing -> 0 [nogc]


FindBuiltinAndAddParameterTypes : integer funcname, integer paramindex, integer paramcount, simplelist<integer> ref types
{
	integer ctype = GetTypeByName(funcname)
	if((ctype & 0x7f000000) == 0x05000000)
	{
		funcname = GetNameOfType(FindTypeAliasBase(TypeAliases, ctype))
	}

	if((ctype & 0x7f000000) == 0x07000000)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				FindSumTypeAndPrependTypesToList(SumTypes, ctype, types)
			}
		}
		return()
	}

	if(funcname == PooledStringHandleForPassTest)
	{
		// No parameters
	}
	elseif(funcname == PooledStringHandleForAssert)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForPrint)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForInteger16)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForBoolean)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForReal)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForBuffer)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
				simpleprepend<integer>(types, 0x02000001)	// buffer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForNarrowString)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForUnescape)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubstringWithLength)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubstringNoLength)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSubchar)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastBooleanToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000003)	// boolean type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastRealToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastRealToString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastStringToReal)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastIntegerToString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastStringToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastInteger16ToInteger)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000002)	// integer16 type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastIntegerToInteger16)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCastBufferToString)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x82000001)	// reference to buffer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBuffer)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		if(paramcount == 4)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
			elseif(paramindex == 3)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		if(paramcount == 4)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 3)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		if(paramcount == 3)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x82000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 2)
			{
				simpleprepend<integer>(types, 0x01000004)	// real type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForLength)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000000)	// string type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWidenFromPtr)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForWidenFromBuffer)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x02000001)	// buffer type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}	
	}
	elseif(funcname == PooledStringHandleForCmdLineGet)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForCmdLineGetCount)
	{
		// no params
	}
	elseif(funcname == PooledStringHandleForCmdLineIsValid)
	{
		// no params
	}
	elseif(funcname == PooledStringHandleForMarshalStructure)
	{
		if(paramcount == 2)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
			elseif(paramindex == 1)
			{
				simpleprepend<integer>(types, 0x01000001)	// integer type signature
			}
		}
	}
	elseif(funcname == PooledStringHandleForSizeOf)
	{
		if(paramcount == 1)
		{
			if(paramindex == 0)
			{
				simpleprepend<integer>(types, 0x01000000)	// identifier type signature
			}
		}
	}
}


PrependSumTypeBases : simplelist<integer> ref input, list<SumTypeBase> ref newentries [nogc]
{
	simpleprepend<integer>(input, newentries.value.Name)
	PrependSumTypeBases(input, newentries.next)
}

PrependSumTypeBases : simplelist<integer> ref input, nothing [nogc]


FindSumTypeAndPrependTypesToList : list<SumType> ref sumtypes, integer sumtypeid, simplelist<integer> ref types [nogc]
{
	if(sumtypes.value.Type == sumtypeid)
	{
		PrependSumTypeBases(types, sumtypes.value.Bases)
	}
	else
	{
		FindSumTypeAndPrependTypesToList(sumtypes.next, sumtypeid, types)
	}
}


FindConstructorAndAddParameterTypes : list<StructureDefinition> ref structures, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> boolean hit = false
{
	integer membercount = structures.value.MemberCount

	if((structures.value.ConstructorName == funcname) && (paramcount == membercount + 1))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		else
		{
			FindMemberAndAddParameterTypes(structures.value.Members, paramindex - 1, types)
		}
		hit = true
	}
	elseif((structures.value.AnonConstructorName == funcname) && (paramcount == membercount))
	{
		FindMemberAndAddParameterTypes(structures.value.Members, paramindex, types)
		hit = true
	}
	elseif((toplevel) && (structures.value.CopyConstructorName == funcname) && (paramcount == 2))
	{
		if(paramindex == 0)
		{
			simpleprepend<integer>(types, 0x01000000)	// identifier type signature
		}
		elseif(paramindex == 1)
		{
			simpleprepend<integer>(types, structures.value.Type)
		}
		hit = true
	}
	else
	{
		hit = FindConstructorAndAddParameterTypes(structures.next, funcname, paramindex, paramcount, toplevel, types)
	}
}

FindConstructorAndAddParameterTypes : nothing, integer funcname, integer paramindex, integer paramcount, boolean toplevel, simplelist<integer> ref types -> false


FindMemberAndAddParameterTypes : list<StructureMember> ref members, integer paramindex, simplelist<integer> ref types [nogc]
{
	if(paramindex == 0)
	{
		AddParameterTypesForMember(members.value, types)
	}
	else
	{
		FindMemberAndAddParameterTypes(members.next, paramindex - 1, types)
	}
}

FindMemberAndAddParameterTypes : nothing, integer paramindex, simplelist<integer> ref types [nogc]
{
	print("Too many arguments to constructor")
	assert(false)
}


AddParameterTypesForMember : StructureMemberVariable ref memvar, simplelist<integer> ref types [nogc]
{
	simpleprepend<integer>(types, memvar.Type)
}

AddParameterTypesForMember : StructureMemberFunctionRef ref memfunc, simplelist<integer> ref types [nogc]
{
	simpleprepend<integer>(types, GetMemberTypeDecompose(memfunc))
}


GetConstructorName : list<StructureDefinition> ref structures, integer typeid -> integer name = 0 [nogc]
{
	if(structures.value.Type == typeid)
	{
		name = structures.value.ConstructorName
	}
	else
	{
		name = GetConstructorName(structures.next, typeid)
	}
}


StructureConstructorExists : list<StructureDefinition> ref structures, integer ctorname -> boolean exists = false [nogc]
{
	if(structures.value.ConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.CopyConstructorName == ctorname)
	{
		exists = true
	}
	elseif(structures.value.AnonConstructorName == ctorname)
	{
		exists = true
	}
	else
	{
		exists = StructureConstructorExists(structures.next, ctorname)
	}
}

StructureConstructorExists : nothing, integer ctorname -> false [nogc]


CoalesceMemberAccesses : list<ExpressionAtom> ref atoms, Scope ref scope
{
	while(SearchForMemberAccessStart(atoms, atoms.next, scope))
	{
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, list<ExpressionAtom> ref current, Scope ref scope -> boolean found = false
{
	if(IsMemberAccessOperator(current.value))
	{
		CoalesceMemberAccessTriplet(previous, current, current.next, scope)
		found = true
	}
	else
	{
		found = SearchForMemberAccessStart(current, current.next, scope)
	}
}

SearchForMemberAccessStart : list<ExpressionAtom> ref previous, nothing, Scope ref scope -> false


CoalesceMemberAccessTriplet : list<ExpressionAtom> ref lhs, list<ExpressionAtom> ref op, list<ExpressionAtom> ref rhs, Scope ref scope
{
	CoalesceMemberAccessAtoms(lhs, lhs.value, rhs.value, scope)
	lhs.next = rhs.next
}

CoalesceMemberAccessAtoms : list<ExpressionAtom> ref lhslist, ExpressionAtom ref lhs, ExpressionAtom ref rhs, Scope ref scope
{
	CoalesceMemberAccessAtomsUnwrapped(lhslist, lhs, rhs, scope)
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, IdentifierAtom ref lhs, IdentifierAtom ref rhs, Scope ref scope
{
	Variable var = 0, 0, 0, 0
	FindVariableDataInSingleScope(scope, lhs.Handle, var)

	if(var.Name == 0)
	{
		print("Member access is bogus!")
		print(GetPooledString(GlobalStrings, lhs.Handle))
		assert(false)
	}

	assert(var.VarType != 0)
	integer lhstypename = GetNameOfType(var.VarType)

	integer rhstype = GetStructureMemberType(lhstypename, rhs.Handle)
	if(rhstype == 0)
	{
		print(GetPooledString(GlobalStrings, rhs.Handle))
	}
	
	assert(rhstype != 0)
	integer rhstypename = GetNameOfType(rhstype)

	RefBinding lhsbinding = lhs.Handle, lhstypename, false, false
	RefBinding rhsbinding = rhs.Handle, rhstypename, false, false

	list<RefBinding> bindings = rhsbinding, nothing
	prepend<RefBinding>(bindings, lhsbinding)

	CompoundAtom compound = bindings, rhstype
	ExpressionAtom wrap = compound
	lhslist.value = wrap
}

CoalesceMemberAccessAtomsUnwrapped : list<ExpressionAtom> ref lhslist, CompoundAtom ref lhs, IdentifierAtom ref rhs, Scope ref scope
{
	assert(lhs.Type != 0)
	integer typename = GetNameOfType(lhs.Type)

	RefBinding temp = rhs.Handle, typename, false, false
	AppendBinding(lhs.Bindings, lhs.Bindings.next, temp)

	lhs.Type = GetStructureMemberType(typename, rhs.Handle)
}

AppendBinding : list<RefBinding> ref bindings, list<RefBinding> ref tail, RefBinding ref binding [nogc]
{
	AppendBinding(tail, tail.next, binding)
}

AppendBinding : list<RefBinding> ref bindings, nothing, RefBinding ref binding [nogc]
{
	list<RefBinding> newtail = binding, nothing
	bindings.next = newtail
}


FindOrCreateTypeMatcher : integer rawname, integer overloadnamehandle, FunctionDefinition ref func -> integer matcherhandle = 0
{
	if(!func.IsTemplate)
	{
		string matchername = func.RawNameString ; "@@typematcher"
		matcherhandle = PoolString(matchername)

		EnsureMatcherIsPending(overloadnamehandle, matcherhandle, func)
	}
}

EnsureMatcherIsPending : integer overloadname, integer matcher, FunctionDefinition ref func [nogc]
{
	boolean found = SearchBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloadname)
	if(found)
	{
		return()
	}

	PendingTypeMatcher m = overloadname, matcher, func
	prepend<PendingTypeMatcher>(PendingTypeMatchers, m)
	InsertIntoBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExist, overloadname, m)
	InsertIntoBinaryTree<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matcher, m)
}

GetPendingTypeMatcherReturnType : integer matchername, ContextNode<PendingTypeMatcher> ref outcontext -> integer rettype = 0
{
	boolean found = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matchername, outcontext)
	if(found)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = InferFunctionReturnType(outcontext)
		return()
	}

	rettype = GetPendingPatternMatcherReturnType(PendingPatternMatchers, matchername)
}


GetPendingPatternMatcherReturnType : list<PendingPatternMatcher> ref pending, integer matchername -> integer rettype = 0
{
	if(pending.value.MatcherName == matchername)
	{
		// TODO - ensure all overloads return the same type or this might get ugly!
		rettype = GetFunctionReturnType(Functions, pending.value.OverloadName)
		return()
	}

	rettype = GetPendingPatternMatcherReturnType(pending.next, matchername)
}

GetPendingPatternMatcherReturnType : nothing, integer matchername -> integer typeid = GetBuiltInReturnType(matchername)



GetBuiltInReturnType : integer builtinname -> integer returntype = 0
{
	if(StructureConstructorExists(Structures, builtinname))
	{
		returntype = GetStructureByAnonConstructorName(Structures, builtinname)
		return()
	}

	if(builtinname == PooledStringHandleForNarrowString)
	{
		returntype = 0x02000001		// buffer type signature
	}
	elseif(builtinname == PooledStringHandleForUnescape)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubstringWithLength)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubstringNoLength)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForSubchar)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastRealToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastBooleanToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastInteger16ToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastIntegerToInteger16)
	{
		returntype = 0x01000002		// integer16 type signature
	}
	elseif(builtinname == PooledStringHandleForCastIntegerToString)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCastRealToString)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCastStringToReal)
	{
		returntype = 0x01000004		// real type signature
	}
	elseif(builtinname == PooledStringHandleForCastStringToInteger)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCastBufferToString)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForLength)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineGet)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForWidenFromPtr)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForWidenFromBuffer)
	{
		returntype = 0x02000000		// string type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineGetCount)
	{
		returntype = 0x01000001		// integer type signature
	}
	elseif(builtinname == PooledStringHandleForCmdLineIsValid)
	{
		returntype = 0x01000003		// boolean type signature
	}
	elseif(builtinname == PooledStringHandleForSizeOf)
	{
		returntype = 0x01000001		// integer type signature
	}
}


FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, nothing


FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, ExpressionList ref paramexprs
{
	FindConstructorAndAnnotateTypeMatchedParams(Structures, funcname, paramexprs.Expressions)
}

FindConstructorAndAnnotateTypeMatchedParams : list<StructureDefinition> ref structures, integer funcname, list<Expression> ref paramexprs
{
	if(structures.value.ConstructorName == funcname)
	{
		listnode<Expression> ne = paramexprs.next
		AnnotateTypeMatchedParamsFromConstructor(structures.value.Members, ne)
	}
	else
	{
		FindConstructorAndAnnotateTypeMatchedParams(structures.next, funcname, paramexprs)
	}
}

FindConstructorAndAnnotateTypeMatchedParams : nothing, integer funcname, list<Expression> ref paramexprs
{
	if(SumTypeExists(funcname))
	{
		AnnotateNonReferenceParameters(paramexprs.next)
	}
}


AnnotateTypeMatchedParamsFromConstructor : list<StructureMember> ref members, list<Expression> ref paramexprs
{
	integer membertype = GetMemberTypeDecompose(members.value)
	if((membertype & 0x7f000000) == 0x07000000)
	{
		if(MakeNonReferenceType(paramexprs.value.Type) != MakeNonReferenceType(membertype))
		{
			AddTypeAnnotation(paramexprs.value)
		}
	}

	listnode<StructureMember> nm = members.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParamsFromConstructor(nm, ne)
}

AnnotateTypeMatchedParamsFromConstructor : nothing, nothing


AnnotateTypeMatchedParams : FunctionParams ref params, list<Expression> ref paramexprs
{
	AnnotateTypeMatchedParams(params.Params, paramexprs)
}

AnnotateTypeMatchedParams : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	if((params.value.ResolvedType & 0x7f000000) == 0x07000000)
	{
		AddTypeAnnotation(paramexprs.value)
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	AnnotateTypeMatchedParams(np, ne)
}

AnnotateTypeMatchedParams : nothing, nothing


MakeParametersReferencesUnwrapFast : FunctionDefinition ref function, integer overloadname, ExpressionList ref params
{
	WalkFunctionParamsAndSetReferences(function.Params, params)
}

MakeParametersReferencesForTypeMatcherFast : PendingTypeMatcher ref pending, integer matchername, ExpressionList ref params
{
	if(pending.MatcherName == matchername)
	{
		MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)
	}
}

MakeParametersReferencesUnwrap : PendingTypeMatcher ref pending, ExpressionList ref params
{
	MakeParametersReferencesUnwrapFast(pending.OverloadImplementation, pending.OverloadName, params)
}

MakeParametersReferencesForTypeMatcher : integer matchername, ExpressionList ref params
{
	ContextNode<PendingTypeMatcher> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<PendingTypeMatcher>(TypeMatchersWhichExistByMatcherName, matchername, wrap)
	if(found)
	{
		MakeParametersReferencesUnwrap(wrap, params)
	}
	else
	{
		MakeParametersReferencesForConstructor(Structures, matchername, params)
	}
}


MakeParametersReferencesForConstructor : list<StructureDefinition> ref structures, integer constructorname, ExpressionList ref params
{
	if(structures.value.ConstructorName == constructorname)
	{
		boolean ok = MakeParametersReferencesForStructureMembers(structures.value.Members, params.Expressions.next)
		if(!ok)
		{
			print("Failed to generate call to constructor " ; GetPooledString(GlobalStrings, constructorname))
			assert(false)
		}
	}
	else
	{
		MakeParametersReferencesForConstructor(structures.next, constructorname, params)
	}
}


MakeParametersReferencesForConstructor : nothing, integer constructorname, ExpressionList ref params
{
	MakeParametersReferencesForBuiltIn(constructorname, params)
}

MakeParametersReferencesForBuiltIn : integer funcname, ExpressionList ref params
{
	if(funcname == PooledStringHandleForWriteBuffer)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferString)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferMultiple)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForWriteBufferReal)
	{
		if(!MarkAtomAsReference(params.Expressions.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}
	elseif(funcname == PooledStringHandleForCastBufferToString)
	{
		MarkFirstAtomAsReference(params.Expressions.next)
	}
}


MarkFirstAtomAsReference : list<Expression> ref exprs
{
	if(!MarkAtomAsReference(exprs.value.Atoms.value))
	{
		print("WARNING: failed to bind reference")
	}	
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, list<Expression> ref params -> boolean ret = true
{
	if(IsMemberReferenceType(members.value))
	{
		if(!MarkAtomAsReference(params.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}

	ret = MakeParametersReferencesForStructureMembers(members.next, params.next)
}


MakeParametersReferencesForStructureMembers : list<StructureMember> ref members, nothing -> false
{
	if(GetMemberName(members.value) != 0)
	{
		print("Constructor has too few arguments!")
	}
}

MakeParametersReferencesForStructureMembers : nothing, list<Expression> ref params -> false
{
	print("Constructor has too many arguments!")
}

MakeParametersReferencesForStructureMembers : nothing, nothing -> true



IsMemberReferenceType : StructureMemberVariable ref memvar -> boolean isref = IsReferenceType(memvar.Type) [nogc]
IsMemberReferenceType : StructureMemberFunctionRef ref memfunc -> false [nogc]


WalkFunctionParamsAndSetReferencesShim : FunctionDefinition ref func, OptionalExpressionList ref optexprs
{
	WalkFunctionParamsAndSetReferences(func.Params, optexprs)
}

WalkFunctionParamsAndSetReferences : nothing, ExpressionList ref paramexprs

WalkFunctionParamsAndSetReferences : FunctionParams ref params, ExpressionList ref paramexprs
{
	WalkFunctionParamsAndSetReferencesUnwrapped(params.Params, paramexprs.Expressions)
}


WalkFunctionParamsAndSetReferencesUnwrapped : list<UnresolvedParameter> ref params, list<Expression> ref paramexprs
{
	boolean needref = false
	if(IsReferenceType(params.value.ResolvedType))
	{
		needref = true
	}
	elseif(params.value.ResolvedType == 0x00000004)			// TODO - don't assume "nothing" is always passed by ref
	{
		needref = true
	}

	if(needref)
	{
		if(!MarkAtomAsReference(paramexprs.value.Atoms.value))
		{
			print("WARNING: failed to bind reference")
		}
	}

	listnode<UnresolvedParameter> np = params.next
	listnode<Expression> ne = paramexprs.next
	WalkFunctionParamsAndSetReferencesUnwrapped(np, ne)
}

WalkFunctionParamsAndSetReferencesUnwrapped : nothing, nothing


DemoteAtomType : list<ExpressionAtom> ref atoms [nogc]
{
	PerformDemotion(atoms, atoms.value)
}

PerformDemotion : list<ExpressionAtom> ref atoms, integer ref atom [nogc]
{
	integer16 newatom = cast(integer16, atom)
	ExpressionAtom wrap = newatom
	atoms.value = wrap
}

PerformDemotion : list<ExpressionAtom> ref atoms, IdentifierAtom ref atom [nogc]

PerformDemotion : list<ExpressionAtom> ref atoms, Statement ref atom [nogc]
{
	assertmsg(atom.Type == 0x01000002, "Failed to demote statement type")
}

PerformDemotion : list<ExpressionAtom> ref atoms, CompoundAtom ref atom [nogc]


DumpOverloadList : list<InferencePossibility> ref possibilities
{
	if(possibilities.value.FunctionName != 0)
	{
		print(GetPooledString(GlobalStrings, possibilities.value.FunctionName))
	}

	DumpOverloadList(possibilities.next)
}

DumpOverloadList : nothing



FilterOverloadsForTypeDemotion : list<InferencePossibility> ref in, list<InferencePossibility> ref out
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedOverloads(in, hasdemoted, hassuperior, hasother)

	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedOverloads(in, out)
	}
	else
	{
		out = in
	}
}


FilterTypesForDemotion : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	boolean hasdemoted = false
	boolean hassuperior = false
	boolean hasother = false

	CheckIfContainsOnlyDemotedTypes(in, hasdemoted, hassuperior, hasother)

	if(hasdemoted && hassuperior && (!hasother))
	{
		StripDemotedTypes(in, out)
	}
	else
	{
		out = in
	}
}


CheckIfContainsOnlyDemotedOverloads : list<InferencePossibility> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value == 0x01000001)
		{
			hassuperior = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0x01000002)
		{
			hasdemoted = true
		}
		elseif(in.value.ParameterTypes.value.Types.value == 0)
		{
		}
		else
		{
			hasother = true
		}
	}

	CheckIfContainsOnlyDemotedOverloads(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedOverloads : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedOverloads : list<InferencePossibility> ref in, list<InferencePossibility> ref out [nogc]
{
	if(in.value.FunctionName != 0)
	{
		if(in.value.ParameterTypes.value.Types.value != 0x01000002)
		{
			prepend<InferencePossibility>(out, in.value)
		}
	}

	StripDemotedOverloads(in.next, out)
}

StripDemotedOverloads : nothing, list<InferencePossibility> ref out [nogc]



CheckIfContainsOnlyDemotedTypes : simplelist<integer> ref in, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]
{
	if(in.value == 0x01000001)
	{
		hassuperior = true
	}
	elseif(in.value == 0x01000002)
	{
		hasdemoted = true
	}
	elseif(in.value == 0)
	{
	}
	else
	{
		hasother = true
	}

	CheckIfContainsOnlyDemotedTypes(in.next, hasdemoted, hassuperior, hasother)
}

CheckIfContainsOnlyDemotedTypes : nothing, boolean ref hasdemoted, boolean ref hassuperior, boolean ref hasother [nogc]


StripDemotedTypes : simplelist<integer> ref in, simplelist<integer> ref out [nogc]
{
	if(in.value != 0)
	{
		if(in.value != 0x01000002)
		{
			simpleprepend<integer>(out, in.value)
		}
	}

	StripDemotedTypes(in.next, out)
}

StripDemotedTypes : nothing, simplelist<integer> ref out [nogc]


InitBuiltInOverloads : [nogc]
{
	Overload buffercopy = PooledStringHandleForBuffer, PooledStringHandleForBufferCopy, nothing
	prepend<Overload>(AutoGenOverloads, buffercopy)

	Overload substrlength = PooledStringHandleForSubstring, PooledStringHandleForSubstringWithLength, nothing
	prepend<Overload>(AutoGenOverloads, substrlength)

	Overload substrnolen = PooledStringHandleForSubstring, PooledStringHandleForSubstringNoLength, nothing
	prepend<Overload>(AutoGenOverloads, substrnolen)

	Overload castrealtoint = PooledStringHandleForCast, PooledStringHandleForCastRealToInteger, nothing
	prepend<Overload>(AutoGenOverloads, castrealtoint)

	Overload castinttostr = PooledStringHandleForCast, PooledStringHandleForCastIntegerToString, nothing
	prepend<Overload>(AutoGenOverloads, castinttostr)

	Overload caststrtoint = PooledStringHandleForCast, PoolString("cast@@string_to_integer"), nothing
	prepend<Overload>(AutoGenOverloads, caststrtoint)

	Overload castrealtostr = PooledStringHandleForCast, PooledStringHandleForCastRealToString, nothing
	prepend<Overload>(AutoGenOverloads, castrealtostr)

	Overload castbooltoint = PooledStringHandleForCast, PooledStringHandleForCastBooleanToInteger, nothing
	prepend<Overload>(AutoGenOverloads, castbooltoint)

	Overload castint16toint = PooledStringHandleForCast, PoolString("cast@@integer16_to_integer"), nothing
	prepend<Overload>(AutoGenOverloads, castint16toint)

	Overload castinttoint16 = PooledStringHandleForCast, PoolString("cast@@integer_to_integer16"), nothing
	prepend<Overload>(AutoGenOverloads, castinttoint16)

	Overload caststrtoreal = PooledStringHandleForCast, PooledStringHandleForCastStringToReal, nothing
	prepend<Overload>(AutoGenOverloads, caststrtoreal)
	
	Overload castbuffertostr = PooledStringHandleForCast, PooledStringHandleForCastBufferToString, nothing
	prepend<Overload>(AutoGenOverloads, castbuffertostr)

	Overload writebuffernormal = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBuffer, nothing
	prepend<Overload>(AutoGenOverloads, writebuffernormal)

	Overload writebuffermultiple = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferMultiple, nothing
	prepend<Overload>(AutoGenOverloads, writebuffermultiple)

	Overload writebufferstring = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferString, nothing
	prepend<Overload>(AutoGenOverloads, writebufferstring)

	Overload writebufferreal = PooledStringHandleForWriteBuffer, PooledStringHandleForWriteBufferReal, nothing
	prepend<Overload>(AutoGenOverloads, writebufferreal)
}



CheckMemberTypes : list<StructureMember> ref members, simplelist<integer> ref types -> boolean match = true
{
	integer membertype = MakeNonReferenceType(GetMemberTypeDecompose(members.value))
	integer curtype = MakeNonReferenceType(types.value)

	if(membertype == curtype)
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	elseif(SumTypeHasBase(SumTypes, membertype, curtype))
	{
		match = CheckMemberTypes(members.next, types.next)
	}
	else
	{
		match = false
	}
}

CheckMemberTypes : nothing, nothing -> true

CheckMemberTypes : list<StructureMember> ref members, nothing -> false

CheckMemberTypes : nothing, simplelist<integer> ref types -> boolean match = false
{
	if(types.value == 0)
	{
		match = true
	}
}


GetStructureByAnonConstructorName : nothing, integer name -> 0 [nogc]

GetStructureByAnonConstructorName : list<StructureDefinition> ref structures, integer name -> integer typeid = 0 [nogc]
{
	if(structures.value.AnonConstructorName == name)
	{
		typeid = structures.value.Type
	}
	else
	{
		typeid = GetStructureByAnonConstructorName(structures.next, name)
	}
}


stringcontains : string haystack, string needle -> boolean contains = false [nogc]
{
	integer needlelen = length(needle)
	integer haystacklen = length(haystack)

	integer index = 0
	while(index < (haystacklen - needlelen))
	{
		if(substring(haystack, index, needlelen) == needle)
		{
			contains = true
			return()
		}

		++index
	}
}


PrependFunctionParameter : list<FunctionDefinition> ref functions, integer funcname, integer paramname, integer paramtype
{
	if(functions.value.Name == funcname)
	{
		assert(paramtype != 0)
		UnresolvedParameter p = paramname, GetNameOfType(paramtype), paramtype, IsReferenceType(paramtype), nothing, nothing
		PrependUnresolvedParameter(functions.value.Params, p)
	}
	else
	{
		PrependFunctionParameter(functions.next, funcname, paramname, paramtype)
	}
}

PrependUnresolvedParameter : FunctionParams ref params, UnresolvedParameter ref p
{
	PrependUnresolvedParameter(params.Params, p)
}

PrependUnresolvedParameter : list<UnresolvedParameter> ref thelist, UnresolvedParameter ref p
{
	prepend<UnresolvedParameter>(thelist, p)
}

PrependUnresolvedParameter : nothing, UnresolvedParameter ref p
{
	print("Cannot set constructor tag on function with no parameters")
	assert(false)
}


GetSignatureReturnType : list<FunctionSignature> ref signatures, integer functype -> integer rettype = 0
{
	if(signatures.value.Name == functype)		// stupid overload of "name" to also mean "type"
	{
		rettype = GetTypeByName(signatures.value.ReturnTypeName)
	}
	else
	{
		rettype = GetSignatureReturnType(signatures.next, functype)
	}
}


FindOrCreateFunctionSignatureType : FunctionSignature ref signature -> integer typeid = 0
{
	typeid = FindMatchingSignature(FunctionSignatures, signature)
	if(typeid == 0)
	{
		FunctionSignature newsig = signature
		newsig.Name = (++GlobalFunctionTypeCounter)
		prepend<FunctionSignature>(FunctionSignatures, newsig)

		typeid = newsig.Name
	}
}

FindOrCreateFunctionSignatureType : simplelist<integer> ref paramtypenames, integer returntypename -> integer typeid = 0
{
	typeid = FindFunctionSignatureType(FunctionSignatures, paramtypenames, returntypename)
	if(typeid == 0)
	{
		OnCodeGenRegisterFunctionSig((++GlobalFunctionTypeCounter), returntypename)
		OnCodeGenRegisterFunctionSigParamList(paramtypenames)

		typeid = GlobalFunctionTypeCounter
	}
}

FindFunctionSignatureType : list<FunctionSignature> ref signatures, simplelist<integer> ref paramtypes, integer returntypename -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == returntypename)
	{
		if(SignatureMatchesParams(signatures.value.Parameters, paramtypes))
		{
			typeid = signatures.value.Name
			return()
		}
	}

	typeid = FindFunctionSignatureType(signatures.next, paramtypes, returntypename)
}

FindFunctionSignatureType : nothing, simplelist<integer> ref paramtypes, integer returntypename -> 0


SignatureMatchesParams : list<Parameter> ref params, simplelist<integer> ref paramtypes -> boolean match = true
{
	if(params.value.Name == 0)
	{
		match = SignatureMatchesParams(params.next, paramtypes)
	}
	elseif(paramtypes.value == 0)
	{
		match = SignatureMatchesParams(params, paramtypes.next)
	}
	elseif(params.value.Type != GetTypeByName(paramtypes.value))
	{
		match = false
	}
	else
	{
		match = SignatureMatchesParams(params.next, paramtypes.next)
	}
}

SignatureMatchesParams : nothing, simplelist<integer> ref paramtypes -> (paramtypes.value == 0)
SignatureMatchesParams : list<Parameter> ref params, nothing -> (params.value.Name == 0)

SignatureMatchesParams : nothing, nothing -> true


FindFunctionAndGetSignatureType : list<FunctionDefinition> ref functions, integer funcname -> integer typeid = 0
{
	if(functions.value.Name == funcname)
	{
		if(!functions.value.InferenceDone)
		{
			TypeInference(functions.value, DummyContextForFunctions)
		}
	
		simplelist<integer> paramtypes = 0, nothing
		GetFunctionParameterTypes(functions.value.Params, paramtypes)

		integer rettypename = 0
		integer rettype = InferFunctionReturnType(functions.value)
		if(rettype != 0)
		{
			rettypename = GetNameOfType(rettype)
		}
		typeid = FindOrCreateFunctionSignatureType(paramtypes, rettypename)
	}
	else
	{
		typeid = FindFunctionAndGetSignatureType(functions.next, funcname)
	}
}


GetFunctionParameterTypes : FunctionParams ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.Params, outtypenames)
}

GetFunctionParameterTypes : list<UnresolvedParameter> ref params, simplelist<integer> ref outtypenames
{
	GetFunctionParameterTypes(params.next, outtypenames)

	if(params.value.ResolvedType == 0)
	{
		print("Internal error: function parameter has unresolved type")
		print(GetPooledString(GlobalStrings, params.value.NameHandle))
		print(GetPooledString(GlobalStrings, params.value.TypeNameHandle))
		assert(false)
	}

	simpleprepend<integer>(outtypenames, GetNameOfType(params.value.ResolvedType))
}

GetFunctionParameterTypes : nothing, simplelist<integer> ref outtypenames


FindMatchingSignature : list<FunctionSignature> ref signatures, FunctionSignature ref targetsig -> integer typeid = 0
{
	if(signatures.value.ReturnTypeName == targetsig.ReturnTypeName)
	{
		if(SignaturesMatch(signatures.value.Parameters, targetsig.Parameters))
		{
			typeid = signatures.value.Name
			return()
		}
	}

	typeid = FindMatchingSignature(signatures.next, targetsig)
}

FindMatchingSignature : nothing, FunctionSignature ref targetsig -> 0


SignaturesMatch : list<Parameter> ref a, list<Parameter> ref b -> boolean match = true
{
	if(a.value.Type != b.value.Type)
	{
		match = false
	}
	else
	{
		match = SignaturesMatch(a.next, b.next)
	}
}

SignaturesMatch : nothing, list<Parameter> ref b -> (b.value.Name == 0)
SignaturesMatch : list<Parameter> ref a, nothing -> (a.value.Name == 0)

SignaturesMatch : nothing, nothing -> true


DumpSignature : FunctionSignature ref sig
{
	print("  Function signature")
	DumpSignatureParams(sig.Parameters)
	print("  ->")
	if(sig.ReturnTypeName != 0)
	{
		print(GetPooledString(GlobalStrings, sig.ReturnTypeName))
	}
}

DumpSignatureParams : list<Parameter> ref params
{
	if(params.value.Type != 0)
	{
		print(GetPooledString(GlobalStrings, GetNameOfType(params.value.Type)))
	}
	DumpSignatureParams(params.next)
}

DumpSignatureParams : nothing



ResolveSignatureTypes : FunctionSignature ref signature
{
	ResolveSignatureTypes(signature.Parameters)
}

ResolveSignatureTypes : list<Parameter> ref params
{
	params.value.Type = GetTypeByName(params.value.Type)
	ResolveSignatureTypes(params.next)
}

ResolveSignatureTypes : nothing



FindBuiltinAndGetSignatureType : integer builtinname -> integer typeid = 0
{
	if(builtinname == PooledStringHandleForPassTest)
	{
		simplelist<integer> paramtypes = 0, nothing
		typeid = FindOrCreateFunctionSignatureType(paramtypes, 0)
	}
}


FindPrePostOperatorOverload : integer operatorname, integer operandtype -> integer overloadname = 0 [nogc]
{
	if(operatorname == PooledStringHandleForPrePostIncrement)
	{
		if(operandtype == 0x01000001)
		{
			overloadname = PooledStringHandleForPrePostIncrementInteger
		}
	}
	elseif(operatorname == PooledStringHandleForPrePostDecrement)
	{
		if(operandtype == 0x01000001)
		{
			overloadname = PooledStringHandleForPrePostDecrementInteger
		}
	}
}

FindAssignmentOperator : integer operatorname, integer lhstype, integer rhstype -> integer overloadname = operatorname [nogc]
{
	lhstype = MakeNonReferenceType(lhstype)
	rhstype = MakeNonReferenceType(rhstype)

	if(operatorname == PooledStringHandleForIncrementAssign)
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = PooledStringHandleForIncrementAssignInteger
		}
	}
	elseif(operatorname == PooledStringHandleForDecrementAssign)
	{
		if((lhstype == 0x01000001) && (rhstype == 0x01000001))
		{
			overloadname = PooledStringHandleForDecrementAssignInteger
		}
	}
}


SetFunctionReturnType : FunctionDefinition ref func, integer funcname, integer rettype [nogc]
{
	SetOptionalExpressionType(func.Return, rettype)
}


SetOptionalExpressionType : Expression ref expr, integer typeid [nogc]
{
	expr.Type = typeid
}



CheckForNeededPatternMatcher : list<PendingPatternMatcher> ref patternmatchers, integer rawname -> integer matchername = 0 [nogc]
{
	if(patternmatchers.value.RawName == rawname)
	{
		matchername = patternmatchers.value.MatcherName
	}
	else
	{
		matchername = CheckForNeededPatternMatcher(patternmatchers.next, rawname)
	}
}

CheckForNeededPatternMatcher : nothing, integer rawname -> 0 [nogc]


EnsurePatternMatcherExists : list<PendingPatternMatcher> ref patternmatchers, integer rawname, integer mangledname
{
	if(patternmatchers.value.OverloadName == mangledname)
	{
		return()
	}

	EnsurePatternMatcherExists(patternmatchers.next, rawname, mangledname)
}

EnsurePatternMatcherExists : nothing, integer rawname, integer mangledname
{
	PendingPatternMatcher pm = rawname, mangledname, PoolStringFast(GetPooledString(GlobalStrings, rawname) ; "@@patternmatch")
	prepend<PendingPatternMatcher>(PendingPatternMatchers, pm)
}



CodeGenEmitPatternMatchers : list<PendingPatternMatcher> ref matchers
{
	if(!listcontains(EmittedPatternMatchers, matchers.value.MatcherName))
	{
		OnBytecodeEmitByte(0x11)			// DefineLexicalScope instruction
		OnBytecodeEmitInteger(matchers.value.MatcherName)
		OnBytecodeEmitInteger(0)
		OnBytecodeEmitInteger(0)

		OnBytecodeEnterPatternResolver(matchers.value.MatcherName)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, true)
		EmitOverloadsForPatternMatcher(PendingPatternMatchers, matchers.value.MatcherName, false)
		OnBytecodeExitPatternResolver()

		simpleprepend<integer>(EmittedPatternMatchers, matchers.value.MatcherName)
	}

	CodeGenEmitPatternMatchers(matchers.next)
}

CodeGenEmitPatternMatchers : nothing


EmitOverloadsForPatternMatcher : list<PendingPatternMatcher> ref matchers, integer matchername, boolean preferliterals
{
	if(matchername == matchers.value.MatcherName)
	{
		// TODO - filter down to matchers that fit the most general function pattern

		EmitPatternMatchOverload(Functions, matchers.value.OverloadName, preferliterals)
	}

	EmitOverloadsForPatternMatcher(matchers.next, matchername, preferliterals)
}

EmitOverloadsForPatternMatcher : nothing, integer matchername, boolean preferliterals



EmitPatternMatchOverload : list<FunctionDefinition> ref functions, integer overloadname, boolean preferliterals
{
	if(functions.value.Name == overloadname)
	{
		boolean hasliterals = FunctionSignatureHasLiterals(functions.value.Params)
		if(hasliterals && preferliterals)
		{
			EmitPatternMatchingForFunction(functions.value)
		}
		elseif((!hasliterals) && (!preferliterals))
		{
			EmitPatternMatchingForFunction(functions.value)
		}
	}
	else
	{
		EmitPatternMatchOverload(functions.next, overloadname, preferliterals)
	}
}


FunctionSignatureHasLiterals : FunctionParams ref params -> boolean hasliterals = FunctionSignatureHasLiterals(params.Params) [nogc]

FunctionSignatureHasLiterals : list<UnresolvedParameter> ref params -> boolean hasliterals = false [nogc]
{
	integer exprtype = GetOptionalExpressionType(params.value.PatternMatchValue)
	if((exprtype != 0) && (exprtype != 0x00000002))
	{
		hasliterals = true
		return()
	}

	if(FunctionSignatureHasLiterals(params.next))
	{
		hasliterals = true
	}
}

FunctionSignatureHasLiterals : nothing -> false [nogc]



EmitPatternMatchingForFunction : FunctionDefinition ref function
{
	OnBytecodeEmitByte(0x12)			// PatternMatch instruction
	OnBytecodeEmitInteger(function.Name)
	OnBytecodeEmitInteger(0)
	OnBytecodeEmitInteger(CountUnresolvedParameters(function.Params))
	EmitPatternMatchingForParameters(function.Params)
}

EmitPatternMatchingForParameters : FunctionParams ref params
{
	EmitPatternMatchingForParameters(params.Params)
}

EmitPatternMatchingForParameters : list<UnresolvedParameter> ref params
{
	integer parampatterntype = GetOptionalExpressionType(params.value.PatternMatchValue)
	OnBytecodeEmitInteger(MakeNonReferenceType(parampatterntype))

	if(parampatterntype != 0)
	{
		OnBytecodeEmitBoolean(true)
		EmitPatternMatchLiteral(params.value.PatternMatchValue)
	}
	else
	{
		OnBytecodeEmitBoolean(false)
	}

	EmitPatternMatchingForParameters(params.next)
}

EmitPatternMatchingForParameters : nothing


EmitPatternMatchLiteral : Expression ref expr
{
	EmitPatternMatchLiteralAtom(expr.Atoms.value)
}

EmitPatternMatchLiteralAtom : integer value
{
	OnBytecodeEmitInteger(value)
}


PatternMatcherExists : nothing, integer matchername -> false

PatternMatcherExists : list<PendingPatternMatcher> ref matchers, integer matchername -> boolean exists = false
{
	if(matchers.value.MatcherName == matchername)
	{
		exists = true
	}
	else
	{
		exists = PatternMatcherExists(matchers.next, matchername)
	}
}



GetCastOverload : nothing -> 0

GetCastOverload : ExpressionList ref params -> integer overloadname = FigureOutCastOverload(params.Expressions)


FigureOutCastOverload : list<Expression> ref params -> integer overloadname = 0
{
	integer idtype = GetTypeByName(GetIdentifier(params.value.Atoms.value))
	if(idtype != 0)
	{
		integer origintype = FigureOutCastOriginType(params.next)

		if((idtype == 0x01000001) && (origintype == 0x01000004))
		{
			overloadname = PooledStringHandleForCastRealToInteger
		}
		elseif((idtype == 0x02000000) && (origintype == 0x01000001))
		{
			overloadname = PooledStringHandleForCastIntegerToString
		}
		elseif((idtype == 0x02000000) && (origintype == 0x01000004))
		{
			overloadname = PooledStringHandleForCastRealToString
		}
		elseif((idtype == 0x01000001) && (origintype == 0x01000002))
		{
			overloadname = PooledStringHandleForCastInteger16ToInteger
		}
		elseif((idtype == 0x01000002) && (origintype == 0x01000001))
		{
			overloadname = PooledStringHandleForCastIntegerToInteger16
		}
		elseif((idtype == 0x01000001) && (origintype == 0x01000003))
		{
			overloadname = PooledStringHandleForCastBooleanToInteger
		}
		elseif((idtype == 0x01000004) && (origintype == 0x02000000))
		{
			overloadname = PooledStringHandleForCastStringToReal
		}
		elseif((idtype == 0x01000001) && (origintype == 0x02000000))
		{
			overloadname = PooledStringHandleForCastStringToInteger
		}
		elseif((idtype == 0x02000000) && (origintype == 0x82000001))
		{
			overloadname = PooledStringHandleForCastBufferToString
		}
	}
}

FigureOutCastOverload : nothing -> 0



FigureOutCastOriginType : list<Expression> ref params -> integer origintype = params.value.Type [nogc]

FigureOutCastOriginType : nothing -> 0 [nogc]


GetIdentifier : IdentifierAtom ref atom -> atom.Handle [nogc]



IRRegisterTemplateParameter : integer paramtype, integer paramname [nogc]
{
	TemplateParameter p = paramname, paramtype
	prepend<TemplateParameter>(TemplateParameterQueue, p)
}


CreateFunctionTemplateAndAttachParams : integer funcname, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateFunction templfunc = funcname, dummyparams
	prepend<TemplateFunction>(TemplateFunctions, templfunc)
}


CreateStructureTemplateAndAttachParams : integer structurename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateStructure templstructure = structurename, dummyparams
	prepend<TemplateStructure>(TemplateStructures, templstructure)
}


CreateSumTypeTemplateAndAttachParams : integer typename, list<TemplateParameter> ref paramqueue
{
	list<TemplateParameter> dummyparams = scratchtemplateparam, nothing
	TransferTemplateParamsFromQueue(dummyparams, paramqueue)

	TemplateSumType templtype = typename, dummyparams
	prepend<TemplateSumType>(TemplateSumTypes, templtype)
}



TransferTemplateParamsFromQueue : list<TemplateParameter> ref out, list<TemplateParameter> ref queue
{
	if(queue.value.ParamType != 0)
	{
		TransferTemplateParamsFromQueue(out, queue.next)

		if(out.value.ParamType == 0)
		{
			out.value = queue.value
		}
		else
		{
			prepend<TemplateParameter>(out, queue.value)
		}
	}
}



PopTemplateArgStack : list<TemplateArgumentList> ref stack, list<TemplateArgumentList> ref next [nogc]
{
	stack = next
}

PopTemplateArgList : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail [nogc]
{
	thelist = tail
}


AppendTemplateArgument : list<TemplateArgument> ref thelist, TemplateArgument ref arg [nogc]
{
	AppendTemplateArgumentRecurse(thelist, thelist.next, arg)
}


AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, nothing, TemplateArgument ref arg [nogc]
{
	list<TemplateArgument> newlist = arg, nothing
	thelist.next = newlist
}

AppendTemplateArgumentRecurse : list<TemplateArgument> ref thelist, list<TemplateArgument> ref tail, TemplateArgument ref arg [nogc]
{
	AppendTemplateArgumentRecurse(tail, tail.next, arg)
}


InstantiateTemplateFast : integer templatename, nothing -> templatename

InstantiateTemplateFast : integer templatename, TemplateArgumentList ref args -> integer instancename = templatename
{
	integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, templatename, args.Args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	existing = FindExistingTemplateInstance(TemplateStructureInstances, templatename, args.Args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	instancename = InstantiateFunctionTemplate(templatename, args)
}



InstantiateFunctionTemplate : integer templatename, nothing -> templatename

InstantiateFunctionTemplate : integer templatename, TemplateArgumentList ref args -> integer instancename = templatename
{
	instancename = FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, templatename, args.Args)

	ContextNode<FunctionDefinition> wrap = nothing
	while(PopPendingFunctionForInference(wrap))
	{
		TypeInference(wrap, DummyContextForFunctions)
	}
}


EnumerateOverloadsAndInstantiate : list<Overload> ref overloads, integer templatename, list<TemplateArgument> ref args
{
	if(overloads.value.NormalName == templatename)
	{
		integer existing = FindExistingTemplateInstance(TemplateFunctionInstances, overloads.value.MangledName, args)
		if(existing == 0)
		{
			FindFunctionTemplateAndInstantiate(TemplateFunctions, templatename, overloads.value.MangledName, args)
		}
	}

	EnumerateOverloadsAndInstantiate(overloads.next, templatename, args)
}

EnumerateOverloadsAndInstantiate : nothing, integer templatename, list<TemplateArgument> ref args


FindFunctionTemplateAndInstantiate : list<TemplateFunction> ref templates, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.FunctionDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = RegisterOverloadForFunction(mangledname, PoolString(mangledname))

		// TODO - validate that args suit the formal template parameters!

		string basenamemangled = MangleTemplateName(basename, args)
		integer bnmh = PoolString(basenamemangled)
		Overload overload = bnmh, instancename, nothing
		FindFunctionAndAddOverload(overload)

		DoFunctionInstantiation(bnmh, defname, instancename, templates.value.Parameters, args, overload)
	}
	else
	{
		instancename = FindFunctionTemplateAndInstantiate(templates.next, basename, defname, args)
	}
}

FindFunctionTemplateAndInstantiate : nothing, integer basename, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateStructureTemplateFast(defname, args)


FindStructureTemplateAndInstantiate : list<TemplateStructure> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.StructureDefName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)

		// TODO - validate that args suit the formal template parameters!

		DoStructureInstantiation(defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindStructureTemplateAndInstantiate(templates.next, defname, args)
	}
}

FindStructureTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = InstantiateSumType(defname, args)


InstantiateSumType : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateSumTypeInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	instancename = FindSumTypeTemplateAndInstantiate(TemplateSumTypes, defname, args)
}

FindSumTypeTemplateAndInstantiate : list<TemplateSumType> ref templates, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	if(templates.value.SumTypeName == defname)
	{
		string mangledname = MangleTemplateName(defname, args)
		instancename = PoolString(mangledname)

		// TODO - validate that args suit the formal template parameters!

		DoSumTypeInstantiation(defname, instancename, templates.value.Parameters, args)
	}
	else
	{
		instancename = FindSumTypeTemplateAndInstantiate(templates.next, defname, args)
	}
}


FindSumTypeTemplateAndInstantiate : nothing, integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer t = GetTypeByName(defname)
	if(t != 0)
	{
		instancename = defname
		return()
	}

	string namestr = GetPooledString(GlobalStrings, defname)
	print("Error - no template provided for '" ; namestr ; "', cannot create instance!")
}


DoStructureInstantiation : integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, defname, wrap)
	assertmsg(found, "Internal error: structure definition missing")

	StructInstInner(wrap, defname, instancename, params, args)
}

StructInstInner : StructureDefinition ref templstruct, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	assert(templstruct.IsTemplate)

	++GlobalTemplateInstanceCounter

	list<StructureMember> members = dummymember, nothing
	DoMemberListInstantiation(templstruct.Members, members, params, args)
	PopMember(members, members.next)

	StructureDefinition struct = instancename, GlobalTemplateInstanceCounter, 0, 0, 0, members, templstruct.MemberCount, GetPooledString(GlobalStrings, instancename), false
	prepend<StructureDefinition>(Structures, struct)
	InsertIntoBinaryTree<StructureDefinition>(StructuresWhichExist, instancename, struct)

	TemplateInstance instance = defname, instancename, args
	prepend<TemplateInstance>(TemplateStructureInstances, instance)

	TypeInference(Structures.value, DummyContextForFunctions)
}


DoSumTypeInstantiation : integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	ContextNode<SumType> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<SumType>(SumTypesWhichExist, defname, wrap)

	if(found)
	{
		STInst(wrap, instancename, params, args)
	}
}

STInst : SumType ref templst, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	assert(templst.IsTemplate)

	++GlobalSumTypeCounter

	list<SumTypeBase> bases = dummybasetype, nothing
	DoBaseTypeInstantiation(templst.Bases, bases, params, args)

	SumType st = instancename, GlobalSumTypeCounter, bases, false
	prepend<SumType>(SumTypes, st)
	InsertIntoBinaryTree<SumType>(SumTypesWhichExist, instancename, st)

	TemplateInstance instance = templst.Name, instancename, args
	prepend<TemplateInstance>(TemplateSumTypeInstances, instance)

	ResolveSumTypeBases(SumTypes.value.Bases)
}


PopMember : list<StructureMember> ref members, list<StructureMember> ref tail [nogc]
{
	members = tail
}

DoMemberListInstantiation : list<StructureMember> ref members, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	DoMemberInstantiation(members.value, out, params, args)
	DoMemberListInstantiation(members.next, out, params, args)
}

DoMemberListInstantiation : nothing, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args

DoMemberInstantiation : StructureMemberVariable ref memvar, list<StructureMember> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(memvar.Name != 0)
	{
		integer newtype = MapTemplateType(memvar.TypeNameHandle, params, args)

		StructureMemberVariable newmemvar = memvar.Name, 0, newtype, scratchtemplatearglist
		CopyTemplateArgs(memvar.TemplateArgs, newmemvar.TemplateArgs)
		RemapAllTemplateArguments(newmemvar.TemplateArgs, params, args)
		StructureMember newmember = newmemvar
		AppendStructureMember(out, out.next, newmember)
	}
}

CopyTemplateArgs : TemplateArgumentList ref in, TemplateArgumentList ref out [nogc]
{
	TemplateArgumentList copy = in
	out = copy
}

CopyTemplateArgs : nothing, TemplateArgumentList ref out [nogc]

DoBaseTypeInstantiation : list<SumTypeBase> ref bases, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	InstantiateBaseType(bases.value, out, params, args)
	DoBaseTypeInstantiation(bases.next, out, params, args)
}

DoBaseTypeInstantiation : nothing, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args


InstantiateBaseType : SumTypeBase ref in, list<SumTypeBase> ref out, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(in.Name != 0)
	{
		integer newtype = MapTemplateType(in.Name, params, args)

		SumTypeBase newbase = newtype, scratchtemplatearglist
		CopyTemplateArgs(in.TemplateArgs, newbase.TemplateArgs)
		RemapAllTemplateArguments(newbase.TemplateArgs, params, args)
		prepend<SumTypeBase>(out, newbase)
	}
}

RemapAllTemplateArguments : TemplateArgumentList ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	RemapAllTemplateArguments(toremap.Args, params, args)
}

RemapAllTemplateArguments : list<TemplateArgument> ref toremap, list<TemplateParameter> ref params, list<TemplateArgument> ref args
{
	if(toremap.value.ReplaceWith != 0)
	{
		toremap.value.ReplaceWith = MapTemplateType(toremap.value.ReplaceWith, params, args)
		toremap.value.ReplaceWithString = GetPooledString(GlobalStrings, toremap.value.ReplaceWith)
	}

	RemapAllTemplateArguments(toremap.next, params, args)
}

RemapAllTemplateArguments : nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args


DoFunctionInstantiation : integer basenamemangled, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args, Overload ref overload
{
	ContextNode<FunctionDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<FunctionDefinition>(FunctionsWhichExist, defname, wrap)
	assertmsg(found, "Internal error: function definition missing")

	FunctionInstantiationInner(wrap, basenamemangled, defname, instancename, params, args, overload)
	EnumerateOverloadsAndInstantiate(wrap, defname, args)
}

EnumerateOverloadsAndInstantiate : FunctionDefinition ref func, integer templatename, list<TemplateArgument> ref args
{
	EnumerateOverloadsAndInstantiate(func.Overloads, templatename, args)
}

FunctionInstantiationInner : FunctionDefinition ref originalfunc, integer basenamemangled, integer defname, integer instancename, list<TemplateParameter> ref params, list<TemplateArgument> ref args, Overload ref outoverload
{
	if(!originalfunc.IsTemplate)
	{
		print("Function is not template: " ; GetPooledString(GlobalStrings, defname))
		assert(false)
	}

	TemplateInstance inst = defname, instancename, args
	prepend<TemplateInstance>(TemplateFunctionInstances, inst)

	ContextWrapper<Scope> scopewrap = nothing
	FunctionDefinition func = basenamemangled, instancename, nothing, nothing, nothing, originalfunc.Overloads, scopewrap, GetPooledString(GlobalStrings, basenamemangled), 0, false, false, originalfunc.AnonymousReturn
	prepend<FunctionDefinition>(Functions, func)
	InsertIntoBinaryTree<FunctionDefinition>(FunctionsWhichExist, instancename, func)

	Overload selfoverload = instancename, instancename, func
	prepend<Overload>(func.Overloads, selfoverload)

	AttachContextToOverload(func.Overloads, instancename, func)
	outoverload.Implementation = func

	list<OptionalCodeBlock> newstack = nothing, nothing
	CurrentCodeBlockStack = newstack

	DoParameterInstantiation(originalfunc.Params, params, args)
	DoReturnInstantiation(originalfunc.Return, instancename, originalfunc.AnonymousReturn, params, args)

	// TODO - traverse template and instantiate the following stuff
	//ParseFunctionTags(namehandle, rawnamehandle)

	IREnterFunction(instancename)
	Functions.value.AttachedScope.Wrapped = Scopes.value
	OnCodeGenEnterFunctionBody(instancename)

	DoCodeBlockInstantiation(originalfunc.Code, params, args)

	IRExitFunction()

	PushPendingFunctionForInference(func)
}


DoParameterInstantiation : FunctionParams ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	DoParameterInstantiation(params.Params, templateparams, templateargs)
}

DoParameterInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoParameterInstantiation : list<UnresolvedParameter> ref params, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer newtype = MapTemplateType(params.value.TypeNameHandle, templateparams, templateargs)
	integer resolvedtype = params.value.ResolvedType

	if((resolvedtype & 0x7f000000) == 0x09000000)
	{
		resolvedtype = InstantiateFunctionSignature(FunctionSignatures, resolvedtype, templateparams, templateargs)
		newtype = GetNameOfType(resolvedtype)
	}

	UnresolvedParameter p = params.value.NameHandle, newtype, resolvedtype, params.value.HasRefTag, params.value.PatternMatchValue, nothing
	PropagateTemplateArgsForParameter(p, params.value.TemplateArgs, templateparams, templateargs)

	AppendUnresolvedParameterToFunction(Functions.value, Functions.value.Params, p)

	DoParameterInstantiation(params.next, templateparams, templateargs)
}

InstantiateFunctionSignature : list<FunctionSignature> ref sigs, integer targettype, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs -> integer ret = 0
{
	if(sigs.value.Name == targettype)
	{
		FunctionSignature clone = sigs.value
		clone.ReturnTypeName = MapTemplateType(clone.ReturnTypeName, templateparams, templateargs)
		RemapSignatureParamTypes(clone.Parameters, templateparams, templateargs)

		ret = FindOrCreateFunctionSignatureType(clone)
	}
	else
	{
		ret = InstantiateFunctionSignature(sigs.next, targettype, templateparams, templateargs)
	}
}

RemapSignatureParamTypes : list<Parameter> ref parameters, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	parameters.value.Type = GetTypeByName(MapTemplateType(parameters.value.Type, templateparams, templateargs))
	RemapSignatureParamTypes(parameters.next, templateparams, templateargs)
}

RemapSignatureParamTypes : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs


PropagateTemplateArgsForParameter : UnresolvedParameter ref p, TemplateArgumentList ref check, list<TemplateParameter> ref params, list<TemplateArgument> ref args [nogc]
{
	TemplateArgumentList wrap = args
	RemapAllTemplateArguments(wrap, params, args)
	p.TemplateArgs = wrap
}

PropagateTemplateArgsForParameter : UnresolvedParameter ref p, nothing, list<TemplateParameter> ref params, list<TemplateArgument> ref args [nogc]


DoReturnInstantiation : Expression ref retexpr, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterFunctionReturn(funcname, anonymous)
	InstantiateExpression(retexpr, true, templateparams, templateargs)
	OnCodeGenExitContext()
}

DoReturnInstantiation : nothing, integer funcname, boolean anonymous, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs


MapTemplateType : integer typenamehandle, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs -> integer newtypename = typenamehandle [nogc]
{
	if(templateparams.value.ParamName == typenamehandle)
	{
		newtypename = templateargs.value.ReplaceWith
	}
	else
	{
		newtypename = MapTemplateType(typenamehandle, templateparams.next, templateargs.next)
	}
}

MapTemplateType : integer typenamehandle, nothing, nothing -> typenamehandle [nogc]


MangleTemplateNameByHandle : integer defname, nothing -> integer mangled = defname [nogc]

MangleTemplateNameByHandle : integer defname, TemplateArgumentList ref args -> integer mangled = PoolString(MangleTemplateName(defname, args.Args)) [nogc]


MangleTemplateName : integer defname, list<TemplateArgument> ref args -> string mangled = GetPooledString(GlobalStrings, defname) ; "@@templateinst@" [nogc]
{
	mangled = mangled ; MangleTemplateArguments(args)
}

MangleTemplateArguments : list<TemplateArgument> ref args -> string mangled = args.value.ReplaceWithString [nogc]
{
	mangled = mangled ; MangleTemplateArguments(args.next)
}

MangleTemplateArguments : nothing -> "" [nogc]


InstantiateStructureTemplate : integer defname, TemplateArgumentList ref args -> integer instancename = InstantiateStructureTemplate(defname, args.Args)

InstantiateStructureTemplate : integer defname, nothing -> integer instancename = 0

InstantiateStructureTemplate : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	integer existing = FindExistingTemplateInstance(TemplateStructureInstances, defname, args)
	if(existing != 0)
	{
		instancename = existing
		return()
	}

	instancename = FindStructureTemplateAndInstantiate(TemplateStructures, defname, args)
}


InstantiateStructureTemplateFast : integer defname, TemplateArgumentList ref args -> integer instancename = InstantiateStructureTemplateFast(defname, args.Args)

InstantiateStructureTemplateFast : integer defname, nothing -> integer instancename = 0

InstantiateStructureTemplateFast : integer defname, list<TemplateArgument> ref args -> integer instancename = 0
{
	instancename = FindStructureTemplateAndInstantiate(TemplateStructures, defname, args)
}


FindExistingTemplateInstance : list<TemplateInstance> ref instances, integer defname, list<TemplateArgument> ref args -> integer instancename = 0 [nogc]
{
	if(instances.value.DefName == defname)
	{
		if(TemplateArgumentsMatch(instances.value.Arguments, args))
		{
			instancename = instances.value.InstanceName
			return()
		}
	}

	instancename = FindExistingTemplateInstance(instances.next, defname, args)
}

FindExistingTemplateInstance : nothing, integer defname, list<TemplateArgument> ref args -> 0 [nogc]



TemplateArgumentsMatch : list<TemplateArgument> ref a, list<TemplateArgument> ref b -> boolean match = true [nogc]
{
	if(a.value.ReplaceWith != b.value.ReplaceWith)
	{
		match = false
	}
	else
	{
		match = TemplateArgumentsMatch(a.next, b.next)
	}
}

TemplateArgumentsMatch : nothing, list<TemplateArgument> ref b -> false [nogc]
TemplateArgumentsMatch : list<TemplateArgument> ref a, nothing -> false [nogc]
TemplateArgumentsMatch : nothing, nothing -> true [nogc]



InstantiateExpression : Expression ref expr, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateAtoms(expr.Atoms, inret, templateparams, templateargs)
}

InstantiateExpression : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

InstantiateAtoms : list<ExpressionAtom> ref atoms, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateSingleAtom(atoms.value, inret, templateparams, templateargs)
	InstantiateAtoms(atoms.next, inret, templateparams, templateargs)
}

InstantiateAtoms : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support ALL atom types (parenthetical should be the only one left)
InstantiateSingleAtom : IdentifierAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterAtomIdentifier(atom.Handle, 0)
}

InstantiateSingleAtom : OperatorInvokeAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterOperatorInvoke(atom.OperatorName)
}

InstantiateSingleAtom : Statement ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	integer statementname = MapTemplateType(atom.Name, templateparams, templateargs)

	OnCodeGenEnterSubStatement()
	InstantiateStatement(statementname, inret, atom.TemplateArgs, templateparams, templateargs)

	InstantiateExpressionList(atom.Parameters, false, templateparams, templateargs, 0)

	IRExitStatement()
	IRExitStatement()
}


InstantiateSingleAtom : AtomSentinel ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

InstantiateSingleAtom : boolean ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralBoolean(atom)
}

InstantiateSingleAtom : StringHandleAtom ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralString(atom.Handle)
}

InstantiateSingleAtom : integer ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralInteger(atom, 0x01000001)
}

InstantiateSingleAtom : integer16 ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralInteger(cast(integer, atom), 0x01000002)
}

InstantiateSingleAtom : real ref atom, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenRegisterLiteralReal(atom)
}


InstantiateStatement : integer statementname, boolean inret, nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterStatement(statementname, 0, inret, false)
}

InstantiateStatement : integer statementname, boolean inret, TemplateArgumentList ref args, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	Statement statement = statementname, nothing, 0, args, inret, false
	PropagateTemplateArgsForStatement(statement, args, templateargs)
	RemapAllTemplateArguments(statement.TemplateArgs, templateparams, templateargs)
	OnCodeGenEmplaceStatement(statement)
}

PropagateTemplateArgsForStatement : Statement ref s, TemplateArgumentList ref check, list<TemplateArgument> ref args
{
	TemplateArgumentList wrap = args
	s.TemplateArgs = wrap
}

PropagateTemplateArgsForStatement : Statement ref s, nothing, list<TemplateArgument> ref args


InstantiateExpressionList : ExpressionList ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	InstantiateExpressionList(exprs.Expressions, inret, templateparams, templateargs, count)
}

InstantiateExpressionList : list<Expression> ref exprs, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count
{
	if(count != 0)
	{
		OnCodeGenShiftParameter()
	}

	InstantiateExpression(exprs.value, inret, templateparams, templateargs)
	InstantiateExpressionList(exprs.next, inret, templateparams, templateargs, count + 1)
}

InstantiateExpressionList : nothing, boolean inret, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs, integer count


DoCodeBlockInstantiation : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs

DoCodeBlockInstantiation : CodeBlock ref code, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntries(code.Entries, templateparams, templateargs)
}

InstantiateCodeBlockEntries : list<CodeBlockEntry> ref entries, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateCodeBlockEntry(entries.value, templateparams, templateargs)
	InstantiateCodeBlockEntries(entries.next, templateparams, templateargs)
}

InstantiateCodeBlockEntries : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs



// TODO - support all code block entry types
InstantiateCodeBlockEntry : Statement ref s, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateStatement(s.Name, true, s.TemplateArgs, templateparams, templateargs)
	InstantiateExpressionList(s.Parameters, false, templateparams, templateargs, 0)

	IRExitStatement()
}

InstantiateCodeBlockEntry : Assignment ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support

	OnCodeGenEnterAssignment(a.Operator, a.LHSName, 0, 0)
	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCodeBlockEntry : AssignmentCompound ref a, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	// TODO - chained assignment support

	OnCodeGenEnterAssignmentCompound(a.Operator, a.LHS.value, 0, 0)
	InstantiateCompoundAssignmentLHS(a.LHS.next)
	OnCodeGenAssignmentCompoundEnd()

	InstantiateExpression(a.RHS, false, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateCompoundAssignmentLHS : simplelist<integer> ref lhs
{
	FindCurrentFunctionAndAppendCompoundMember(lhs.value)
	InstantiateCompoundAssignmentLHS(lhs.next)
}

InstantiateCompoundAssignmentLHS : nothing


InstantiateCodeBlockEntry : EntityChain ref chain, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterChain()
	InstantiateEntityChainEntries(chain.Entries, templateparams, templateargs)
	OnCodeGenExitContext()
}

InstantiateEntityChainEntries : EntityList ref entities, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	InstantiateEntityChainEntries(entities.ActualList, templateparams, templateargs)
}

InstantiateEntityChainEntries : list<Entity> ref entities, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs
{
	OnCodeGenEnterEntity(entities.value.Tag, entities.value.PostfixTag)
	InstantiateExpression(entities.value.Param, false, templateparams, templateargs)
	OnCodeGenEnterEntityCode()
	DoCodeBlockInstantiation(entities.value.Code, templateparams, templateargs)
	OnCodeGenExitContext()
	OnCodeGenExitContext()

	InstantiateEntityChainEntries(entities.next, templateparams, templateargs)
}

InstantiateEntityChainEntries : nothing, list<TemplateParameter> ref templateparams, list<TemplateArgument> ref templateargs




SetStructureToTemplate : integer name
{
	ContextNode<StructureDefinition> wrap = nothing
	boolean found = SearchBinaryTreeForPayload<StructureDefinition>(StructuresWhichExist, name, wrap)
	assert(found)

	SetStructureToTemplate(wrap)
}

SetStructureToTemplate : StructureDefinition ref struct
{
	struct.IsTemplate = true

	CreateStructureTemplateAndAttachParams(struct.Name, TemplateParameterQueue)

	// Reset template parameter queue
	list<TemplateParameter> dummylist = scratchtemplateparam, nothing
	TemplateParameterQueue = dummylist
}


PopPendingFunctionForInference : ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	hasnode = PopPendingFunctionForInferenceWorker(PendingInferenceFunctions, PendingInferenceFunctions.next, out)
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, list<FunctionDefinition> ref tail, ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	if(head.value.Name != 0)
	{
		ContextNode<FunctionDefinition> outwrap = head.value
		out = outwrap
		head = tail
		hasnode = true
	}
}

PopPendingFunctionForInferenceWorker : list<FunctionDefinition> ref head, nothing, ContextNode<FunctionDefinition> ref out -> boolean hasnode = false [nogc]
{
	assert(head.value.Name == 0)
}

PushPendingFunctionForInference : FunctionDefinition ref func [nogc]
{
	prepend<FunctionDefinition>(PendingInferenceFunctions, func)
}


DumpOverloadList : list<Overload> ref overloads
{
	DumpOverload(overloads.value)
	DumpOverloadList(overloads.next)
}


DumpOverload : Overload ref overload
{
	print(GetPooledString(GlobalStrings, overload.NormalName) ; " -> " ; GetPooledString(GlobalStrings, overload.MangledName))
}


CacheGlobalCodeBlock : list<Scope> ref scopes [nogc]
{
	if(scopes.value.Name == GlobalCodeBlockName)
	{
		GlobalScope.Wrapped = scopes.value
	}
	else
	{
		CacheGlobalCodeBlock(scopes.next)
	}
}
