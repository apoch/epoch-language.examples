//
// Epoch Compiler
// Compiler.epoch
//
// Monolithic self-hosting compiler
//
// Support for separate compilation is desirable so this file is less of a mess.
//

CloseHandle : integer handle -> boolean ret = false [external("Kernel32.dll", "CloseHandle", "stdcall")]
CreateFile : string filename, integer access, integer sharemode, integer attributes, integer creation, integer flags, integer template -> integer ret = 0 [external("Kernel32.dll", "CreateFileW", "stdcall")]
CreateFileMapping : integer filehandle, integer attributes, integer protection, integer maxsizehigh, integer maxsizelow, integer name -> integer ret = 0 [external("Kernel32.dll", "CreateFileMappingW", "stdcall")]
MapViewOfFile : integer handle, integer access, integer offsethigh, integer offsetlow, integer bytestomap -> integer ptr = 0 [external("Kernel32.dll", "MapViewOfFile", "stdcall")]
UnmapViewOfFile : integer ptr -> boolean ret = false [external("Kernel32.dll", "UnmapViewOfFile", "stdcall")]
GetFileSize : integer handle, integer ignored -> integer size = 0 [external("Kernel32.dll", "GetFileSize", "stdcall")]
SetCurrentDirectory : string path -> boolean success = false [external("Kernel32.dll", "SetCurrentDirectoryW", "stdcall")]

timeGetTime : -> integer ms = 0 [external("WinMM.dll", "timeGetTime", "stdcall")]

ExecuteByteCodeBuffer : buffer ref code, integer len [external("EpochRuntime.dll", "ExecuteByteCodeDeferred", "stdcall")]


entrypoint :
{
	print("Epoch Language Project")
	print("Command line compiler and tools interface")
	print("")

	if(cmdlineisvalid() && (cmdlinegetcount() > 1))
	{
		boolean makeproject = false

		string filename = cmdlineget(1)
		if((length(filename) > 5) && (substring(filename, length(filename) - 5) == ".eprj"))
		{
			makeproject = true
		}
		else
		{
			print("Executing: " ; filename)
			print("")
		}

		PrepareStringTable()
		InitBuiltInOverloads()

		if(makeproject)
		{
			ChangeToPath(filename)
			CompileProject(filename)
		}
		else
		{
			if(CompileFile(filename))
			{
				ExecuteByteCodeBuffer(Hack, HackSize)		
			}
		}
	}
	else
	{
		print("Please specify a program to execute!")
	}
}


ChangeToPath : string filename
{
	if(!stringcontains(filename, "\"))
	{
		return()
	}
	
	integer pos = length(filename) - 1
	while(charat(filename, pos) != "\")
	{
		--pos
	}
	
	string path = substring(filename, 0, pos)
	SetCurrentDirectory(path)
}


ParseFile : string filename -> boolean success = false
{
	integer len = 0
	string contents = ReadFile(filename, len)

	if(len == 0)
	{
		return()
	}
	
	success = Parse(contents, len)
}


CompileProject : string filename
{	
	simplelist<string> emptysourcefilelist = "", nothing
	simplelist<string> emptyresourcefilelist = "", nothing
	EpochProject project = "", "project.exe", emptysourcefilelist, emptyresourcefilelist, false

	ParseProjectFile(filename, project)

	print("Parsing source code...")
	boolean parseok = ProjectParseAllCode(project.SourceFiles)	
	if(!parseok)
	{
		return()
	}

	print("Performing semantic analysis...")
	boolean irok = IRProcess()
	if(!irok)
	{
		return()
	}

	print("Generating code...")
	OnCodeGenProcessProgram()
	
	print("Writing executable file...")
	MakeExe(project)
}

//
// Helper for traversing the list of files in a project
// and passing each in turn to the Epoch parser
//
ProjectParseAllCode : simplelist<string> ref files -> boolean success = true
{
	if(files.value != "")
	{
		print(files.value)
		if(!ParseFile(files.value))
		{
			success = false
		}
	}
	
	if(!ProjectParseAllCode(files.next))
	{
		success = false
	}
}

ProjectParseAllCode : nothing -> true


CompileFile : string filename -> boolean success = false
{
	integer len = 0
	string contents = ReadFile(filename, len)

	if(len == 0)
	{
		return()
	}

	integer startparsems = timeGetTime()
	boolean parseok = Parse(contents, len)
	integer durationparsems = timeGetTime() - startparsems

	print("Parsing completed in " ; cast(string, durationparsems) ; " milliseconds")
	if(!parseok)
	{
		return()
	}

	integer startprocessms = timeGetTime()
	boolean irok = IRProcess()
	integer durationprocessms = timeGetTime() - startprocessms

	print("Semantic analysis completed in " ; cast(string, durationprocessms) ; " milliseconds")
	if(!irok)
	{
		return()
	}

	integer startcodegenms = timeGetTime()
	OnCodeGenProcessProgram()
	integer durationcodegenms = timeGetTime() - startcodegenms

	print("Code generation completed in " ; cast(string, durationcodegenms) ; " milliseconds")
	print("")

	success = true
}



PopContext : list<ContextStackEntry> ref stack, list<ContextStackEntry> ref next
{
	stack = next
}

PopContext : list<ContextStackEntry> ref stack, nothing
{
	print("No contexts available")
	assert(false)
}

PopExpression : list<Expression> ref thelist, list<Expression> ref next
{
	thelist = next
}

PopExpression : list<Expression> ref thelist, nothing



PopCodeBlock : list<OptionalCodeBlock> ref stack, list<OptionalCodeBlock> ref next
{
	stack = next
}

PopCodeBlock : list<OptionalCodeBlock> ref stack, nothing
{
	list<OptionalCodeBlock> newlist = nothing, nothing
	stack = newlist
}


PopEntityStack : list<Entity> ref stack, list<Entity> ref next
{
	stack = next
}

PopEntityStack : list<Entity> ref stack, nothing


PopChain : list<EntityChain> ref stack, list<EntityChain> ref next
{
	stack = next
}

PopChain : list<EntityChain> ref stack, nothing



PopCurrentStatementAndAppendToScratchExpression : list<Expression> ref expressions, list<Expression> ref tail
{
	ExpressionAtom atom = SubStatements.value

	expressions = tail

	PlaceAtomInScratchExpression(atom)
	PopSubStatement(SubStatements, SubStatements.next)
}

SetGlobalCodeBlock : CodeBlock ref block
{
	GlobalCodeBlock = block
}

SetGlobalCodeBlock : nothing


PopSubStatement : list<Statement> ref statements, list<Statement> ref tail
{
	statements = tail
}




FindScopeAndSetContext : FunctionDefinition ref func [nogc]
{
	EmittingScope.Wrapped = func.AttachedScope.Wrapped
}






CountTagParams : list<string> ref params -> integer count = 0 [nogc]
{
	count = CountTagParams(params.next)
	if(params.value != "")
	{
		++count
	}
}

CountTagParams : nothing -> integer count = 0 [nogc]



FindLastPreOpAndAppendCompoundMemberHelper : CodeBlock ref codeblock, integer operand
{
	FindLastPreOpAndAppendCompoundMember(codeblock.Entries, codeblock.Entries.next, operand)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, list<CodeBlockEntry> ref tail, integer membername
{
	FindLastPreOpAndAppendCompoundMember(tail, tail.next, membername)
}

FindLastPreOpAndAppendCompoundMember : list<CodeBlockEntry> ref entries, nothing, integer membername
{
	AppendCompoundMemberHelper(entries.value, membername)
}

